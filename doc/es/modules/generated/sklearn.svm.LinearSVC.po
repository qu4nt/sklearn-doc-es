msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 12:43-0400\n"
"PO-Revision-Date: 2021-06-27 04:33\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/generated/sklearn.svm.LinearSVC.po\n"
"X-Crowdin-File-ID: 5904\n"
"Language: es_ES\n"

#: ../modules/generated/sklearn.svm.LinearSVC.rst:2
msgid ":mod:`sklearn.svm`.LinearSVC"
msgstr ":mod:`sklearn.svm`.LinearSVC"

#: of sklearn.svm._classes.LinearSVC:2
msgid "Linear Support Vector Classification."
msgstr "Clasificación Lineal por Vectores de Soporte."

#: of sklearn.svm._classes.LinearSVC:4
msgid "Similar to SVC with parameter kernel='linear', but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples."
msgstr "Similar a SVC con el parámetro kernel='linear', pero implementado en términos de liblinear en lugar de libsvm, por lo que tiene más flexibilidad en la elección de las penalidades y funciones de pérdida y debería escalar mejor a un gran número de muestras."

#: of sklearn.svm._classes.LinearSVC:9
msgid "This class supports both dense and sparse input and the multiclass support is handled according to a one-vs-the-rest scheme."
msgstr "Esta clase soporta entradas densas y dispersas y el soporte multiclase es manejado de acuerdo a un esquema uno contra el resto."

#: of sklearn.svm._classes.LinearSVC:12
msgid "Read more in the :ref:`User Guide <svm_classification>`."
msgstr "Más información en el :ref:`Manual de usuario <svm_classification>`."

#: of sklearn.base.BaseEstimator.get_params
#: sklearn.base.BaseEstimator.set_params sklearn.base.ClassifierMixin.score
#: sklearn.linear_model._base.LinearClassifierMixin.decision_function
#: sklearn.linear_model._base.LinearClassifierMixin.predict
#: sklearn.svm._classes.LinearSVC sklearn.svm._classes.LinearSVC.fit
msgid "Parameters"
msgstr "Parámetros"

#: of sklearn.svm._classes.LinearSVC:19
msgid "**penalty**"
msgstr "**penalty**"

#: of
msgid "{'l1', 'l2'}, default='l2'"
msgstr "{'l1', 'l2'}, default='l2'"

#: of sklearn.svm._classes.LinearSVC:17
msgid "Specifies the norm used in the penalization. The 'l2' penalty is the standard used in SVC. The 'l1' leads to ``coef_`` vectors that are sparse."
msgstr "Específica la norma usada en la penalización. La penalidad 'l2' es el estandar usado en SVC. El 'l1' lleva a vectores ``coef_`` que son dispersos."

#: of sklearn.svm._classes.LinearSVC:25
msgid "**loss**"
msgstr "**loss**"

#: of
msgid "{'hinge', 'squared_hinge'}, default='squared_hinge'"
msgstr "{'hinge', 'squared_hinge'}, default='squared_hinge'"

#: of sklearn.svm._classes.LinearSVC:22
msgid "Specifies the loss function. 'hinge' is the standard SVM loss (used e.g. by the SVC class) while 'squared_hinge' is the square of the hinge loss. The combination of ``penalty='l1'`` and ``loss='hinge'`` is not supported."
msgstr "Específica la función de pérdida. 'bisagra' es la pérdida estándar SVM (utilizada por ejemplo por la clase SVC) mientras que 'squared_hinge' es el cuadrado de la pérdida de bisagra. La combinación de ``penalty='l1'`` y ``loss='hinge'`` no está soportada."

#: of sklearn.svm._classes.LinearSVC:29
msgid "**dual**"
msgstr "**dual**"

#: of
msgid "bool, default=True"
msgstr "booleano, default=True"

#: of sklearn.svm._classes.LinearSVC:28
msgid "Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=False when n_samples > n_features."
msgstr "Seleccione el algoritmo para resolver el problema de optimización dual o primaria. Se prefiere dual=False cuando n_samples > n_features."

#: of sklearn.svm._classes.LinearSVC:32
msgid "**tol**"
msgstr "**tol**"

#: of
msgid "float, default=1e-4"
msgstr "flotante, default=1e-4"

#: of sklearn.svm._classes.LinearSVC:32
msgid "Tolerance for stopping criteria."
msgstr "Tolerancia para el criterio de parada."

#: of sklearn.linear_model._base.LinearClassifierMixin.predict:24
#: sklearn.svm._classes.LinearSVC:36
msgid "**C**"
msgstr "**C**"

#: of
msgid "float, default=1.0"
msgstr "flotante, default=1.0"

#: of sklearn.svm._classes.LinearSVC:35
msgid "Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive."
msgstr "Parámetro de regularización. La fuerza de la regularización es inversamente proporcional a C. Debe ser estrictamente positiva."

#: of sklearn.svm._classes.LinearSVC:47
msgid "**multi_class**"
msgstr "**multi_class**"

#: of
msgid "{'ovr', 'crammer_singer'}, default='ovr'"
msgstr "{'ovr', 'crammer_singer'}, default='ovr'"

#: of sklearn.svm._classes.LinearSVC:39
msgid "Determines the multi-class strategy if `y` contains more than two classes. ``\"ovr\"`` trains n_classes one-vs-rest classifiers, while ``\"crammer_singer\"`` optimizes a joint objective over all classes. While `crammer_singer` is interesting from a theoretical perspective as it is consistent, it is seldom used in practice as it rarely leads to better accuracy and is more expensive to compute. If ``\"crammer_singer\"`` is chosen, the options loss, penalty and dual will be ignored."
msgstr "Determina la estrategia multiclase si `y` contiene más que dos clases. ``\"ovr\"`` entrena clasificadores n_classes uno contra el resto, mientras que ``\"crammer_singer\"`` optimiza un objetivo conjunto sobre todas las clases. Mientras que `crammer_singer` es interesante desde una perspectiva teorica ya que es consistente, casí ni se usa en la practica ya que pocas veces lleva a mejor precisión y es mas cara para calcular. Si se escoge ``\"crammer_singer\"``, las opciones loss, penalty y dual serán ignorados."

#: of sklearn.svm._classes.LinearSVC:52
msgid "**fit_intercept**"
msgstr "**fit_intercept**"

#: of sklearn.svm._classes.LinearSVC:50
msgid "Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be already centered)."
msgstr "Si se calcula el intercepto para este modelo. Si se establece en False, no se utilizará ningún intercepto en los cálculos (es decir, se espera que los datos ya estén centrados)."

#: of sklearn.svm._classes.LinearSVC:63
msgid "**intercept_scaling**"
msgstr "**intercept_scaling**"

#: of
msgid "float, default=1"
msgstr "flotante, default=1"

#: of sklearn.svm._classes.LinearSVC:55
msgid "When self.fit_intercept is True, instance vector x becomes ``[x, self.intercept_scaling]``, i.e. a \"synthetic\" feature with constant value equals to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic feature weight Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased."
msgstr "Cuando self.fit_intercept es True, la instancia vector y se vuelve [x, self.intercept_scaling], es decir, una característica \"synthetic\" con valor constante igual a intercept_scaling se adjunta al vector de instancia. El intercepto se vuelve intercept_scaling * synthetic feature weight. Nota! El ponderado de característica sintetica es sujeto a la regularización l1/l2 como todás las demás características. Para disminuir el efecto de la regularización en el ponderado de características synteticas (y por lo tanto, en el intercepto) intercept_scaling debe ser incrementado."

#: of sklearn.svm._classes.LinearSVC:71
msgid "**class_weight**"
msgstr "**class_weight**"

#: of
msgid "dict or 'balanced', default=None"
msgstr "dict or 'balanced', default=None"

#: of sklearn.svm._classes.LinearSVC:66
msgid "Set the parameter C of class i to ``class_weight[i]*C`` for SVC. If not given, all classes are supposed to have weight one. The \"balanced\" mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as ``n_samples / (n_classes * np.bincount(y))``."
msgstr "Establece el parámetro C de la clase i a ``class_weight[i]*C`` para SVC. Si no es dado, todas las clases se suponen que tienen peso uno. El modo \"balanced\" utiliza los valores de y para ajustar automáticamente los ponderados inversamente proporcionales a las frecuencias de clase en los datos de entrada como ``n_samples / (n_classes * np.bincount(y))``."

#: of sklearn.svm._classes.LinearSVC:76
msgid "**verbose**"
msgstr "**verbose**"

#: of
msgid "int, default=0"
msgstr "entero, default=0"

#: of sklearn.svm._classes.LinearSVC:74
msgid "Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in liblinear that, if enabled, may not work properly in a multithreaded context."
msgstr "Activar salida detallada. Tenga en cuenta que esta configuración toma ventaja de una configuración por proceso en el tiempo de ejecución en liblinear que, si está habilitada, puede no funcionar correctamente en un contexto multihilo."

#: of sklearn.svm._classes.LinearSVC:84
msgid "**random_state**"
msgstr "**random_state**"

#: of
msgid "int, RandomState instance or None, default=None"
msgstr "int, instancia RandomState o None, por defecto=None"

#: of sklearn.svm._classes.LinearSVC:79
msgid "Controls the pseudo random number generation for shuffling the data for the dual coordinate descent (if ``dual=True``). When ``dual=False`` the underlying implementation of :class:`LinearSVC` is not random and ``random_state`` has no effect on the results. Pass an int for reproducible output across multiple function calls. See :term:`Glossary <random_state>`."
msgstr "Controla la generación de números pseudo-aleatorios para revolver los datos para el descenso de coordenadas duales (si ``dual=True``). Cuando ``dual=False`` la implementación subyacente de :class:`LinearSVC` no es aleatoria y ``random_state`` no tiene efecto sobre los resultados. Pase un int para salida reproducible a través de múltiples llamadas de función. Vea :term:`Glosario <random_state>`."

#: of sklearn.svm._classes.LinearSVC:90
msgid "**max_iter**"
msgstr "**max_iter**"

#: of
msgid "int, default=1000"
msgstr "entero, default=1000"

#: of sklearn.svm._classes.LinearSVC:87
msgid "The maximum number of iterations to be run."
msgstr "Número máximo de iteraciones a correr."

#: of sklearn.svm._classes.LinearSVC
msgid "Attributes"
msgstr "Atributos"

#: of sklearn.svm._classes.LinearSVC:99
msgid "**coef_**"
msgstr "**coef_**"

#: of
msgid "ndarray of shape (1, n_features) if n_classes == 2             else (n_classes, n_features)"
msgstr "ndarray de forma (1, n_features) if n_classes == 2 else             (n_classes, n_features)"

#: of sklearn.svm._classes.LinearSVC:95
msgid "Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel."
msgstr "Ponderados asignados a las características (coeficientes en el problema primario). Esto solo está disponible en el caso de un núcleo lineal."

#: of sklearn.svm._classes.LinearSVC:98
msgid "``coef_`` is a readonly property derived from ``raw_coef_`` that follows the internal memory layout of liblinear."
msgstr "``coef_`` es una propiedad de sólo lectura derivada de ``raw_coef_`` que sigue el diseño de memoria interna de liblinear."

#: of sklearn.svm._classes.LinearSVC:102
msgid "**intercept_**"
msgstr "**intercept_**"

#: of
msgid "ndarray of shape (1,) if n_classes == 2 else (n_classes,)"
msgstr "ndarray of shape (1,) if n_classes == 2 else (n_classes,)"

#: of sklearn.svm._classes.LinearSVC:102
msgid "Constants in decision function."
msgstr "Constantes en la función de decisión."

#: of sklearn.svm._classes.LinearSVC:105
msgid "**classes_**"
msgstr "**classes_**"

#: of
msgid "ndarray of shape (n_classes,)"
msgstr "ndarray de forma (n_classes,)"

#: of sklearn.svm._classes.LinearSVC:105
msgid "The unique classes labels."
msgstr "Etiquetas de clase únicas."

#: of sklearn.svm._classes.LinearSVC:111
msgid "**n_iter_**"
msgstr "**n_iter_**"

#: of
msgid "int"
msgstr "entero"

#: of sklearn.svm._classes.LinearSVC:108
msgid "Maximum number of iterations run across all classes."
msgstr "Número máximo de iteraciones ejecutadas en todas las clases."

#: of sklearn.svm._classes.LinearSVC:116
msgid ":obj:`SVC`"
msgstr ":obj:`SVC`"

#: of sklearn.svm._classes.LinearSVC:117
msgid "Implementation of Support Vector Machine classifier using libsvm: the kernel can be non-linear but its SMO algorithm does not scale to large number of samples as LinearSVC does. Furthermore SVC multi-class mode is implemented using one vs one scheme while LinearSVC uses one vs the rest. It is possible to implement one vs the rest with SVC by using the :class:`~sklearn.multiclass.OneVsRestClassifier` wrapper. Finally SVC can fit dense data without memory copy if the input is C-contiguous. Sparse data will still incur memory copy though."
msgstr "Implementación del clasificador de Maquina de Vectores de Soporte usando libsvm: el núcleo puede ser no-lineal pero su algoritmo SMO no escala a un número grande de muestras como LinearSVC lo hace. Además, el modo SVC multiclase es implementado utilizando un esquema uno contra uno mientras que LinearSVC utiliza uno contra el resto. Es posible implementar uno contra el resto con SVC utilizando el envoltorio :class:`~sklearn.multiclass.OneVsRestClassifier`. Finalmente SVC puede ajustar datos densos sin copia de memoria si la entrada es contingua con C. Sin embargo, los datos dispersos igual incurrirán en la copia de memoria."

#: of sklearn.svm._classes.LinearSVC:118
msgid ":obj:`sklearn.linear_model.SGDClassifier`"
msgstr ":obj:`sklearn.linear_model.SGDClassifier`"

#: of sklearn.svm._classes.LinearSVC:119
msgid "SGDClassifier can optimize the same cost function as LinearSVC by adjusting the penalty and loss parameters. In addition it requires less memory, allows incremental (online) learning, and implements various loss functions and regularization regimes."
msgstr "SGDClassifier puede optimizar la misma función de costo que LinearSVC ajustando los parámetros de penalización y pérdida. Además requiere menos memoria, permite un aprendizaje incremental (en línea) e implementa varias funciones de pérdida y regimenes de regularización."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:24
#: sklearn.svm._classes.LinearSVC:123
msgid "Notes"
msgstr "Notas"

#: of sklearn.svm._classes.LinearSVC:124
msgid "The underlying C implementation uses a random number generator to select features when fitting the model. It is thus not uncommon to have slightly different results for the same input data. If that happens, try with a smaller ``tol`` parameter."
msgstr "La implementación C subyacente utiliza un generador de números aleatorios para seleccionar características al ajustar el modelo. Por lo tanto, no es raro tener resultados ligeramente diferentes para los mismos datos de entrenamiento. Si eso sucede, intente con un parámetro ``tol`` más pequeño."

#: of sklearn.svm._classes.LinearSVC:129
msgid "The underlying implementation, liblinear, uses a sparse internal representation for the data that will incur a memory copy."
msgstr "La implementación subyacente, liblinear, utiliza una representación interna dispersa para los datos que incurrirán en una copia de memoria."

#: of sklearn.svm._classes.LinearSVC:132
msgid "Predict output may not match that of standalone liblinear in certain cases. See :ref:`differences from liblinear <liblinear_differences>` in the narrative documentation."
msgstr "La salida predicha quizás no coincida con la del liblinear independiente en ciertos casos. Vea :ref:`diferencias con el liblinear <liblinear_differences>` en la documentación narrativa."

#: of sklearn.svm._classes.LinearSVC:137
msgid "References"
msgstr "Referencias"

#: of sklearn.svm._classes.LinearSVC:138
msgid "`LIBLINEAR: A Library for Large Linear Classification <https://www.csie.ntu.edu.tw/~cjlin/liblinear/>`__"
msgstr "`LIBLINEAR: A Library for Large Linear Classification <https://www.csie.ntu.edu.tw/~cjlin/liblinear/>`__"

#: of sklearn.svm._classes.LinearSVC:146
msgid "Examples"
msgstr "Ejemplos"

#: of sklearn.svm._classes.LinearSVC:167
msgid "Methods"
msgstr "Métodos"

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`decision_function <sklearn.svm.LinearSVC.decision_function>`\\"
msgstr ":obj:`decision_function <sklearn.svm.LinearSVC.decision_function>`\\"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Predict confidence scores for samples."
msgstr "Predice las puntuaciones de confianza para las muestras."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`densify <sklearn.svm.LinearSVC.densify>`\\"
msgstr ":obj:`densify <sklearn.svm.LinearSVC.densify>`\\"

#: of sklearn.linear_model._base.SparseCoefMixin.densify:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Convert coefficient matrix to dense array format."
msgstr "Convierte la matriz de coeficientes en formato de arreglo denso."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`fit <sklearn.svm.LinearSVC.fit>`\\"
msgstr ":obj:`fit <sklearn.svm.LinearSVC.fit>`\\"

#: of sklearn.svm._classes.LinearSVC.fit:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Fit the model according to the given training data."
msgstr "Ajusta el modelo de acuerdo a los datos de entrenamiento dados."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`get_params <sklearn.svm.LinearSVC.get_params>`\\"
msgstr ":obj:`get_params <sklearn.svm.LinearSVC.get_params>`\\"

#: of sklearn.base.BaseEstimator.get_params:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Get parameters for this estimator."
msgstr "Obtiene los parámetros para este estimador."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`predict <sklearn.svm.LinearSVC.predict>`\\"
msgstr ":obj:`predict <sklearn.svm.LinearSVC.predict>`\\"

#: of sklearn.linear_model._base.LinearClassifierMixin.predict:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Predict class labels for samples in X."
msgstr "Predice las etiquetas de clase para las muestras en X."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`score <sklearn.svm.LinearSVC.score>`\\"
msgstr ":obj:`score <sklearn.svm.LinearSVC.score>`\\"

#: of sklearn.base.ClassifierMixin.score:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Return the mean accuracy on the given test data and labels."
msgstr "Devuelve la precisión media en los datos de prueba y las etiquetas dados."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`set_params <sklearn.svm.LinearSVC.set_params>`\\"
msgstr ":obj:`set_params <sklearn.svm.LinearSVC.set_params>`\\"

#: of sklearn.base.BaseEstimator.set_params:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Set the parameters of this estimator."
msgstr "Establece los parámetros de este estimador."

#: of sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid ":obj:`sparsify <sklearn.svm.LinearSVC.sparsify>`\\"
msgstr ":obj:`sparsify <sklearn.svm.LinearSVC.sparsify>`\\"

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:2
#: sklearn.svm._classes.LinearSVC:178:<autosummary>:1
msgid "Convert coefficient matrix to sparse format."
msgstr "Convierte la matriz de coeficientes en formato disperso."

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:4
msgid "The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane."
msgstr "La puntuación de confianza de una muestra es proporcional a la distancia con signo de esa muestra al hiperplano."

#: of sklearn.base.ClassifierMixin.score:11
#: sklearn.linear_model._base.LinearClassifierMixin.decision_function:10
#: sklearn.linear_model._base.LinearClassifierMixin.predict:8
#: sklearn.svm._classes.LinearSVC.fit:9
msgid "**X**"
msgstr "**X**"

#: of
msgid "array-like or sparse matrix, shape (n_samples, n_features)"
msgstr "array-like o sparse matrix, forma (n_samples, n_features)"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:10
#: sklearn.linear_model._base.LinearClassifierMixin.predict:8
msgid "Samples."
msgstr "Muestras."

#: of sklearn.base.BaseEstimator.get_params
#: sklearn.base.BaseEstimator.set_params sklearn.base.ClassifierMixin.score
#: sklearn.linear_model._base.LinearClassifierMixin.decision_function
#: sklearn.linear_model._base.LinearClassifierMixin.predict
#: sklearn.linear_model._base.SparseCoefMixin.densify
#: sklearn.linear_model._base.SparseCoefMixin.sparsify
#: sklearn.svm._classes.LinearSVC.fit
msgid "Returns"
msgstr "Salida"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:28
msgid "array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)"
msgstr "array, forma=(n_samples,) si n_classes == 2 de lo contrario (n_samples, n_classes)"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:15
msgid "Confidence scores per (sample, class) combination. In the binary case, confidence score for self.classes_[1] where >0 means this class would be predicted."
msgstr "Puntuaciones de confianza por combinación (sample, class). En el caso binario, la puntuación de confianza para self.classes_[1] donde >0 significa que esta clase sería predicha."

#: of sklearn.linear_model._base.SparseCoefMixin.densify:4
msgid "Converts the ``coef_`` member (back) to a numpy.ndarray. This is the default format of ``coef_`` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op."
msgstr "Convierte el miembro ``coef_`` (de vuelta) en un numpy.ndarray. Este es el formato por defecto de ``coef_`` y se requiere para el ajuste, por lo que invocar este método sólo es necesario en los modelos que han sido previamente dispersados (sparsified); de lo contrario, es un no-op."

#: of sklearn.linear_model._base.SparseCoefMixin.densify:24
#: sklearn.linear_model._base.SparseCoefMixin.sparsify:21
msgid "self"
msgstr "self"

#: of sklearn.linear_model._base.SparseCoefMixin.densify:13
#: sklearn.linear_model._base.SparseCoefMixin.sparsify:14
msgid "Fitted estimator."
msgstr "Estimador ajustado."

#: of
msgid "{array-like, sparse matrix} of shape (n_samples, n_features)"
msgstr "{array-like, sparse matrix} de forma (n_samples, n_features)"

#: of sklearn.svm._classes.LinearSVC.fit:8
msgid "Training vector, where n_samples in the number of samples and n_features is the number of features."
msgstr "Vector de entrenamiento, donde n_samples es el número de muestras y n_features es el número de características."

#: of sklearn.base.ClassifierMixin.score:14
#: sklearn.svm._classes.LinearSVC.fit:12
msgid "**y**"
msgstr "**y**"

#: of
msgid "array-like of shape (n_samples,)"
msgstr "arrelgo tipo de forma (n_samples,)"

#: of sklearn.svm._classes.LinearSVC.fit:12
msgid "Target vector relative to X."
msgstr "Vector objetivo relativo a X."

#: of sklearn.base.ClassifierMixin.score:17
#: sklearn.svm._classes.LinearSVC.fit:19
msgid "**sample_weight**"
msgstr "**sample_weight**"

#: of
msgid "array-like of shape (n_samples,), default=None"
msgstr "tipo de arreglo de forma (n_samples,) default=None"

#: of sklearn.svm._classes.LinearSVC.fit:15
msgid "Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight."
msgstr "Arreglo de pesos asignados a muestras individuales. Si no se proporciona, cada muestra se da un ponderado unitario."

#: of sklearn.base.BaseEstimator.set_params:28
#: sklearn.svm._classes.LinearSVC.fit:35
msgid "**self**"
msgstr "**self**"

#: of
msgid "object"
msgstr "objeto"

#: of sklearn.svm._classes.LinearSVC.fit:24
msgid "An instance of the estimator."
msgstr "Una instancia del estimador."

#: of sklearn.base.BaseEstimator.get_params:9
msgid "**deep**"
msgstr "**deep**"

#: of sklearn.base.BaseEstimator.get_params:8
msgid "If True, will return the parameters for this estimator and contained subobjects that are estimators."
msgstr "Si es True, devolverá los parámetros para este estimador y los sub objetos contenidos que son estimadores."

#: of sklearn.base.BaseEstimator.get_params:25
msgid "**params**"
msgstr "**params**"

#: of
msgid "dict"
msgstr "dict"

#: of sklearn.base.BaseEstimator.get_params:14
msgid "Parameter names mapped to their values."
msgstr "Los nombres de los parámetros asignados a sus valores."

#: of
msgid "array, shape [n_samples]"
msgstr "array, forma [n_samples]"

#: of sklearn.linear_model._base.LinearClassifierMixin.predict:13
msgid "Predicted class label per sample."
msgstr "Etiqueta de clase predicha por muestra."

#: of sklearn.base.ClassifierMixin.score:4
msgid "In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted."
msgstr "En la clasificación multietiqueta, se trata de la precisión del subconjunto que es una métrica rigurosa, ya que se requiere para cada muestra que cada conjunto de etiquetas sea predicho correctamente."

#: of
msgid "array-like of shape (n_samples, n_features)"
msgstr "array-like de forma (n_samples_X, n_features)"

#: of sklearn.base.ClassifierMixin.score:11
msgid "Test samples."
msgstr "Muestras de prueba."

#: of
msgid "array-like of shape (n_samples,) or (n_samples, n_outputs)"
msgstr "tipo de arreglo de forma (n_samples,) o (n_samples, n_outputs)"

#: of sklearn.base.ClassifierMixin.score:14
msgid "True labels for `X`."
msgstr "Etiquetas True para `X`."

#: of sklearn.base.ClassifierMixin.score:17
msgid "Sample weights."
msgstr "Ponderaciones de muestras."

#: of sklearn.base.ClassifierMixin.score:33
msgid "**score**"
msgstr "**score**"

#: of
msgid "float"
msgstr "de punto flotante (float)"

#: of sklearn.base.ClassifierMixin.score:22
msgid "Mean accuracy of ``self.predict(X)`` wrt. `y`."
msgstr "Precisión media de ``self.predict(X)`` con respecto a `y`."

#: of sklearn.base.BaseEstimator.set_params:4
msgid "The method works on simple estimators as well as on nested objects (such as :class:`~sklearn.pipeline.Pipeline`). The latter have parameters of the form ``<component>__<parameter>`` so that it's possible to update each component of a nested object."
msgstr "El método funciona tanto con estimadores simples como en objetos anidados (como :class:`~sklearn.pipeline.Pipeline`). Estos últimos tienen parámetros de la forma ``<component>__<parameter>`` para que sea posible actualizar cada componente de un objeto anidado."

#: of sklearn.base.BaseEstimator.set_params:12
msgid "**\\*\\*params**"
msgstr "**\\*\\*params**"

#: of sklearn.base.BaseEstimator.set_params:12
msgid "Estimator parameters."
msgstr "Parámetros del estimador."

#: of
msgid "estimator instance"
msgstr "instancia del estimador"

#: of sklearn.base.BaseEstimator.set_params:17
msgid "Estimator instance."
msgstr "Instancia de estimador."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:4
msgid "Converts the ``coef_`` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation."
msgstr "Convierte el miembro ``coef_`` en una matriz scipy.sparse, que para los modelos L1-regularizados puede ser mucho más eficiente en cuanto a memoria y almacenamiento que la representación numpy.ndarray habitual."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:8
msgid "The ``intercept_`` member is not converted."
msgstr "El miembro ``intercept_`` no se convierte."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:25
#, python-format
msgid "For non-sparse models, i.e. when there are not many zeros in ``coef_``, this may actually *increase* memory usage, so use this method with care. A rule of thumb is that the number of zero elements, which can be computed with ``(coef_ == 0).sum()``, must be more than 50% for this to provide significant benefits."
msgstr "Para los modelos no dispersos, es decir, cuando no hay muchos ceros en ``coef_``, esto puede en realidad *aumentar* el uso de la memoria, así que utilice este método con cuidado. Una regla general es que el número de elementos cero, que puede ser calculado con ``(coef_ == 0).sum()``, debe ser más del 50% para que esto proporcione beneficios significativos."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:31
msgid "After calling this method, further fitting with the partial_fit method (if any) will not work until you call densify."
msgstr "Después de invocar a este método, el ajuste posterior con el método partial_fit (si lo hay) no funcionará hasta que llame a densify."

#: ../modules/generated/sklearn.svm.LinearSVC.examples:4
msgid "Examples using ``sklearn.svm.LinearSVC``"
msgstr "Ejemplos con ``sklearn.svm.LinearSVC``"

#: ../modules/generated/sklearn.svm.LinearSVC.examples:15
#: ../modules/generated/sklearn.svm.LinearSVC.examples:23
msgid ":ref:`sphx_glr_auto_examples_release_highlights_plot_release_highlights_0_22_0.py`"
msgstr ":ref:`sphx_glr_auto_examples_release_highlights_plot_release_highlights_0_22_0.py`"

#~ msgid ":ref:`sphx_glr_auto_examples_feature_selection_plot_feature_selection_pipeline.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_feature_selection_plot_feature_selection.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_kernel_approximation_plot_scalable_poly_kernels.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_miscellaneous_plot_kernel_approximation.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_model_selection_plot_det.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_model_selection_plot_grid_search_refit_callable.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_model_selection_plot_precision_recall.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_compose_plot_compare_reduction.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_compose_plot_column_transformer.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_svm_plot_linearsvc_support_vectors.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_svm_plot_iris_svc.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_svm_plot_svm_scale_c.py`"
#~ msgstr ""

#~ msgid ":ref:`sphx_glr_auto_examples_text_plot_document_classification_20newsgroups.py`"
#~ msgstr ""

