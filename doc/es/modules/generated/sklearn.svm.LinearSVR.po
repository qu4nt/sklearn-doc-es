msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 11:24-0400\n"
"PO-Revision-Date: 2021-07-25 02:54\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/generated/sklearn.svm.LinearSVR.po\n"
"X-Crowdin-File-ID: 5558\n"
"Language: es_ES\n"

#: ../modules/generated/sklearn.svm.LinearSVR.rst:2
msgid ":mod:`sklearn.svm`.LinearSVR"
msgstr ":mod:`sklearn.svm`.LinearSVR"

#: of sklearn.svm._classes.LinearSVR:2
msgid "Linear Support Vector Regression."
msgstr "Regresión de Vector de Soporte Lineal."

#: of sklearn.svm._classes.LinearSVR:4
msgid "Similar to SVR with parameter kernel='linear', but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples."
msgstr "Similar a SVR con el parámetro kernel='linear', pero implementado en términos de liblinear en lugar de libsvm, por lo que tiene más flexibilidad en la elección de las penalidades y funciones de pérdida y debería escalar mejor a un gran número de muestras."

#: of sklearn.svm._classes.LinearSVR:9
msgid "This class supports both dense and sparse input."
msgstr "Esta clase soporta entradas densas y dispersas."

#: of sklearn.svm._classes.LinearSVR:11
msgid "Read more in the :ref:`User Guide <svm_regression>`."
msgstr "Lee más en el :ref:`Manual de usuario <svm_regression>`."

#: of sklearn.base.BaseEstimator.get_params
#: sklearn.base.BaseEstimator.set_params sklearn.base.RegressorMixin.score
#: sklearn.linear_model._base.LinearModel.predict
#: sklearn.svm._classes.LinearSVR sklearn.svm._classes.LinearSVR.fit
msgid "Parameters"
msgstr "Parámetros"

#: of sklearn.svm._classes.LinearSVR:20
msgid "**epsilon**"
msgstr "**epsilon**"

#: of
msgid "float, default=0.0"
msgstr "flotante, default=0.0"

#: of sklearn.svm._classes.LinearSVR:18
msgid "Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y. If unsure, set ``epsilon=0``."
msgstr "Parámetro épsilon en la función de pérdida insensibles a épsilon. Tenga en cuenta que el valor de este parámetro depende de la escala de la variable de destino y. Si no está seguro, establezca ``epsilon=0``."

#: of sklearn.svm._classes.LinearSVR:23
msgid "**tol**"
msgstr "**tol**"

#: of
msgid "float, default=1e-4"
msgstr "flotante, default=1e-4"

#: of sklearn.svm._classes.LinearSVR:23
msgid "Tolerance for stopping criteria."
msgstr "Tolerancia para el criterio de parada."

#: of sklearn.linear_model._base.LinearModel.predict:24
#: sklearn.svm._classes.LinearSVR:27
msgid "**C**"
msgstr "**C**"

#: of
msgid "float, default=1.0"
msgstr "flotante, default=1.0"

#: of sklearn.svm._classes.LinearSVR:26
msgid "Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive."
msgstr "Parámetro de regularización. La fuerza de la regularización es inversamente proporcional a C. Debe ser estrictamente positiva."

#: of sklearn.svm._classes.LinearSVR:32
msgid "**loss**"
msgstr "**loss**"

#: of
msgid "{'epsilon_insensitive', 'squared_epsilon_insensitive'},             default='epsilon_insensitive'"
msgstr "{'epsilon_insensitive', 'squared_epsilon_insensitive'}, default='epsilon_insensitive'"

#: of sklearn.svm._classes.LinearSVR:30
msgid "Specifies the loss function. The epsilon-insensitive loss (standard SVR) is the L1 loss, while the squared epsilon-insensitive loss ('squared_epsilon_insensitive') is the L2 loss."
msgstr "Especifica la función de pérdida. La pérdida insensible a épsilon (estándar SVR) es la pérdida L1, mientras que la pérdida insensible a épsilon cuadrada ('squared_epsilon_insensitive') es la pérdida L2."

#: of sklearn.svm._classes.LinearSVR:37
msgid "**fit_intercept**"
msgstr "**fit_intercept**"

#: of
msgid "bool, default=True"
msgstr "booleano, default=True"

#: of sklearn.svm._classes.LinearSVR:35
msgid "Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be already centered)."
msgstr "Si se calcula el intercepto para este modelo. Si se establece en False, no se utilizará ningún intercepto en los cálculos (es decir, se espera que los datos ya estén centrados)."

#: of sklearn.svm._classes.LinearSVR:48
msgid "**intercept_scaling**"
msgstr "**intercept_scaling**"

#: of
msgid "float, default=1."
msgstr "flotante, default=1."

#: of sklearn.svm._classes.LinearSVR:40
msgid "When self.fit_intercept is True, instance vector x becomes [x, self.intercept_scaling], i.e. a \"synthetic\" feature with constant value equals to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic feature weight Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased."
msgstr "Cuando self.fit_intercept es True, la instancia vector y se vuelve [x, self.intercept_scaling], es decir, una característica \"synthetic\" con valor constante igual a intercept_scaling se adjunta al vector de instancia. El intercepto se vuelve intercept_scaling * synthetic feature weight. Nota! El ponderado de característica sintetica es sujeto a la regularización l1/l2 como todás las demás características. Para disminuir el efecto de la regularización en el ponderado de características synteticas (y por lo tanto, en el intercepto) intercept_scaling debe ser incrementado."

#: of sklearn.svm._classes.LinearSVR:52
msgid "**dual**"
msgstr "**dual**"

#: of sklearn.svm._classes.LinearSVR:51
msgid "Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=False when n_samples > n_features."
msgstr "Seleccione el algoritmo para resolver el problema de optimización dual o primaria. Se prefiere dual=False cuando n_samples > n_features."

#: of sklearn.svm._classes.LinearSVR:57
msgid "**verbose**"
msgstr "**verbose**"

#: of
msgid "int, default=0"
msgstr "entero, default=0"

#: of sklearn.svm._classes.LinearSVR:55
msgid "Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in liblinear that, if enabled, may not work properly in a multithreaded context."
msgstr "Activar salida detallada. Ten en cuenta que esta configuración toma ventaja de una configuración por proceso en el tiempo de ejecución en liblinear que, si está habilitada, puede no funcionar correctamente en un contexto multihilo."

#: of sklearn.svm._classes.LinearSVR:62
msgid "**random_state**"
msgstr "**random_state**"

#: of
msgid "int, RandomState instance or None, default=None"
msgstr "entero, instancia de RandomState o None, default=None"

#: of sklearn.svm._classes.LinearSVR:60
msgid "Controls the pseudo random number generation for shuffling the data. Pass an int for reproducible output across multiple function calls. See :term:`Glossary <random_state>`."
msgstr "Controla la generación de números pseudo aleatorios para revolver los datos. Pasa un int para salidas reproducibles a través de múltiples llamadas a la función. Ver el :term:`Glosario <random_state>`."

#: of sklearn.svm._classes.LinearSVR:68
msgid "**max_iter**"
msgstr "**max_iter**"

#: of
msgid "int, default=1000"
msgstr "entero, default=1000"

#: of sklearn.svm._classes.LinearSVR:65
msgid "The maximum number of iterations to be run."
msgstr "Número máximo de iteraciones a correr."

#: of sklearn.svm._classes.LinearSVR
msgid "Attributes"
msgstr "Atributos"

#: of sklearn.svm._classes.LinearSVR:77
msgid "**coef_**"
msgstr "**coef_**"

#: of
msgid "ndarray of shape (n_features) if n_classes == 2             else (n_classes, n_features)"
msgstr "ndarray de forma (n_features) si n_classes == 2 de lo contrario             (n_classes, n_features)"

#: of sklearn.svm._classes.LinearSVR:73
msgid "Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel."
msgstr "Ponderados asignados a las características (coeficientes en el problema primario). Esto solo está disponible en el caso de un núcleo lineal."

#: of sklearn.svm._classes.LinearSVR:76
msgid "`coef_` is a readonly property derived from `raw_coef_` that follows the internal memory layout of liblinear."
msgstr "`coef_` es una propiedad de sólo lectura derivada de `raw_coef_` que sigue el diseño de memoria interna de liblinear."

#: of sklearn.svm._classes.LinearSVR:80
msgid "**intercept_**"
msgstr "**intercept_**"

#: of
msgid "ndarray of shape (1) if n_classes == 2 else (n_classes)"
msgstr "ndarray de forma (1) si n_classes == 2 de lo contrario (n_classes)"

#: of sklearn.svm._classes.LinearSVR:80
msgid "Constants in decision function."
msgstr "Constantes en la función de decisión."

#: of sklearn.svm._classes.LinearSVR:86
msgid "**n_iter_**"
msgstr "**n_iter_**"

#: of
msgid "int"
msgstr "entero"

#: of sklearn.svm._classes.LinearSVR:83
msgid "Maximum number of iterations run across all classes."
msgstr "Número máximo de iteraciones ejecutadas en todas las clases."

#: of sklearn.svm._classes.LinearSVR:91
msgid ":obj:`LinearSVC`"
msgstr ":obj:`LinearSVC`"

#: of sklearn.svm._classes.LinearSVR:92
msgid "Implementation of Support Vector Machine classifier using the same library as this class (liblinear)."
msgstr "Implementación del clasificador Máquina de Vectores de Soporte usando la misma librería que esta clase (liblinear)."

#: of sklearn.svm._classes.LinearSVR:93
msgid ":obj:`SVR`"
msgstr ":obj:`SVR`"

#: of sklearn.svm._classes.LinearSVR:94
msgid "Implementation of Support Vector Machine regression using libsvm: the kernel can be non-linear but its SMO algorithm does not scale to large number of samples as LinearSVC does."
msgstr "Implementación de regresión por Maquina de Vectores de Soporte usando libsvm: el núcleo puede ser no lineal pero su algoritmo SMO no escala a un gran número de muestras como LinearSVC lo hace."

#: of sklearn.svm._classes.LinearSVR:95
msgid ":obj:`sklearn.linear_model.SGDRegressor`"
msgstr ":obj:`sklearn.linear_model.SGDRegressor`"

#: of sklearn.svm._classes.LinearSVR:96
msgid "SGDRegressor can optimize the same cost function as LinearSVR by adjusting the penalty and loss parameters. In addition it requires less memory, allows incremental (online) learning, and implements various loss functions and regularization regimes."
msgstr "SGDRegressor puede optimizar la misma función de costo que LinearSVR ajustando los parámetros de penalización y pérdida. Además requiere menos memoria, permite un aprendizaje incremental (en línea) e implementa varias funciones de pérdida y regimenes de regularización."

#: of sklearn.svm._classes.LinearSVR:102
msgid "Examples"
msgstr "Ejemplos"

#: of sklearn.svm._classes.LinearSVR:122
msgid "Methods"
msgstr "Métodos"

#: of sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid ":obj:`fit <sklearn.svm.LinearSVR.fit>`\\"
msgstr ":obj:`fit <sklearn.svm.LinearSVR.fit>`\\"

#: of sklearn.svm._classes.LinearSVR.fit:2
#: sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid "Fit the model according to the given training data."
msgstr "Ajusta el modelo de acuerdo a los datos de entrenamiento dados."

#: of sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid ":obj:`get_params <sklearn.svm.LinearSVR.get_params>`\\"
msgstr ":obj:`get_params <sklearn.svm.LinearSVR.get_params>`\\"

#: of sklearn.base.BaseEstimator.get_params:2
#: sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid "Get parameters for this estimator."
msgstr "Obtiene los parámetros para este estimador."

#: of sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid ":obj:`predict <sklearn.svm.LinearSVR.predict>`\\"
msgstr ":obj:`predict <sklearn.svm.LinearSVR.predict>`\\"

#: of sklearn.linear_model._base.LinearModel.predict:2
#: sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid "Predict using the linear model."
msgstr "Predice utilizando el modelo lineal."

#: of sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid ":obj:`score <sklearn.svm.LinearSVR.score>`\\"
msgstr ":obj:`score <sklearn.svm.LinearSVR.score>`\\"

#: of sklearn.base.RegressorMixin.score:2
#: sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid "Return the coefficient of determination :math:`R^2` of the prediction."
msgstr "Devuelve el coeficiente de determinación :math:`R^2` de la predicción."

#: of sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid ":obj:`set_params <sklearn.svm.LinearSVR.set_params>`\\"
msgstr ":obj:`set_params <sklearn.svm.LinearSVR.set_params>`\\"

#: of sklearn.base.BaseEstimator.set_params:2
#: sklearn.svm._classes.LinearSVR:130:<autosummary>:1
msgid "Set the parameters of this estimator."
msgstr "Establece los parámetros de este estimador."

#: of sklearn.base.RegressorMixin.score:20
#: sklearn.linear_model._base.LinearModel.predict:8
#: sklearn.svm._classes.LinearSVR.fit:9
msgid "**X**"
msgstr "**X**"

#: of
msgid "{array-like, sparse matrix} of shape (n_samples, n_features)"
msgstr "{array-like, sparse matrix} de forma (n_samples, n_features)"

#: of sklearn.svm._classes.LinearSVR.fit:8
msgid "Training vector, where n_samples in the number of samples and n_features is the number of features."
msgstr "Vector de entrenamiento, donde n_samples es el número de muestras y n_features es el número de características."

#: of sklearn.base.RegressorMixin.score:23
#: sklearn.svm._classes.LinearSVR.fit:12
msgid "**y**"
msgstr "**y**"

#: of
msgid "array-like of shape (n_samples,)"
msgstr "array-like de forma (n_samples,)"

#: of sklearn.svm._classes.LinearSVR.fit:12
msgid "Target vector relative to X"
msgstr "Vector objetivo relativo a X"

#: of sklearn.base.RegressorMixin.score:26
#: sklearn.svm._classes.LinearSVR.fit:19
msgid "**sample_weight**"
msgstr "**sample_weight**"

#: of
msgid "array-like of shape (n_samples,), default=None"
msgstr "array-like de forma (n_samples,) default=None"

#: of sklearn.svm._classes.LinearSVR.fit:15
msgid "Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight."
msgstr "Arreglo de ponderados asignados a muestras individuales. Si no se proporciona, entonces se le da peso unitario a cada muestra."

#: of sklearn.base.BaseEstimator.get_params
#: sklearn.base.BaseEstimator.set_params sklearn.base.RegressorMixin.score
#: sklearn.linear_model._base.LinearModel.predict
#: sklearn.svm._classes.LinearSVR.fit
msgid "Returns"
msgstr "Devuelve"

#: of sklearn.base.BaseEstimator.set_params:28
#: sklearn.svm._classes.LinearSVR.fit:35
msgid "**self**"
msgstr "**self**"

#: of
msgid "object"
msgstr "objeto"

#: of sklearn.svm._classes.LinearSVR.fit:24
msgid "An instance of the estimator."
msgstr "Una instancia del estimador."

#: of sklearn.base.BaseEstimator.get_params:9
msgid "**deep**"
msgstr "**deep**"

#: of sklearn.base.BaseEstimator.get_params:8
msgid "If True, will return the parameters for this estimator and contained subobjects that are estimators."
msgstr "Si es True, devolverá los parámetros para este estimador y los sub objetos contenidos que son estimadores."

#: of sklearn.base.BaseEstimator.get_params:25
msgid "**params**"
msgstr "**params**"

#: of
msgid "dict"
msgstr "dict"

#: of sklearn.base.BaseEstimator.get_params:14
msgid "Parameter names mapped to their values."
msgstr "Los nombres de los parámetros asignados a sus valores."

#: of
msgid "array-like or sparse matrix, shape (n_samples, n_features)"
msgstr "array-like o matriz dispersa, forma (n_samples, n_features)"

#: of sklearn.linear_model._base.LinearModel.predict:8
msgid "Samples."
msgstr "Muestras."

#: of
msgid "array, shape (n_samples,)"
msgstr "arreglo, forma (n_samples,)"

#: of sklearn.linear_model._base.LinearModel.predict:13
msgid "Returns predicted values."
msgstr "Devuelve los valores predichos."

#: of sklearn.base.RegressorMixin.score:5
msgid "The coefficient :math:`R^2` is defined as :math:`(1 - \\frac{u}{v})`, where :math:`u` is the residual sum of squares ``((y_true - y_pred) ** 2).sum()`` and :math:`v` is the total sum of squares ``((y_true - y_true.mean()) ** 2).sum()``. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a :math:`R^2` score of 0.0."
msgstr "El coeficiente :math:`R^2` se define como :math:`(1 - \\frac{u}{v})`, donde :math:`u` es la suma de cuadrados de los residuos ``((y_true - y_pred) ** 2).sum()`` y :math:`v` es la suma total de cuadrados ``((y_true - y_true.mean()) ** 2).sum()``. La mejor puntuación posible es 1.0 y puede ser negativa (porque el modelo puede ser arbitrariamente peor). Un modelo constante que siempre predice el valor esperado de `y`, sin tener en cuenta las características de entrada, obtendría una puntuación :math:`R^2` de 0.0."

#: of
msgid "array-like of shape (n_samples, n_features)"
msgstr "array-like de forma (n_samples_X, n_features)"

#: of sklearn.base.RegressorMixin.score:17
msgid "Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape ``(n_samples, n_samples_fitted)``, where ``n_samples_fitted`` is the number of samples used in the fitting for the estimator."
msgstr "Muestras de prueba. Para algunos estimadores esto puede ser una matriz de núcleo precalculada o una lista de objetos genéricos con forma ``(n_samples, n_samples_fitted)``, donde ``n_samples_fitted`` es el número de muestras utilizadas en el ajuste para el estimador."

#: of
msgid "array-like of shape (n_samples,) or (n_samples, n_outputs)"
msgstr "array-like de forma (n_samples,) o (n_samples, n_outputs)"

#: of sklearn.base.RegressorMixin.score:23
msgid "True values for `X`."
msgstr "Valores verdaderos para `X`."

#: of sklearn.base.RegressorMixin.score:26
msgid "Sample weights."
msgstr "Ponderaciones de muestras."

#: of sklearn.base.RegressorMixin.score:38
msgid "**score**"
msgstr "**score**"

#: of
msgid "float"
msgstr "de punto flotante (float)"

#: of sklearn.base.RegressorMixin.score:31
msgid ":math:`R^2` of ``self.predict(X)`` wrt. `y`."
msgstr ":math:`R^2` de ``self.predict(X)`` con respecto a `y`."

#: of sklearn.base.RegressorMixin.score:41
msgid "Notes"
msgstr "Notas"

#: of sklearn.base.RegressorMixin.score:42
msgid "The :math:`R^2` score used when calling ``score`` on a regressor uses ``multioutput='uniform_average'`` from version 0.23 to keep consistent with default value of :func:`~sklearn.metrics.r2_score`. This influences the ``score`` method of all the multioutput regressors (except for :class:`~sklearn.multioutput.MultiOutputRegressor`)."
msgstr "La puntuación :math:`R^2` utilizada al llamar a ``score`` en un regresor utiliza ``multioutput='uniform_average'`` desde la versión 0.23 para mantener la consistencia con el valor predeterminado de :func:`~sklearn.metrics.r2_score`. Esto influye en el método ``score`` de todos los regresores de salida múltiple (excepto para :class:`~sklearn.multioutput.MultiOutputRegressor`)."

#: of sklearn.base.BaseEstimator.set_params:4
msgid "The method works on simple estimators as well as on nested objects (such as :class:`~sklearn.pipeline.Pipeline`). The latter have parameters of the form ``<component>__<parameter>`` so that it's possible to update each component of a nested object."
msgstr "El método funciona tanto con estimadores simples como en objetos anidados (como :class:`~sklearn.pipeline.Pipeline`). Estos últimos tienen parámetros de la forma ``<component>__<parameter>`` para que sea posible actualizar cada componente de un objeto anidado."

#: of sklearn.base.BaseEstimator.set_params:12
msgid "**\\*\\*params**"
msgstr "**\\*\\*params**"

#: of sklearn.base.BaseEstimator.set_params:12
msgid "Estimator parameters."
msgstr "Parámetros del estimador."

#: of
msgid "estimator instance"
msgstr "instancia del estimador"

#: of sklearn.base.BaseEstimator.set_params:17
msgid "Estimator instance."
msgstr "Instancia de estimador."

