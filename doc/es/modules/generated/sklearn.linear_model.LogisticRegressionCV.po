msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 11:24-0400\n"
"PO-Revision-Date: 2021-07-13 22:12\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/generated/sklearn.linear_model.LogisticRegressionCV.po\n"
"X-Crowdin-File-ID: 5742\n"
"Language: es_ES\n"

#: ../modules/generated/sklearn.linear_model.LogisticRegressionCV.rst:2
msgid ":mod:`sklearn.linear_model`.LogisticRegressionCV"
msgstr ":mod:`sklearn.linear_model`.LogisticRegressionCV"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:2
msgid "Logistic Regression CV (aka logit, MaxEnt) classifier."
msgstr "Clasificador de Regresión Logística CV (también conocido como logit, MaxEnt)."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:4
msgid "See glossary entry for :term:`cross-validation estimator`."
msgstr "Ver entrada del glosario para :term:`estimador de validación cruzada`."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:6
msgid "This class implements logistic regression using liblinear, newton-cg, sag of lbfgs optimizer. The newton-cg, sag and lbfgs solvers support only L2 regularization with primal formulation. The liblinear solver supports both L1 and L2 regularization, with a dual formulation only for the L2 penalty. Elastic-Net penalty is only supported by the saga solver."
msgstr "Esta clase implementa la regresión logística utilizando el optimizador liblinear, newton-cg, sag o lbfgs. Los solucionadores newton-cg, sag y lbfgs sólo soportan la regularización L2 con formulación primal. El solucionador liblinear soporta tanto la regularización L1 como la L2, con una formulación dual sólo para la penalización L2. La penalización Elastic-Net sólo es compatible con el solucionador saga."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:12
msgid "For the grid of `Cs` values and `l1_ratios` values, the best hyperparameter is selected by the cross-validator :class:`~sklearn.model_selection.StratifiedKFold`, but it can be changed using the :term:`cv` parameter. The 'newton-cg', 'sag', 'saga' and 'lbfgs' solvers can warm-start the coefficients (see :term:`Glossary<warm_start>`)."
msgstr "Para la cuadrícula de valores `Cs` y `l1_ratios`, el mejor hiperparámetro es seleccionado por el validador cruzado :class:`~sklearn.model_selection.StratifiedKFold`, pero puede ser cambiado usando el parámetro :term:`cv`. Los solucionadores 'newton-cg', 'sag', 'saga' y 'lbfgs' pueden arrancar en caliente (warm-start) los coeficientes (ver :term:`Glosario <warm_start>`)."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:18
msgid "Read more in the :ref:`User Guide <logistic_regression>`."
msgstr "Leer más en el :ref:`Manual de Usuario <logistic_regression>`."

#: of sklearn.base.BaseEstimator.get_params
#: sklearn.base.BaseEstimator.set_params
#: sklearn.linear_model._base.LinearClassifierMixin.decision_function
#: sklearn.linear_model._base.LinearClassifierMixin.predict
#: sklearn.linear_model._logistic.LogisticRegression.predict_log_proba
#: sklearn.linear_model._logistic.LogisticRegression.predict_proba
#: sklearn.linear_model._logistic.LogisticRegressionCV
#: sklearn.linear_model._logistic.LogisticRegressionCV.fit
#: sklearn.linear_model._logistic.LogisticRegressionCV.score
msgid "Parameters"
msgstr "Parámetros"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:27
msgid "**Cs**"
msgstr "**Cs**"

#: of
msgid "int or list of floats, default=10"
msgstr "int o lista de flotantes, default=10"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:23
msgid "Each of the values in Cs describes the inverse of regularization strength. If Cs is as an int, then a grid of Cs values are chosen in a logarithmic scale between 1e-4 and 1e4. Like in support vector machines, smaller values specify stronger regularization."
msgstr "Cada uno de los valores en Cs describe el inverso de la fuerza de regularización. Si Cs es como un int, entonces se elige una cuadrícula de valores Cs en una escala logarítmica entre 1e-4 y 1e4. Como en las máquinas de vectores de soporte, los valores más pequeños especifican una regularización más fuerte."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:31
msgid "**fit_intercept**"
msgstr "**fit_intercept**"

#: of
msgid "bool, default=True"
msgstr "bool, default=True"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:30
msgid "Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function."
msgstr "Especifica si una constante (también conocida como sesgo o intercepto) se debe añadir a la función de decisión."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:40
msgid "**cv**"
msgstr "**cv**"

#: of
msgid "int or cross-validation generator, default=None"
msgstr "int o generador de validación cruzada, default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:34
msgid "The default cross-validation generator used is Stratified K-Folds. If an integer is provided, then it is the number of folds used. See the module :mod:`sklearn.model_selection` module for the list of possible cross-validation objects."
msgstr "El generador de validación cruzada utilizado por defecto es Stratified K-Folds. Si se proporciona un número entero, entonces es el número de partes (folds) utilizadas. Ver el módulo :mod:`sklearn.model_selection` para la lista de posibles objetos de validación cruzada."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:39
msgid "``cv`` default value if None changed from 3-fold to 5-fold."
msgstr "El valor predeterminado de ``cv``, si es None, cambió de 3 partes a 5 partes."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:45
msgid "**dual**"
msgstr "**dual**"

#: of
msgid "bool, default=False"
msgstr "bool, default=False"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:43
msgid "Dual or primal formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples > n_features."
msgstr "Formulación dual o primal. La formulación dual sólo se implementa para la penalización l2 con el solucionador liblinear. Preferir dual=False cuando n_samples > n_features."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:50
msgid "**penalty**"
msgstr "**penalty**"

#: of
msgid "{'l1', 'l2', 'elasticnet'}, default='l2'"
msgstr "{'l1', 'l2', 'elasticnet'}, default='l2'"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:48
msgid "Used to specify the norm used in the penalization. The 'newton-cg', 'sag' and 'lbfgs' solvers support only l2 penalties. 'elasticnet' is only supported by the 'saga' solver."
msgstr "Utilizado para especificar la norma usada en la penalización. Los solucionadores 'newton-cg', 'sag' y 'lbfgs' sólo soportan penalizaciones l2. 'elasticnet' sólo es soportado por el solucionador 'saga'."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:57
msgid "**scoring**"
msgstr "**scoring**"

#: of
msgid "str or callable, default=None"
msgstr "cadena de caracteres o invocable, default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:53
msgid "A string (see model evaluation documentation) or a scorer callable object / function with signature ``scorer(estimator, X, y)``. For a list of scoring functions that can be used, look at :mod:`sklearn.metrics`. The default scoring option used is 'accuracy'."
msgstr "Una cadena (ver la documentación sobre la evaluación del modelo) o un objeto / función de puntuación invocable con la firma ``scorer(estimator, X, y)``. Para obtener una lista de funciones de puntuación que pueden ser usadas, consulta :mod:`sklearn.metrics`. La opción de puntuación utilizada por defecto es 'accuracy'."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:79
msgid "**solver**"
msgstr "**solver**"

#: of
msgid "{'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'},             default='lbfgs'"
msgstr "{'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'},             default='lbfgs'"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:60
msgid "Algorithm to use in the optimization problem."
msgstr "Algoritmo a utilizar en el problema de optimización."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:62
msgid "For small datasets, 'liblinear' is a good choice, whereas 'sag' and 'saga' are faster for large ones."
msgstr "Para conjuntos de datos pequeños, 'liblinear' es una buena elección, mientras que 'sag' y 'saga' son más rápidos para los grandes."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:64
msgid "For multiclass problems, only 'newton-cg', 'sag', 'saga' and 'lbfgs' handle multinomial loss; 'liblinear' is limited to one-versus-rest schemes."
msgstr "Para los problemas multiclase, sólo 'newton-cg', 'sag', 'saga' y 'lbfgs' manejan la pérdida multinomial; 'liblinear' se limita a los esquemas de uno contra el resto."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:67
msgid "'newton-cg', 'lbfgs' and 'sag' only handle L2 penalty, whereas 'liblinear' and 'saga' handle L1 penalty."
msgstr "'newton-cg', 'lbfgs' y 'sag' sólo manejan la penalización L2, mientras que 'liblinear' y 'saga' manejan la penalización L1."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:69
msgid "'liblinear' might be slower in LogisticRegressionCV because it does not handle warm-starting."
msgstr "'liblinear' podría ser más lento en LogisticRegressionCV porque no maneja el arranque en caliente (warm-starting)."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:72
msgid "Note that 'sag' and 'saga' fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing."
msgstr "Ten en cuenta que la convergencia rápida de 'sag' y 'saga' sólo está garantizada en características con aproximadamente la misma escala. Puedes preprocesar los datos con un escalador de sklearn.preprocessing."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:76
msgid "Stochastic Average Gradient descent solver."
msgstr "Solucionador de descenso de Gradiente Medio Estocástico (Stochastic Average Gradient descent solver)."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:78
msgid "SAGA solver."
msgstr "Solucionador SAGA."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:82
msgid "**tol**"
msgstr "**tol**"

#: of
msgid "float, default=1e-4"
msgstr "float, default=1e-4"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:82
msgid "Tolerance for stopping criteria."
msgstr "Tolerancia para el criterio de parada."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:85
msgid "**max_iter**"
msgstr "**max_iter**"

#: of
msgid "int, default=100"
msgstr "int, default=100"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:85
msgid "Maximum number of iterations of the optimization algorithm."
msgstr "Número máximo de iteraciones del algoritmo de optimización."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:99
msgid "**class_weight**"
msgstr "**class_weight**"

#: of
msgid "dict or 'balanced', default=None"
msgstr "diccionario o 'balanced', default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:88
msgid "Weights associated with classes in the form ``{class_label: weight}``. If not given, all classes are supposed to have weight one."
msgstr "Ponderaciones asociadas a las clases de la forma ``{class_label: weight}``. Si no se da, se supone que todas las clases tienen ponderación uno."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:91
msgid "The \"balanced\" mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as ``n_samples / (n_classes * np.bincount(y))``."
msgstr "El modo \"balanced\" utiliza los valores de y para ajustar automáticamente las ponderaciones de forma inversamente proporcional a las frecuencias de las clases en los datos de entrada como ``n_samples / (n_classes * np.bincount(y))``."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:95
msgid "Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified."
msgstr "Ten en cuenta que estas ponderaciones se multiplicarán por sample_weight (pasado por el método de ajuste) si se especifica sample_weight."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:98
msgid "class_weight == 'balanced'"
msgstr "class_weight == 'balanced'"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:105
msgid "**n_jobs**"
msgstr "**n_jobs**"

#: of
msgid "int, default=None"
msgstr "int, default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:102
msgid "Number of CPU cores used during the cross-validation loop. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details."
msgstr "Número de núcleos de CPU utilizados durante el bucle de validación cruzada. ``None`` significa 1 a menos que esté en un contexto :obj:`joblib.parallel_backend`. ``-1`` significa usar todos los procesadores. Ver :term:`Glosario <n_jobs>` para más detalles."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:109
msgid "**verbose**"
msgstr "**verbose**"

#: of
msgid "int, default=0"
msgstr "int, default=0"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:108
msgid "For the 'liblinear', 'sag' and 'lbfgs' solvers set verbose to any positive number for verbosity."
msgstr "Para los solucionadores 'liblinear', 'sag' y 'lbfgs' establece verbose a cualquier número positivo para la verbosidad."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:116
msgid "**refit**"
msgstr "**refit**"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:112
msgid "If set to True, the scores are averaged across all folds, and the coefs and the C that corresponds to the best score is taken, and a final refit is done using these parameters. Otherwise the coefs, intercepts and C that correspond to the best scores across folds are averaged."
msgstr "Si se establece en True, las puntuaciones se promedian entre todas las partes, y se toman los coefs y la C correspondientes a la mejor puntuación, y se hace un reajuste final utilizando estos parámetros. En caso contrario, se promedian los coefs, interceptos y C correspondientes a las mejores puntuaciones en todas las partes."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:129
msgid "**intercept_scaling**"
msgstr "**intercept_scaling**"

#: of
msgid "float, default=1"
msgstr "float, default=1"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:119
msgid "Useful only when the solver 'liblinear' is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \"synthetic\" feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes ``intercept_scaling * synthetic_feature_weight``."
msgstr "Útil sólo cuando se usa el solucionador 'liblinear' y self.fit_intercept se establece en True. En este caso, x se convierte en [x, self.intercept_scaling], es decir, una característica \"sintética\" con valor constante igual a intercept_scaling se añade al vector de la instancia. El intercepto se convierte en ``intercept_scaling * synthetic_feature_weight``."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:126
msgid "Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased."
msgstr "Nota: la ponderación de la característica sintética está sujeta a la regularización l1/l2 como todas las demás características. Para disminuir el efecto de la regularización en la ponderación de la característica sintética (y por lo tanto en el intercepto) el intercept_scaling tiene que aumentarse."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:142
msgid "**multi_class**"
msgstr "**multi_class**"

#: of
msgid "{'auto, 'ovr', 'multinomial'}, default='auto'"
msgstr "{'auto, 'ovr', 'multinomial'}, default='auto'"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:132
msgid "If the option chosen is 'ovr', then a binary problem is fit for each label. For 'multinomial' the loss minimised is the multinomial loss fit across the entire probability distribution, *even when the data is binary*. 'multinomial' is unavailable when solver='liblinear'. 'auto' selects 'ovr' if the data is binary, or if solver='liblinear', and otherwise selects 'multinomial'."
msgstr "Si la opción elegida es 'ovr', entonces se ajusta un problema binario para cada etiqueta. Para 'multinomial' la pérdida minimizada es la pérdida multinomial ajustada a través de toda la distribución de probabilidad, *incluso cuando los datos son binarios*. 'multinomial' no está disponible cuando solver='liblinear'. auto' selecciona 'ovr' si los datos son binarios, o si solver='liblinear', y en caso contrario selecciona 'multinomial'."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:139
msgid "Stochastic Average Gradient descent solver for 'multinomial' case."
msgstr "Solucionador de descenso de Gradiente Medio Estocástico para el caso 'multinomial'."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:141
msgid "Default changed from 'ovr' to 'auto' in 0.22."
msgstr "Por defecto cambió de 'ovr' a 'auto' en 0.22."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:147
msgid "**random_state**"
msgstr "**random_state**"

#: of
msgid "int, RandomState instance, default=None"
msgstr "entero, instancia de RandomState, default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:145
msgid "Used when `solver='sag'`, 'saga' or 'liblinear' to shuffle the data. Note that this only applies to the solver and not the cross-validation generator. See :term:`Glossary <random_state>` for details."
msgstr "Utilizado cuando `solver='sag'`, 'saga' o 'liblinear' para revolver los datos. Ten en cuenta que esto sólo se aplica al solucionador y no al generador de validación cruzada. Ver :term:`Glosario <random_state>` para obtener detalles."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:157
msgid "**l1_ratios**"
msgstr "**l1_ratios**"

#: of
msgid "list of float, default=None"
msgstr "lista de flotantes, default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:150
msgid "The list of Elastic-Net mixing parameter, with ``0 <= l1_ratio <= 1``. Only used if ``penalty='elasticnet'``. A value of 0 is equivalent to using ``penalty='l2'``, while 1 is equivalent to using ``penalty='l1'``. For ``0 < l1_ratio <1``, the penalty is a combination of L1 and L2."
msgstr "La lista del parámetro de mezcla de Elastic-Net, con ``0 < l1_ratio <= 1``. Sólo se utiliza si ``penalty='elasticnet'``. Un valor de 0 es equivalente a utilizar ``penalty='l2'``, mientras que 1 es equivalente a utilizar ``penalty='l1'``. Para ``0 < l1_ratio < 1``, la penalización es una combinación de L1 y L2."

#: of sklearn.linear_model._logistic.LogisticRegressionCV
msgid "Attributes"
msgstr "Atributos"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:162
msgid "**classes_**"
msgstr "**classes_**"

#: of
msgid "ndarray of shape (n_classes, )"
msgstr "ndarray de forma (n_classes, )"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:162
msgid "A list of class labels known to the classifier."
msgstr "Una lista de etiquetas de clase conocidas por el clasificador."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:168
msgid "**coef_**"
msgstr "**coef_**"

#: of
msgid "ndarray of shape (1, n_features) or (n_classes, n_features)"
msgstr "ndarray de forma (1, n_features) o (n_classes, n_features)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:165
msgid "Coefficient of the features in the decision function."
msgstr "Coeficiente de las características en la función de decisión."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:167
msgid "`coef_` is of shape (1, n_features) when the given problem is binary."
msgstr "`coef_` es de forma (1, n_features) cuando el problema dado es binario."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:174
msgid "**intercept_**"
msgstr "**intercept_**"

#: of
msgid "ndarray of shape (1,) or (n_classes,)"
msgstr "ndarray de forma (1,) o (n_classes,)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:171
msgid "Intercept (a.k.a. bias) added to the decision function."
msgstr "Intercepto (también conocido como sesgo) añadido a la función de decisión."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:173
msgid "If `fit_intercept` is set to False, the intercept is set to zero. `intercept_` is of shape(1,) when the problem is binary."
msgstr "Si `fit_intercept` se establece en False, el intercepto se establece en cero. `intercept_` es de forma (1,) cuando el problema es binario."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:178
msgid "**Cs_**"
msgstr "**Cs_**"

#: of
msgid "ndarray of shape (n_cs)"
msgstr "ndarray de forma (n_cs)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:177
msgid "Array of C i.e. inverse of regularization parameter values used for cross-validation."
msgstr "Arreglo de C, es decir, la inversa de los valores de los parámetros de regularización utilizados para la validación cruzada."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:182
msgid "**l1_ratios_**"
msgstr "**l1_ratios_**"

#: of
msgid "ndarray of shape (n_l1_ratios)"
msgstr "ndarray de forma (n_l1_ratios)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:181
msgid "Array of l1_ratios used for cross-validation. If no l1_ratio is used (i.e. penalty is not 'elasticnet'), this is set to ``[None]``"
msgstr "Arreglo de l1_ratios utilizados para la validación cruzada. Si no se utiliza l1_ratio (es decir, la penalización no es 'elasticnet'), se establece como ``[None]``"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:194
msgid "**coefs_paths_**"
msgstr "**coefs_paths_**"

#: of
msgid "ndarray of shape (n_folds, n_cs, n_features) or                    (n_folds, n_cs, n_features + 1)"
msgstr "ndarray de forma (n_folds, n_cs, n_features) o                    (n_folds, n_cs, n_features + 1)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:185
msgid "dict with classes as the keys, and the path of coefficients obtained during cross-validating across each fold and then across each Cs after doing an OvR for the corresponding class as values. If the 'multi_class' option is set to 'multinomial', then the coefs_paths are the coefficients corresponding to each class. Each dict value has shape ``(n_folds, n_cs, n_features)`` or ``(n_folds, n_cs, n_features + 1)`` depending on whether the intercept is fit or not. If ``penalty='elasticnet'``, the shape is ``(n_folds, n_cs, n_l1_ratios_, n_features)`` or ``(n_folds, n_cs, n_l1_ratios_, n_features + 1)``."
msgstr "Diccionario con las clases como claves, y la ruta de los coeficientes obtenidos durante la validación cruzada a través de cada parte (fold) y luego a través de cada Cs después de hacer un OvR para la clase correspondiente como valores. Si la opción 'multi_class' se establece como 'multinomial', entonces los coefs_paths son los coeficientes correspondientes a cada clase. Cada valor del diccionario tiene forma ``(n_folds, n_cs, n_features)`` o ``(n_folds, n_cs, n_features + 1)`` dependiendo de si el intercepto se ajusta o no. Si ``penalty='elasticnet'``, la forma es ``(n_folds, n_cs, n_l1_ratios_, n_features)`` o ``(n_folds, n_cs, n_l1_ratios_, n_features + 1)``."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:203
msgid "**scores_**"
msgstr "**scores_**"

#: of
msgid "dict"
msgstr "dict"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:197
msgid "dict with classes as the keys, and the values as the grid of scores obtained during cross-validating each fold, after doing an OvR for the corresponding class. If the 'multi_class' option given is 'multinomial' then the same scores are repeated across all classes, since this is the multinomial class. Each dict value has shape ``(n_folds, n_cs`` or ``(n_folds, n_cs, n_l1_ratios)`` if ``penalty='elasticnet'``."
msgstr "Diccionario con las clases como claves, y los valores como la cuadrícula de puntuaciones obtenidas durante la validación cruzada de cada parte (fold), después de hacer un OvR para la clase correspondiente. Si la opción 'multi_class' dada es 'multinomial' entonces las mismas puntuaciones se repiten en todas las clases, ya que se trata de la clase multinomial. Cada valor del diccionario tiene forma ``(n_folds, n_cs`` o ``(n_folds, n_cs, n_l1_ratios)`` si ``penalty='elasticnet'``."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:209
msgid "**C_**"
msgstr "**C_**"

#: of
msgid "ndarray of shape (n_classes,) or (n_classes - 1,)"
msgstr "ndarray de forma (n_classes,) o (n_classes - 1,)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:206
msgid "Array of C that maps to the best scores across every class. If refit is set to False, then for each class, the best C is the average of the C's that correspond to the best scores for each fold. `C_` is of shape(n_classes,) when the problem is binary."
msgstr "Arreglo de C que se mapea a las mejores puntuaciones de cada clase. Si refit se establece en False, entonces para cada clase, la mejor C es la media de las C que corresponden a las mejores puntuaciones para cada parte. `C_` es de forma (n_classes,) cuando el problema es binario."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:215
msgid "**l1_ratio_**"
msgstr "**l1_ratio_**"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:212
msgid "Array of l1_ratio that maps to the best scores across every class. If refit is set to False, then for each class, the best l1_ratio is the average of the l1_ratio's that correspond to the best scores for each fold.  `l1_ratio_` is of shape(n_classes,) when the problem is binary."
msgstr "Arreglo de l1_ratio que se mapea a las mejores puntuaciones de cada clase. Si refit se establece en False, entonces para cada clase, el mejor l1_ratio es el promedio de los l1_ratio que corresponden a las mejores puntuaciones para cada parte.  `l1_ratio_` es de forma (n_classes,) cuando el problema es binario."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:224
msgid "**n_iter_**"
msgstr "**n_iter_**"

#: of
msgid "ndarray of shape (n_classes, n_folds, n_cs) or (1, n_folds, n_cs)"
msgstr "ndarray de forma (n_classes, n_folds, n_cs) o (1, n_folds, n_cs)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:218
msgid "Actual number of iterations for all classes, folds and Cs. In the binary or multinomial cases, the first dimension is equal to 1. If ``penalty='elasticnet'``, the shape is ``(n_classes, n_folds, n_cs, n_l1_ratios)`` or ``(1, n_folds, n_cs, n_l1_ratios)``."
msgstr "Número real de iteraciones para todas las clases, partes y Cs. En los casos binarios o multinomiales, la primera dimensión es igual a 1. Si ``penalty='elasticnet'``, la forma es ``(n_classes, n_folds, n_cs, n_l1_ratios)`` o ``(1, n_folds, n_cs, n_l1_ratios)``."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:229
msgid ":obj:`LogisticRegression`"
msgstr ":obj:`LogisticRegression`"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:235
msgid "Examples"
msgstr "Ejemplos"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:248
msgid "Methods"
msgstr "Métodos"

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`decision_function <sklearn.linear_model.LogisticRegressionCV.decision_function>`\\"
msgstr ":obj:`decision_function <sklearn.linear_model.LogisticRegressionCV.decision_function>`\\"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Predict confidence scores for samples."
msgstr "Predice las puntuaciones de confianza de las muestras."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`densify <sklearn.linear_model.LogisticRegressionCV.densify>`\\"
msgstr ":obj:`densify <sklearn.linear_model.LogisticRegressionCV.densify>`\\"

#: of sklearn.linear_model._base.SparseCoefMixin.densify:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Convert coefficient matrix to dense array format."
msgstr "Convierte la matriz de coeficientes en formato de arreglo denso."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`fit <sklearn.linear_model.LogisticRegressionCV.fit>`\\"
msgstr ":obj:`fit <sklearn.linear_model.LogisticRegressionCV.fit>`\\"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.fit:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Fit the model according to the given training data."
msgstr "Ajusta el modelo según los datos de entrenamiento dados."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`get_params <sklearn.linear_model.LogisticRegressionCV.get_params>`\\"
msgstr ":obj:`get_params <sklearn.linear_model.LogisticRegressionCV.get_params>`\\"

#: of sklearn.base.BaseEstimator.get_params:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Get parameters for this estimator."
msgstr "Obtiene los parámetros para este estimador."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`predict <sklearn.linear_model.LogisticRegressionCV.predict>`\\"
msgstr ":obj:`predict <sklearn.linear_model.LogisticRegressionCV.predict>`\\"

#: of sklearn.linear_model._base.LinearClassifierMixin.predict:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Predict class labels for samples in X."
msgstr "Predice las etiquetas de clase para las muestras en X."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`predict_log_proba <sklearn.linear_model.LogisticRegressionCV.predict_log_proba>`\\"
msgstr ":obj:`predict_log_proba <sklearn.linear_model.LogisticRegressionCV.predict_log_proba>`\\"

#: of sklearn.linear_model._logistic.LogisticRegression.predict_log_proba:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Predict logarithm of probability estimates."
msgstr "Predice el logaritmo de las estimaciones de probabilidad."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`predict_proba <sklearn.linear_model.LogisticRegressionCV.predict_proba>`\\"
msgstr ":obj:`predict_proba <sklearn.linear_model.LogisticRegressionCV.predict_proba>`\\"

#: of sklearn.linear_model._logistic.LogisticRegression.predict_proba:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Probability estimates."
msgstr "Estimaciones de probabilidad."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`score <sklearn.linear_model.LogisticRegressionCV.score>`\\"
msgstr ":obj:`score <sklearn.linear_model.LogisticRegressionCV.score>`\\"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.score:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Returns the score using the `scoring` option on the given test data and labels."
msgstr "Devuelve la puntuación utilizando la opción `scoring` en los datos de la prueba y las etiquetas dadas."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`set_params <sklearn.linear_model.LogisticRegressionCV.set_params>`\\"
msgstr ":obj:`set_params <sklearn.linear_model.LogisticRegressionCV.set_params>`\\"

#: of sklearn.base.BaseEstimator.set_params:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Set the parameters of this estimator."
msgstr "Establece los parámetros de este estimador."

#: of sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid ":obj:`sparsify <sklearn.linear_model.LogisticRegressionCV.sparsify>`\\"
msgstr ":obj:`sparsify <sklearn.linear_model.LogisticRegressionCV.sparsify>`\\"

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:2
#: sklearn.linear_model._logistic.LogisticRegressionCV:261:<autosummary>:1
msgid "Convert coefficient matrix to sparse format."
msgstr "Convierte la matriz de coeficientes en formato disperso."

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:4
msgid "The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane."
msgstr "La puntuación de confianza de una muestra es proporcional a la distancia con signo de esa muestra al hiperplano."

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:10
#: sklearn.linear_model._base.LinearClassifierMixin.predict:8
#: sklearn.linear_model._logistic.LogisticRegression.predict_log_proba:11
#: sklearn.linear_model._logistic.LogisticRegression.predict_proba:18
#: sklearn.linear_model._logistic.LogisticRegressionCV.fit:9
#: sklearn.linear_model._logistic.LogisticRegressionCV.score:9
msgid "**X**"
msgstr "**X**"

#: of
msgid "array-like or sparse matrix, shape (n_samples, n_features)"
msgstr "array-like o matriz dispersa, forma (n_samples, n_features)"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:10
#: sklearn.linear_model._base.LinearClassifierMixin.predict:8
msgid "Samples."
msgstr "Muestras."

#: of sklearn.base.BaseEstimator.get_params
#: sklearn.base.BaseEstimator.set_params
#: sklearn.linear_model._base.LinearClassifierMixin.decision_function
#: sklearn.linear_model._base.LinearClassifierMixin.predict
#: sklearn.linear_model._base.SparseCoefMixin.densify
#: sklearn.linear_model._base.SparseCoefMixin.sparsify
#: sklearn.linear_model._logistic.LogisticRegression.predict_log_proba
#: sklearn.linear_model._logistic.LogisticRegression.predict_proba
#: sklearn.linear_model._logistic.LogisticRegressionCV.fit
#: sklearn.linear_model._logistic.LogisticRegressionCV.score
msgid "Returns"
msgstr "Devuelve"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:28
msgid "array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)"
msgstr "array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)"

#: of sklearn.linear_model._base.LinearClassifierMixin.decision_function:15
msgid "Confidence scores per (sample, class) combination. In the binary case, confidence score for self.classes_[1] where >0 means this class would be predicted."
msgstr "Puntuaciones de confianza por combinación (sample, class). En el caso binario, la puntuación de confianza para self.classes_[1] donde >0 significa que esta clase sería predicha."

#: of sklearn.linear_model._base.SparseCoefMixin.densify:4
msgid "Converts the ``coef_`` member (back) to a numpy.ndarray. This is the default format of ``coef_`` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op."
msgstr "Convierte el miembro ``coef_`` (de vuelta) en un numpy.ndarray. Este es el formato predeterminado de ``coef_`` y se requiere para el ajuste, por lo que llamar a este método sólo es necesario en los modelos que han sido previamente dispersados (sparsified); de lo contrario, es un no-op."

#: of sklearn.linear_model._base.SparseCoefMixin.densify:24
#: sklearn.linear_model._base.SparseCoefMixin.sparsify:21
msgid "self"
msgstr "self"

#: of sklearn.linear_model._base.SparseCoefMixin.densify:13
#: sklearn.linear_model._base.SparseCoefMixin.sparsify:14
msgid "Fitted estimator."
msgstr "Estimador ajustado."

#: of
msgid "{array-like, sparse matrix} of shape (n_samples, n_features)"
msgstr "{array-like, sparse matrix} de forma (n_samples, n_features)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.fit:8
msgid "Training vector, where n_samples is the number of samples and n_features is the number of features."
msgstr "Vector de entrenamiento, donde n_samples es el número de muestras y n_features es el número de características."

#: of sklearn.linear_model._logistic.LogisticRegressionCV.fit:12
#: sklearn.linear_model._logistic.LogisticRegressionCV.score:12
msgid "**y**"
msgstr "**y**"

#: of
msgid "array-like of shape (n_samples,)"
msgstr "array-like de forma (n_samples,)"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.fit:12
msgid "Target vector relative to X."
msgstr "Vector objetivo relativo a X."

#: of sklearn.linear_model._logistic.LogisticRegressionCV.fit:16
#: sklearn.linear_model._logistic.LogisticRegressionCV.score:15
msgid "**sample_weight**"
msgstr "**sample_weight**"

#: of
msgid "array-like of shape (n_samples,) default=None"
msgstr "array-like de forma (n_samples,) default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.fit:15
msgid "Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight."
msgstr "Arreglo de ponderaciones que se asignan a las muestras individuales. Si no se proporciona, entonces cada muestra recibe una ponderación unitaria."

#: of sklearn.base.BaseEstimator.set_params:28
#: sklearn.linear_model._logistic.LogisticRegressionCV.fit:32
msgid "**self**"
msgstr "**self**"

#: of
msgid "object"
msgstr "object"

#: of sklearn.base.BaseEstimator.get_params:9
msgid "**deep**"
msgstr "**deep**"

#: of sklearn.base.BaseEstimator.get_params:8
msgid "If True, will return the parameters for this estimator and contained subobjects that are estimators."
msgstr "Si es True, devolverá los parámetros para este estimador y los subobjetos contenidos que son estimadores."

#: of sklearn.base.BaseEstimator.get_params:25
msgid "**params**"
msgstr "**params**"

#: of sklearn.base.BaseEstimator.get_params:14
msgid "Parameter names mapped to their values."
msgstr "Nombres de parámetros mapeados a sus valores."

#: of sklearn.linear_model._base.LinearClassifierMixin.predict:24
msgid "**C**"
msgstr "**C**"

#: of
msgid "array, shape [n_samples]"
msgstr "array, forma [n_samples]"

#: of sklearn.linear_model._base.LinearClassifierMixin.predict:13
msgid "Predicted class label per sample."
msgstr "Etiqueta de clase predicha por muestra."

#: of sklearn.linear_model._logistic.LogisticRegression.predict_log_proba:4
#: sklearn.linear_model._logistic.LogisticRegression.predict_proba:4
msgid "The returned estimates for all classes are ordered by the label of classes."
msgstr "Las estimaciones devueltas para todas las clases están ordenadas por la etiqueta de las clases."

#: of
msgid "array-like of shape (n_samples, n_features)"
msgstr "array-like de forma (n_samples, n_features)"

#: of sklearn.linear_model._logistic.LogisticRegression.predict_log_proba:10
#: sklearn.linear_model._logistic.LogisticRegression.predict_proba:17
msgid "Vector to be scored, where `n_samples` is the number of samples and `n_features` is the number of features."
msgstr "Vector a ser puntuado, donde `n_samples` es el número de muestras y `n_features` es el número de características."

#: of sklearn.linear_model._logistic.LogisticRegression.predict_log_proba:28
#: sklearn.linear_model._logistic.LogisticRegression.predict_proba:35
msgid "**T**"
msgstr "**T**"

#: of
msgid "array-like of shape (n_samples, n_classes)"
msgstr "array-like de forma (n_samples, n_classes)"

#: of sklearn.linear_model._logistic.LogisticRegression.predict_log_proba:16
msgid "Returns the log-probability of the sample for each class in the model, where classes are ordered as they are in ``self.classes_``."
msgstr "Devuelve la probabilidad logarítmica de la muestra para cada clase en el modelo, donde las clases se ordenan como están en ``self.classes_``."

#: of sklearn.linear_model._logistic.LogisticRegression.predict_proba:7
msgid "For a multi_class problem, if multi_class is set to be \"multinomial\" the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes."
msgstr "Para un problema multi_class, si multi_class está establecido como \"multinomial\" se utiliza la función softmax para encontrar la probabilidad predicha de cada clase. De lo contrario, se utiliza un enfoque de uno contra el resto, es decir, se calcula la probabilidad de cada clase asumiendo que es positiva utilizando la función logística y se normalizan estos valores en todas las clases."

#: of sklearn.linear_model._logistic.LogisticRegression.predict_proba:23
msgid "Returns the probability of the sample for each class in the model, where classes are ordered as they are in ``self.classes_``."
msgstr "Devuelve la probabilidad de la muestra para cada clase en el modelo, donde las clases se ordenan como están en ``self.classes_``."

#: of sklearn.linear_model._logistic.LogisticRegressionCV.score:9
msgid "Test samples."
msgstr "Muestras de prueba."

#: of sklearn.linear_model._logistic.LogisticRegressionCV.score:12
msgid "True labels for X."
msgstr "Etiquetas verdaderas para X."

#: of
msgid "array-like of shape (n_samples,), default=None"
msgstr "array-like de forma (n_samples,), default=None"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.score:15
msgid "Sample weights."
msgstr "Ponderaciones de muestras."

#: of sklearn.linear_model._logistic.LogisticRegressionCV.score:31
msgid "**score**"
msgstr "**score**"

#: of
msgid "float"
msgstr "float"

#: of sklearn.linear_model._logistic.LogisticRegressionCV.score:20
msgid "Score of self.predict(X) wrt. y."
msgstr "Puntuación de self.predict(X) con respecto a y."

#: of sklearn.base.BaseEstimator.set_params:4
msgid "The method works on simple estimators as well as on nested objects (such as :class:`~sklearn.pipeline.Pipeline`). The latter have parameters of the form ``<component>__<parameter>`` so that it's possible to update each component of a nested object."
msgstr "El método funciona tanto en estimadores simples como en objetos anidados (como :class:`~sklearn.pipeline.Pipeline`). Estos últimos tienen parámetros de la forma ``<component>__<parameter>`` para que sea posible actualizar cada componente de un objeto anidado."

#: of sklearn.base.BaseEstimator.set_params:12
msgid "**\\*\\*params**"
msgstr "**\\*\\*params**"

#: of sklearn.base.BaseEstimator.set_params:12
msgid "Estimator parameters."
msgstr "Parámetros del estimador."

#: of
msgid "estimator instance"
msgstr "instancia del estimador"

#: of sklearn.base.BaseEstimator.set_params:17
msgid "Estimator instance."
msgstr "Instancia del estimador."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:4
msgid "Converts the ``coef_`` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation."
msgstr "Convierte el miembro ``coef_`` en una matriz scipy.sparse, que para los modelos L1-regularizados puede ser mucho más eficiente en cuanto a memoria y almacenamiento que la representación numpy.ndarray habitual."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:8
msgid "The ``intercept_`` member is not converted."
msgstr "El miembro ``intercept_`` no se convierte."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:24
msgid "Notes"
msgstr "Notas"

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:25
#, python-format
msgid "For non-sparse models, i.e. when there are not many zeros in ``coef_``, this may actually *increase* memory usage, so use this method with care. A rule of thumb is that the number of zero elements, which can be computed with ``(coef_ == 0).sum()``, must be more than 50% for this to provide significant benefits."
msgstr "Para los modelos no dispersos, es decir, cuando no hay muchos ceros en ``coef_``, esto puede en realidad *aumentar* el uso de la memoria, así que utiliza este método con cuidado. Una regla general es que el número de elementos cero, que puede ser calculado con ``(coef_ == 0).sum()``, debe ser más del 50% para que esto proporcione beneficios significativos."

#: of sklearn.linear_model._base.SparseCoefMixin.sparsify:31
msgid "After calling this method, further fitting with the partial_fit method (if any) will not work until you call densify."
msgstr "Después de llamar a este método, el ajuste posterior con el método partial_fit (si lo hay) no funcionará hasta que llames a densify."

