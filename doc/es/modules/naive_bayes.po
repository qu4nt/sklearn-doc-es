msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 11:24-0400\n"
"PO-Revision-Date: 2021-05-03 12:32\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/naive_bayes.po\n"
"X-Crowdin-File-ID: 5928\n"
"Language: es_ES\n"

#: ../modules/naive_bayes.rst:5
msgid "Naive Bayes"
msgstr "Bayesiano ingenuo"

#: ../modules/naive_bayes.rst:10
msgid "Naive Bayes methods are a set of supervised learning algorithms based on applying Bayes' theorem with the \"naive\" assumption of conditional independence between every pair of features given the value of the class variable. Bayes' theorem states the following relationship, given class variable :math:`y` and dependent feature vector :math:`x_1` through :math:`x_n`, :"
msgstr "Los métodos de Bayesiano ingenio son un conjunto de algoritmos de aprendizaje supervisados basados en la aplicación del teorema de Bayes con la suposición \"ingenua\" de independencia condicional entre cada par de características dado el valor de la variable de clase. El teorema de Bayes indica la siguiente relación, variable de clase dada :math:`y` y vector de característica dependiente :math:`x_1` a través de :math:`x_n`, :"

#: ../modules/naive_bayes.rst:17
msgid "P(y \\mid x_1, \\dots, x_n) = \\frac{P(y) P(x_1, \\dots, x_n \\mid y)}\n"
"                                 {P(x_1, \\dots, x_n)}"
msgstr "P(y \\mid x_1, \\dots, x_n) = \\frac{P(y) P(x_1, \\dots, x_n \\mid y)}\n"
"                                 {P(x_1, \\dots, x_n)}"

#: ../modules/naive_bayes.rst:22
msgid "Using the naive conditional independence assumption that"
msgstr "Utilizando el ingenuo supuesto de independencia condicional de ese"

#: ../modules/naive_bayes.rst:24
msgid "P(x_i | y, x_1, \\dots, x_{i-1}, x_{i+1}, \\dots, x_n) = P(x_i | y),"
msgstr "P(x_i | y, x_1, \\dots, x_{i-1}, x_{i+1}, \\dots, x_n) = P(x_i | y),"

#: ../modules/naive_bayes.rst:28
msgid "for all :math:`i`, this relationship is simplified to"
msgstr "para todos los :math:`i`, esta relación se simplifica a"

#: ../modules/naive_bayes.rst:30
msgid "P(y \\mid x_1, \\dots, x_n) = \\frac{P(y) \\prod_{i=1}^{n} P(x_i \\mid y)}\n"
"                                 {P(x_1, \\dots, x_n)}"
msgstr "P(y \\mid x_1, \\dots, x_n) = \\frac{P(y) \\prod_{i=1}^{n} P(x_i \\mid y)}\n"
"                                 {P(x_1, \\dots, x_n)}"

#: ../modules/naive_bayes.rst:35
msgid "Since :math:`P(x_1, \\dots, x_n)` is constant given the input, we can use the following classification rule:"
msgstr "Como :math:`P(x_1, \\dots, x_n)` es constante dada la entrada, podemos usar la siguiente regla de clasificación:"

#: ../modules/naive_bayes.rst:38
msgid "P(y \\mid x_1, \\dots, x_n) \\propto P(y) \\prod_{i=1}^{n} P(x_i \\mid y)\n\n"
"\\Downarrow\n\n"
"\\hat{y} = \\arg\\max_y P(y) \\prod_{i=1}^{n} P(x_i \\mid y),"
msgstr "P(y \\mid x_1, \\dots, x_n) \\propto P(y) \\prod_{i=1}^{n} P(x_i \\mid y)\n\n"
"\\Downarrow\n\n"
"\\hat{y} = \\arg\\max_y P(y) \\prod_{i=1}^{n} P(x_i \\mid y),"

#: ../modules/naive_bayes.rst:46
msgid "and we can use Maximum A Posteriori (MAP) estimation to estimate :math:`P(y)` and :math:`P(x_i \\mid y)`; the former is then the relative frequency of class :math:`y` in the training set."
msgstr "y podemos usar la estimación máxima A Posteriori (MAP) para estimar :math:`P(y)` y :math:`P(x_i \\mid y)`; el primero es entonces la frecuencia relativa de la clase :math:`y` en el conjunto de entrenamiento."

#: ../modules/naive_bayes.rst:51
msgid "The different naive Bayes classifiers differ mainly by the assumptions they make regarding the distribution of :math:`P(x_i \\mid y)`."
msgstr "Los diferentes clasificadores Bayesianos ingenuos difieren principalmente por los supuestos que hacen con respecto a la distribución de :math:`P(x_i \\mid y)`."

#: ../modules/naive_bayes.rst:54
msgid "In spite of their apparently over-simplified assumptions, naive Bayes classifiers have worked quite well in many real-world situations, famously document classification and spam filtering. They require a small amount of training data to estimate the necessary parameters. (For theoretical reasons why naive Bayes works well, and on which types of data it does, see the references below.)"
msgstr "A pesar de sus supuestos aparentemente demasiado simplificados, los clasificadores Bayesianos ingenuos han funcionado bastante bien en muchas situaciones del mundo real, como la clasificación de documentos y el filtrado de spam. Requieren una pequeña cantidad de datos de entrenamiento para estimar los parámetros necesarios. (Para conocer las razones teóricas por las que el Bayesiano ingenuo funciona bien, y sobre qué tipos de datos lo hace, ver las referencias más abajo.)"

#: ../modules/naive_bayes.rst:61
msgid "Naive Bayes learners and classifiers can be extremely fast compared to more sophisticated methods. The decoupling of the class conditional feature distributions means that each distribution can be independently estimated as a one dimensional distribution. This in turn helps to alleviate problems stemming from the curse of dimensionality."
msgstr "Los aprendices y clasificadores de Bayesiano ingenuo pueden ser extremadamente rápidos en comparación con métodos más sofisticados. La disociación de las distribuciones de características condicionales de la clase significa que cada distribución puede estimarse independientemente como una distribución unidimensional. Esto, a su vez, ayuda a aliviar los problemas derivados de la maldición de la dimensionalidad."

#: ../modules/naive_bayes.rst:68
msgid "On the flip side, although naive Bayes is known as a decent classifier, it is known to be a bad estimator, so the probability outputs from ``predict_proba`` are not to be taken too seriously."
msgstr "Por otro lado, aunque el Bayesiano ingenuo es conocido como un clasificador decente, se sabe que es un mal estimador, por lo que las salidas de probabilidad de ``predict_proba`` no deben tomarse demasiado en serio."

#: ../modules/naive_bayes.rst:74
msgid "H. Zhang (2004). `The optimality of Naive Bayes. <https://www.cs.unb.ca/~hzhang/publications/FLAIRS04ZhangH.pdf>`_ Proc. FLAIRS."
msgstr "H. Zhang (2004). `The optimality of Naive Bayes. <https://www.cs.unb.ca/~hzhang/publications/FLAIRS04ZhangH.pdf>`_ Proc. FLAIRS."

#: ../modules/naive_bayes.rst:81
msgid "Gaussian Naive Bayes"
msgstr "Bayesiano ingenuo Gaussiano"

#: ../modules/naive_bayes.rst:83
msgid ":class:`GaussianNB` implements the Gaussian Naive Bayes algorithm for classification. The likelihood of the features is assumed to be Gaussian:"
msgstr ":class:`GaussianNB` implementa el algoritmo Bayesiano ingenuo Gaussiano para la clasificación. Se supone que la probabilidad de las características es gaussiana:"

#: ../modules/naive_bayes.rst:86
msgid "P(x_i \\mid y) = \\frac{1}{\\sqrt{2\\pi\\sigma^2_y}} \\exp\\left(-\\frac{(x_i - \\mu_y)^2}{2\\sigma^2_y}\\right)"
msgstr "P(x_i \\mid y) = \\frac{1}{\\sqrt{2\\pi\\sigma^2_y}} \\exp\\left(-\\frac{(x_i - \\mu_y)^2}{2\\sigma^2_y}\\right)"

#: ../modules/naive_bayes.rst:90
msgid "The parameters :math:`\\sigma_y` and :math:`\\mu_y` are estimated using maximum likelihood."
msgstr "Los parámetros :math:`sigma_y` y :math:`mu_y` se estiman por máxima verosimilitud."

#: ../modules/naive_bayes.rst:107
msgid "Multinomial Naive Bayes"
msgstr "Bayesiano ingenuo multinomial"

#: ../modules/naive_bayes.rst:109
msgid ":class:`MultinomialNB` implements the naive Bayes algorithm for multinomially distributed data, and is one of the two classic naive Bayes variants used in text classification (where the data are typically represented as word vector counts, although tf-idf vectors are also known to work well in practice). The distribution is parametrized by vectors :math:`\\theta_y = (\\theta_{y1},\\ldots,\\theta_{yn})` for each class :math:`y`, where :math:`n` is the number of features (in text classification, the size of the vocabulary) and :math:`\\theta_{yi}` is the probability :math:`P(x_i \\mid y)` of feature :math:`i` appearing in a sample belonging to class :math:`y`."
msgstr ":class:`MultinomialNB` implementa el algoritmo Bayesiano ingenuo para datos distribuidos multinomialmente, y es una de las dos variantes clásicas de Bayesiano ingenuo utilizadas en la clasificación de textos (donde los datos se representan típicamente como recuentos de vectores de palabras, aunque también se sabe que los vectores tf-idf funcionan bien en la práctica). La distribución está parametrizada por vectores :math:`theta_y = (\\theta_{y1},\\ldots,\\theta_{yn})` para cada clase :math:`y`, donde :math: `n` es el número de características (en la clasificación de textos, el tamaño del vocabulario) y :math:`theta_{yi}` es la probabilidad :math:`P(x_i \\mid y)` de que la característica :math:`i` aparezca en una muestra perteneciente a la clase :math:`y`."

#: ../modules/naive_bayes.rst:120
msgid "The parameters :math:`\\theta_y` is estimated by a smoothed version of maximum likelihood, i.e. relative frequency counting:"
msgstr "Los parámetros :math:`\\theta_y` se estiman por una versión suavizada de la verosimilitud máxima, es decir, conteo de frecuencia relativa:"

#: ../modules/naive_bayes.rst:123
msgid "\\hat{\\theta}_{yi} = \\frac{ N_{yi} + \\alpha}{N_y + \\alpha n}"
msgstr "\\hat{\\theta}_{yi} = \\frac{ N_{yi} + \\alpha}{N_y + \\alpha n}"

#: ../modules/naive_bayes.rst:127
msgid "where :math:`N_{yi} = \\sum_{x \\in T} x_i` is the number of times feature :math:`i` appears in a sample of class :math:`y` in the training set :math:`T`, and :math:`N_{y} = \\sum_{i=1}^{n} N_{yi}` is the total count of all features for class :math:`y`."
msgstr "donde :math:`N_{yi} = \\sum_{x \\in T} x_i` es el número de veces que la característica :math:`i` aparece en una muestra de la clase :math:`y` en el set de entrenamiento :math:`T`, y :math:`N_{y} = \\sum_{i=1}^{n} N_{yi}` es el recuento total de todas las características para la clase :math:`y`."

#: ../modules/naive_bayes.rst:133
msgid "The smoothing priors :math:`\\alpha \\ge 0` accounts for features not present in the learning samples and prevents zero probabilities in further computations. Setting :math:`\\alpha = 1` is called Laplace smoothing, while :math:`\\alpha < 1` is called Lidstone smoothing."
msgstr "El suavizado anterior :math:`\\alpha \\ge 0` cuenta con características no presentes en las muestras de aprendizaje y previene cero probabilidades en futuros cálculos. Establecer :math:`\\alpha = 1` se llama Suavizado Laplace, mientras que :math:`\\alpha < 1` se llama Suavizado Lidstone."

#: ../modules/naive_bayes.rst:142
msgid "Complement Naive Bayes"
msgstr "Complemento de Bayesiano ingenuo"

#: ../modules/naive_bayes.rst:144
msgid ":class:`ComplementNB` implements the complement naive Bayes (CNB) algorithm. CNB is an adaptation of the standard multinomial naive Bayes (MNB) algorithm that is particularly suited for imbalanced data sets. Specifically, CNB uses statistics from the *complement* of each class to compute the model's weights. The inventors of CNB show empirically that the parameter estimates for CNB are more stable than those for MNB. Further, CNB regularly outperforms MNB (often by a considerable margin) on text classification tasks. The procedure for calculating the weights is as follows:"
msgstr ":class:`ComplementNB` implementa el algoritmo Bayesiano ingenuo complementario (CNB). CNB es una adaptación del algoritmo estándar de Bayesiano ingenuo multinomial (MNB) que es especialmente adecuado para conjuntos de datos desequilibrados. En concreto, el CNB utiliza las estadísticas del *complemento* de cada clase para calcular las ponderaciones del modelo. Los inventores de CNB demuestran empíricamente que las estimaciones de los parámetros de CNB son más estables que las de MNB. Además, CNB supera regularmente a MNB (a menudo por un margen considerable) en tareas de clasificación de textos. El procedimiento para calcular las ponderaciones es el siguiente:"

#: ../modules/naive_bayes.rst:153
msgid "\\hat{\\theta}_{ci} = \\frac{\\alpha_i + \\sum_{j:y_j \\neq c} d_{ij}}\n"
"                         {\\alpha + \\sum_{j:y_j \\neq c} \\sum_{k} d_{kj}}\n\n"
"w_{ci} = \\log \\hat{\\theta}_{ci}\n\n"
"w_{ci} = \\frac{w_{ci}}{\\sum_{j} |w_{cj}|}"
msgstr "\\hat{\\theta}_{ci} = \\frac{\\alpha_i + \\sum_{j:y_j \\neq c} d_{ij}}\n"
"                         {\\alpha + \\sum_{j:y_j \\neq c} \\sum_{k} d_{kj}}\n\n"
"w_{ci} = \\log \\hat{\\theta}_{ci}\n\n"
"w_{ci} = \\frac{w_{ci}}{\\sum_{j} |w_{cj}|}"

#: ../modules/naive_bayes.rst:162
msgid "where the summations are over all documents :math:`j` not in class :math:`c`, :math:`d_{ij}` is either the count or tf-idf value of term :math:`i` in document :math:`j`, :math:`\\alpha_i` is a smoothing hyperparameter like that found in MNB, and :math:`\\alpha = \\sum_{i} \\alpha_i`. The second normalization addresses the tendency for longer documents to dominate parameter estimates in MNB. The classification rule is:"
msgstr "donde las sumatorias son sobre todos los documentos :math:`j` que no están en la clase :math:`c`, :math:`d_{ij}` es el recuento o el valor tf-idf del término :math:`i` en el documento :math:`j`, :math:`alpha_i` es un hiperparámetro de suavización como el que se encuentra en MNB, y :math:`alpha = \\sum_{i} \\alpha_i``. \\alpha_i`. La segunda normalización aborda la tendencia de los documentos más largos a dominar las estimaciones de los parámetros en MNB. La regla de clasificación es:"

#: ../modules/naive_bayes.rst:169
msgid "\\hat{c} = \\arg\\min_c \\sum_{i} t_i w_{ci}"
msgstr "\\hat{c} = \\arg\\min_c \\sum_{i} t_i w_{ci}"

#: ../modules/naive_bayes.rst:173
msgid "i.e., a document is assigned to the class that is the *poorest* complement match."
msgstr "es decir, se asigna un documento a la clase que es la *más pobre* coincidencia de complementos."

#: ../modules/naive_bayes.rst:178
msgid "Rennie, J. D., Shih, L., Teevan, J., & Karger, D. R. (2003). `Tackling the poor assumptions of naive bayes text classifiers. <https://people.csail.mit.edu/jrennie/papers/icml03-nb.pdf>`_ In ICML (Vol. 3, pp. 616-623)."
msgstr "Rennie, J. D., Shih, L., Teevan, J., & Karger, D. R. (2003). `Tackling the poor assumptions of naive bayes text classifiers. <https://people.csail.mit.edu/jrennie/papers/icml03-nb.pdf>`_ In ICML (Vol. 3, pp. 616-623)."

#: ../modules/naive_bayes.rst:186
msgid "Bernoulli Naive Bayes"
msgstr "Bayesiano ingenuo de Bernoulli"

#: ../modules/naive_bayes.rst:188
msgid ":class:`BernoulliNB` implements the naive Bayes training and classification algorithms for data that is distributed according to multivariate Bernoulli distributions; i.e., there may be multiple features but each one is assumed to be a binary-valued (Bernoulli, boolean) variable. Therefore, this class requires samples to be represented as binary-valued feature vectors; if handed any other kind of data, a ``BernoulliNB`` instance may binarize its input (depending on the ``binarize`` parameter)."
msgstr "La clase ``BernoulliNB`` implementa los algoritmos de entrenamiento y clasificación de Bayesiano ingenuo para los datos que se distribuyen de acuerdo con las distribuciones Bernoulli multivariadas; es decir, puede haber múltiples características pero se asume que cada una es una variable de valor binario (Bernoulli, booleano). Por lo tanto, esta clase requiere que las muestras se representen como vectores de características de valor binario; si se entrega cualquier otro tipo de datos, una instancia de ``BernoulliNB`` puede binarizar su entrada (dependiendo del parámetro ``binarize``)."

#: ../modules/naive_bayes.rst:196
msgid "The decision rule for Bernoulli naive Bayes is based on"
msgstr "La regla de decisión para los Bayesianos ingenuos de Bernoulli se basa en"

#: ../modules/naive_bayes.rst:198
msgid "P(x_i \\mid y) = P(i \\mid y) x_i + (1 - P(i \\mid y)) (1 - x_i)"
msgstr "P(x_i \\mid y) = P(i \\mid y) x_i + (1 - P(i \\mid y)) (1 - x_i)"

#: ../modules/naive_bayes.rst:202
msgid "which differs from multinomial NB's rule in that it explicitly penalizes the non-occurrence of a feature :math:`i` that is an indicator for class :math:`y`, where the multinomial variant would simply ignore a non-occurring feature."
msgstr "que difiere de la regla de Bayesiano ingenuo multinomial en que penaliza explícitamente la no ocurrencia de una característica :math:`i` que es un indicador de la clase :math:`y`, mientras que la variante multinomial simplemente ignoraría una característica no ocurrente."

#: ../modules/naive_bayes.rst:207
msgid "In the case of text classification, word occurrence vectors (rather than word count vectors) may be used to train and use this classifier. ``BernoulliNB`` might perform better on some datasets, especially those with shorter documents. It is advisable to evaluate both models, if time permits."
msgstr "En el caso de la clasificación de textos, se pueden utilizar vectores de ocurrencia de palabras (en lugar de vectores de recuento de palabras) para entrenar y utilizar este clasificador. ``BernoulliNB`` podría tener un mejor rendimiento en algunos conjuntos de datos, especialmente en aquellos con documentos más cortos. Es aconsejable evaluar ambos modelos, si el tiempo lo permite."

#: ../modules/naive_bayes.rst:214
msgid "C.D. Manning, P. Raghavan and H. Schütze (2008). Introduction to Information Retrieval. Cambridge University Press, pp. 234-265."
msgstr "C.D. Manning, P. Raghavan and H. Schütze (2008). Introduction to Information Retrieval. Cambridge University Press, pp. 234-265."

#: ../modules/naive_bayes.rst:217
msgid "A. McCallum and K. Nigam (1998). `A comparison of event models for Naive Bayes text classification. <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1529>`_ Proc. AAAI/ICML-98 Workshop on Learning for Text Categorization, pp. 41-48."
msgstr "A. McCallum and K. Nigam (1998). `A comparison of event models for Naive Bayes text classification. <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1529>`_ Proc. AAAI/ICML-98 Workshop on Learning for Text Categorization, pp. 41-48."

#: ../modules/naive_bayes.rst:222
msgid "V. Metsis, I. Androutsopoulos and G. Paliouras (2006). `Spam filtering with Naive Bayes -- Which Naive Bayes? <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.61.5542>`_ 3rd Conf. on Email and Anti-Spam (CEAS)."
msgstr "V. Metsis, I. Androutsopoulos and G. Paliouras (2006). `Spam filtering with Naive Bayes -- Which Naive Bayes? <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.61.5542>`_ 3rd Conf. on Email and Anti-Spam (CEAS)."

#: ../modules/naive_bayes.rst:230
msgid "Categorical Naive Bayes"
msgstr "Bayesiano ingenuo categórico"

#: ../modules/naive_bayes.rst:232
msgid ":class:`CategoricalNB` implements the categorical naive Bayes algorithm for categorically distributed data. It assumes that each feature, which is described by the index :math:`i`, has its own categorical distribution."
msgstr ":class:`CategoricalNB` implementa el algoritmo de Bayesiano ingenuo categórico para datos distribuidos categóricamente. Supone que cada característica, descrita por el índice :math:`i`, tiene su propia distribución categórica."

#: ../modules/naive_bayes.rst:237
msgid "For each feature :math:`i` in the training set :math:`X`, :class:`CategoricalNB` estimates a categorical distribution for each feature i of X conditioned on the class y. The index set of the samples is defined as :math:`J = \\{ 1, \\dots, m \\}`, with :math:`m` as the number of samples."
msgstr "Para cada característica :math:`i` del conjunto de entrenamiento :math:`X`, :class:`CategoricalNB` estima una distribución categórica para cada característica i de X condicionada a la clase y. El conjunto de índices de las muestras se define como :math:`J = \\{ 1, \\dots, m \\}`, siendo :math:`m` el número de muestras."

#: ../modules/naive_bayes.rst:242
msgid "The probability of category :math:`t` in feature :math:`i` given class :math:`c` is estimated as:"
msgstr "Se estima la probabilidad de la categoría :math:`t` en la característica :math:`i` dada clase :math:`c`:"

#: ../modules/naive_bayes.rst:245
msgid "P(x_i = t \\mid y = c \\: ;\\, \\alpha) = \\frac{ N_{tic} + \\alpha}{N_{c} +\n"
"                                       \\alpha n_i},"
msgstr "P(x_i = t \\mid y = c \\: ;\\, \\alpha) = \\frac{ N_{tic} + \\alpha}{N_{c} +\n"
"                                       \\alpha n_i},"

#: ../modules/naive_bayes.rst:250
msgid "where :math:`N_{tic} = |\\{j \\in J \\mid x_{ij} = t, y_j = c\\}|` is the number of times category :math:`t` appears in the samples :math:`x_{i}`, which belong to class :math:`c`, :math:`N_{c} = |\\{ j \\in J\\mid y_j = c\\}|` is the number of samples with class c, :math:`\\alpha` is a smoothing parameter and :math:`n_i` is the number of available categories of feature :math:`i`."
msgstr "donde :math:`N_{tic} = |\\{j \\in J \\mid x_{ij} = t, y_j = c\\}|` es el número de veces que aparece la categoría :math:`t` en las muestras :math:`x_{i}`, que pertenecen a la clase :math:`c`, :math:`N_{c} = |\\{ j \\in J\\mid y_j = c\\}|` es el número de muestras con la clase c, :math:`\\alpha` es un parámetro suavizado y :math:`n_i` es el número de categorías disponibles de la función :math:`i`."

#: ../modules/naive_bayes.rst:256
msgid ":class:`CategoricalNB` assumes that the sample matrix :math:`X` is encoded (for instance with the help of :class:`OrdinalEncoder`) such that all categories for each feature :math:`i` are represented with numbers :math:`0, ..., n_i - 1` where :math:`n_i` is the number of available categories of feature :math:`i`."
msgstr ":class:`CategoricalNB` asume que la matriz de muestra :math:`X` está codificada (por ejemplo con la ayuda de :class:`OrdinalEncoder`) de forma que todas las categorías de cada característica :math:`i` están representadas con números :math:`0, ..., n_i - 1` donde :math:`n_i` es el número de categorías disponibles de la característica :math:`i`."

#: ../modules/naive_bayes.rst:263
msgid "Out-of-core naive Bayes model fitting"
msgstr "Ajuste del modelo de Bayesiano ingenuo fuera del núcleo"

#: ../modules/naive_bayes.rst:265
msgid "Naive Bayes models can be used to tackle large scale classification problems for which the full training set might not fit in memory. To handle this case, :class:`MultinomialNB`, :class:`BernoulliNB`, and :class:`GaussianNB` expose a ``partial_fit`` method that can be used incrementally as done with other classifiers as demonstrated in :ref:`sphx_glr_auto_examples_applications_plot_out_of_core_classification.py`. All naive Bayes classifiers support sample weighting."
msgstr "Los modelos Bayesianoa ingenuos pueden utilizarse para abordar problemas de clasificación a gran escala para los que el conjunto de entrenamiento completo podría no caber en la memoria. Para manejar este caso, :class:`MultinomialNB`, :class:`BernoulliNB`, y :class:`GaussianNB` exponen un método ``partial_fit`` que puede ser utilizado de forma incremental como se hace con otros clasificadores como se demuestra en :ref:`sphx_glr_auto_examples_applications_plot_out_of_core_classification.py`. Todos los clasificadores Bayesianos ingenuos admiten la ponderación de las muestras."

#: ../modules/naive_bayes.rst:273
msgid "Contrary to the ``fit`` method, the first call to ``partial_fit`` needs to be passed the list of all the expected class labels."
msgstr "Contrario al método ``fit``, la primera llamada a ``partial_fit`` necesita ser pasada la lista de todas las etiquetas de clase esperadas."

#: ../modules/naive_bayes.rst:276
msgid "For an overview of available strategies in scikit-learn, see also the :ref:`out-of-core learning <scaling_strategies>` documentation."
msgstr "Para una visión general de las estrategias disponibles en scikit-learn, vea también la documentación :ref:`aprendiendo fuera del núcleo <scaling_strategies>`."

#: ../modules/naive_bayes.rst:281
msgid "The ``partial_fit`` method call of naive Bayes models introduces some computational overhead. It is recommended to use data chunk sizes that are as large as possible, that is as the available RAM allows."
msgstr "La llamada al método ``partial_fit`` de los modelos Bayesianos ingenuos introduce cierta sobrecarga computacional. Se recomienda utilizar tamaños de trozos de datos lo más grandes posible, es decir, lo que permita la memoria RAM disponible."

