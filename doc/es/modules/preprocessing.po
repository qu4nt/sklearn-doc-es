msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 11:24-0400\n"
"PO-Revision-Date: 2021-05-07 22:31\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/preprocessing.po\n"
"X-Crowdin-File-ID: 4804\n"
"Language: es_ES\n"

#: ../modules/preprocessing.rst:5
msgid "Preprocessing data"
msgstr "Preprocesamiento de los datos"

#: ../modules/preprocessing.rst:9
msgid "The ``sklearn.preprocessing`` package provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators."
msgstr "El paquete ``sklearn.preprocessing`` proporciona varias funciones de utilidad comunes y clases transformadoras para cambiar los vectores de características en bruto a una representación que sea más adecuada para los estimadores posteriores."

#: ../modules/preprocessing.rst:13
msgid "In general, learning algorithms benefit from standardization of the data set. If some outliers are present in the set, robust scalers or transformers are more appropriate. The behaviors of the different scalers, transformers, and normalizers on a dataset containing marginal outliers is highlighted in :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`."
msgstr "En general, los algoritmos de aprendizaje se benefician de la estandarización del conjunto de datos. Si hay algunos valores atípicos presentes en el conjunto, los escaladores robustos o transformadores son más apropiados. Los comportamientos de los diferentes escaladores, transformadores y normalizadores en un conjunto de datos que contiene valores atípicos marginales se resaltan en :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`."

#: ../modules/preprocessing.rst:23
msgid "Standardization, or mean removal and variance scaling"
msgstr "Estandarización, o eliminación media y escala de varianza"

#: ../modules/preprocessing.rst:25
msgid "**Standardization** of datasets is a **common requirement for many machine learning estimators** implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with **zero mean and unit variance**."
msgstr "La **Estandarización** de conjuntos de datos es un **requisito común para muchos estimadores de aprendizaje automático** implementados en scikit-learn; podrían comportarse mal si las características individuales no se ven más o menos como datos distribuidos normalmente estándar: Gaussiana con **media cero y varianza unitaria**."

#: ../modules/preprocessing.rst:30
msgid "In practice we often ignore the shape of the distribution and just transform the data to center it by removing the mean value of each feature, then scale it by dividing non-constant features by their standard deviation."
msgstr "En la práctica a menudo ignoramos la forma de la distribución y simplemente transformamos los datos para centrarlos eliminando el valor medio de cada característica, luego los escalamos dividiendo características no constantes por su desviación estándar."

#: ../modules/preprocessing.rst:35
msgid "For instance, many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) assume that all features are centered around zero and have variance in the same order. If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected."
msgstr "Por ejemplo, muchos elementos utilizados en la función objetivo de un algoritmo de aprendizaje (como el kernel RBF de Máquinas de Vectores de Soporte o los regularizadores l1 y l2 de modelos lineales) asumen que todas las características están centradas en cero y tienen varianza del mismo orden. Si una característica tiene varianza de un orden de magnitud mayor que otras, podría dominar la función objetivo y hacer que el estimador no pueda aprender de otras características correctamente como se esperaba."

#: ../modules/preprocessing.rst:44
msgid "The :mod:`~sklearn.preprocessing` module provides the :class:`StandardScaler` utility class, which is a quick and easy way to perform the following operation on an array-like dataset::"
msgstr "El módulo :mod:`~sklearn.preprocessing` proporciona la clase de utilidad :class:`StandardScaler`, que es una forma rápida y sencilla de realizar la siguiente operación en un conjunto de datos array-like::"

#: ../modules/preprocessing.rst:75
msgid "Scaled data has zero mean and unit variance::"
msgstr "Los datos escalados tienen una media cero y varianza unitaria::"

#: ../modules/preprocessing.rst:85
msgid "This class implements the ``Transformer`` API to compute the mean and standard deviation on a training set so as to be able to later re-apply the same transformation on the testing set. This class is hence suitable for use in the early steps of a :class:`~sklearn.pipeline.Pipeline`::"
msgstr "Esta clase implementa la API ``Transformer`` para calcular la media y la desviación estándar en un conjunto de entrenamiento para poder volver a aplicar posteriormente la misma transformación en el conjunto de prueba. Esta clase es, por lo tanto, adecuada para su uso en los primeros pasos de un :class:`~sklearn.pipeline.Pipeline`::"

#: ../modules/preprocessing.rst:106
msgid "It is possible to disable either centering or scaling by either passing ``with_mean=False`` or ``with_std=False`` to the constructor of :class:`StandardScaler`."
msgstr "Es posible desactivar el centrado o el escalado pasando ``with_mean=False`` o ``with_std=False`` al constructor de :class:`StandardScaler`."

#: ../modules/preprocessing.rst:112
msgid "Scaling features to a range"
msgstr "Escalamiento de las características a un rango"

#: ../modules/preprocessing.rst:114
msgid "An alternative standardization is scaling features to lie between a given minimum and maximum value, often between zero and one, or so that the maximum absolute value of each feature is scaled to unit size. This can be achieved using :class:`MinMaxScaler` or :class:`MaxAbsScaler`, respectively."
msgstr "Una estandarización alternativa es el escalamiento de características para que se sitúen entre un valor mínimo y máximo determinado, a menudo entre cero y uno, o para que el valor absoluto máximo de cada característica se escalado al tamaño unitario. Esto puede lograrse utilizando :class:`MinMaxScaler` o :class:`MaxAbsScaler`, respectivamente."

#: ../modules/preprocessing.rst:120
msgid "The motivation to use this scaling include robustness to very small standard deviations of features and preserving zero entries in sparse data."
msgstr "La motivación para utilizar esta escala incluye robustez ante desviaciones estándar muy pequeñas de las características y preservando las entradas cero en los datos dispersos."

#: ../modules/preprocessing.rst:123
msgid "Here is an example to scale a toy data matrix to the ``[0, 1]`` range::"
msgstr "Aquí hay un ejemplo para escalar una matriz de datos de juguete al rango ``[0, 1]``::"

#: ../modules/preprocessing.rst:136
msgid "The same instance of the transformer can then be applied to some new test data unseen during the fit call: the same scaling and shifting operations will be applied to be consistent with the transformation performed on the train data::"
msgstr "La misma instancia del transformador puede aplicarse a unos nuevos datos de prueba no vistos durante el llamado de ajuste: se aplicarán las mismas operaciones de escalamiento y desplazamiento para ser coherentes con la transformación realizada en los datos de entrenamiento::"

#: ../modules/preprocessing.rst:145
msgid "It is possible to introspect the scaler attributes to find about the exact nature of the transformation learned on the training data::"
msgstr "Es posible inspeccionar los atributos del escalador para encontrar la naturaleza exacta de la transformación aprendida en los datos de entrenamiento::"

#: ../modules/preprocessing.rst:154
msgid "If :class:`MinMaxScaler` is given an explicit ``feature_range=(min, max)`` the full formula is::"
msgstr "Si a :class:`MinMaxScaler` se le da un ``feature_range=(min, max)`` explícito la fórmula completa es::"

#: ../modules/preprocessing.rst:161
msgid ":class:`MaxAbsScaler` works in a very similar fashion, but scales in a way that the training data lies within the range ``[-1, 1]`` by dividing through the largest maximum value in each feature. It is meant for data that is already centered at zero or sparse data."
msgstr ":class:`MaxAbsScaler` funciona de una manera muy similar, pero escala de una manera que los datos de entrenamiento se encuentran dentro del rango ``[-1, 1]`` dividiendo entre el valor máximo más grande en cada característica. Está pensado para datos que ya están centrados en cero o datos dispersos."

#: ../modules/preprocessing.rst:166
msgid "Here is how to use the toy data from the previous example with this scaler::"
msgstr "Aquí está cómo utilizar los datos de juguete del ejemplo anterior con este escalador::"

#: ../modules/preprocessing.rst:187
msgid "Scaling sparse data"
msgstr "Escalamiento de datos dispersos"

#: ../modules/preprocessing.rst:188
msgid "Centering sparse data would destroy the sparseness structure in the data, and thus rarely is a sensible thing to do. However, it can make sense to scale sparse inputs, especially if features are on different scales."
msgstr "Centrar datos dispersos destruiría la estructura de dispersión en los datos, por lo que rara vez es algo sensato para hacer. Sin embargo, puede tener sentido escalar las entradas dispersas, especialmente si las características están en diferentes escalas."

#: ../modules/preprocessing.rst:192
msgid ":class:`MaxAbsScaler` was specifically designed for scaling sparse data, and is the recommended way to go about this. However, :class:`StandardScaler` can accept ``scipy.sparse`` matrices  as input, as long as ``with_mean=False`` is explicitly passed to the constructor. Otherwise a ``ValueError`` will be raised as silently centering would break the sparsity and would often crash the execution by allocating excessive amounts of memory unintentionally. :class:`RobustScaler` cannot be fitted to sparse inputs, but you can use the ``transform`` method on sparse inputs."
msgstr ":class:`MaxAbsScaler` fue diseñado específicamente para el escalamiento de datos dispersos, y es la forma recomendada de hacerlo. Sin embargo, :class:`StandardScaler` puede aceptar matrices ``scipy.sparse`` como entrada, siempre que se pase explícitamente ``with_mean=False`` al constructor. De lo contrario, se producirá un ``ValueError`` ya que el centrado silencioso rompería la dispersión y a menudo bloquearía la ejecución al asignar involuntariamente cantidades excesivas de memoria.  :class:`RobustScaler` no puede ajustarse a entradas dispersas, pero puede utilizar el método ``transform`` en entradas dispersas."

#: ../modules/preprocessing.rst:202
msgid "Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse Columns format (see ``scipy.sparse.csr_matrix`` and ``scipy.sparse.csc_matrix``). Any other sparse input will be **converted to the Compressed Sparse Rows representation**.  To avoid unnecessary memory copies, it is recommended to choose the CSR or CSC representation upstream."
msgstr "Ten en cuenta que los escaladores aceptan tanto el formato de Filas Dispersas Comprimidas (CSR) como el formato de Columnas Dispersas Comprimidas (CSC)  (ver ``scipy.sparse.csr_matrix`` y ``scipy.sparse.csc_matrix``). Cualquier otra entrada dispersa será **convertida a la representación Filas Dispersas Comprimidas**. Para evitar copias de memoria innecesarias, se recomienda elegir la representación CSR o CSC en la parte superior."

#: ../modules/preprocessing.rst:208
msgid "Finally, if the centered data is expected to be small enough, explicitly converting the input to an array using the ``toarray`` method of sparse matrices is another option."
msgstr "Por último, si se espera que los datos centrados sean lo suficientemente pequeños, otra opción es convertir explícitamente la entrada en un arreglo utilizando el método ``toarray`` de matrices dispersas."

#: ../modules/preprocessing.rst:214
msgid "Scaling data with outliers"
msgstr "Escalamiento de datos con valores atípicos"

#: ../modules/preprocessing.rst:216
msgid "If your data contains many outliers, scaling using the mean and variance of the data is likely to not work very well. In these cases, you can use :class:`RobustScaler` as a drop-in replacement instead. It uses more robust estimates for the center and range of your data."
msgstr "Si tus datos contienen muchos valores atípicos, es probable que el escalamiento utilizando la media y la varianza de los datos no funcione muy bien. En estos casos, puedes utilizar :class:`RobustScaler` como reemplazo. Este utiliza estimaciones más robustas para el centrado y el rango de tus datos."

msgid "References:"
msgstr "Referencias:"

#: ../modules/preprocessing.rst:224
msgid "Further discussion on the importance of centering and scaling data is available on this FAQ: `Should I normalize/standardize/rescale the data? <http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html>`_"
msgstr "Más información sobre la importancia del centrado y escalamiento de los datos está disponible en este FAQ:`Should I normalize/standardize/rescale the data? <http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html>`_"

msgid "Scaling vs Whitening"
msgstr "Escalamiento vs Whitening"

#: ../modules/preprocessing.rst:230
msgid "It is sometimes not enough to center and scale the features independently, since a downstream model can further make some assumption on the linear independence of the features."
msgstr "A veces no es suficiente con centrar y escalar las características de forma independiente, ya que un modelo posterior puede hacer alguna suposición sobre la independencia lineal de las características."

#: ../modules/preprocessing.rst:234
msgid "To address this issue you can use :class:`~sklearn.decomposition.PCA` with ``whiten=True`` to further remove the linear correlation across features."
msgstr "Para solucionar este problema se puede utilizar :class:`~sklearn.decomposition.PCA` con ``whiten=True`` para eliminar aún más la correlación lineal entre las características."

#: ../modules/preprocessing.rst:240
msgid "Centering kernel matrices"
msgstr "Centrado de matrices del kernel"

#: ../modules/preprocessing.rst:242
msgid "If you have a kernel matrix of a kernel :math:`K` that computes a dot product in a feature space defined by function :math:`\\phi`, a :class:`KernelCenterer` can transform the kernel matrix so that it contains inner products in the feature space defined by :math:`\\phi` followed by removal of the mean in that space."
msgstr "Si tienes una matriz de kernel de un kernel :math:`K` que calcula un producto punto en un espacio de características definido por la función :math:`\\phi`, un :class:`KernelCenterer` puede transformar la matriz de kernel para que contenga productos internos en el espacio de características definido por :math:`\\phi` seguido de la eliminación de la media en ese espacio."

#: ../modules/preprocessing.rst:251
msgid "Non-linear transformation"
msgstr "Transformación no lineal"

#: ../modules/preprocessing.rst:253
msgid "Two types of transformations are available: quantile transforms and power transforms. Both quantile and power transforms are based on monotonic transformations of the features and thus preserve the rank of the values along each feature."
msgstr "Hay dos tipos de transformaciones disponibles: las transformaciones de cuantiles y las transformaciones de potencia. Tanto las transformaciones de cuantiles como las de potencia se basan en transformaciones monótonas de las características y, por tanto, preservan el rango de los valores a lo largo de cada característica."

#: ../modules/preprocessing.rst:258
msgid "Quantile transforms put all features into the same desired distribution based on the formula :math:`G^{-1}(F(X))` where :math:`F` is the cumulative distribution function of the feature and :math:`G^{-1}` the `quantile function <https://en.wikipedia.org/wiki/Quantile_function>`_ of the desired output distribution :math:`G`. This formula is using the two following facts: (i) if :math:`X` is a random variable with a continuous cumulative distribution function :math:`F` then :math:`F(X)` is uniformly distributed on :math:`[0,1]`; (ii) if :math:`U` is a random variable with uniform distribution on :math:`[0,1]` then :math:`G^{-1}(U)` has distribution :math:`G`. By performing a rank transformation, a quantile transform smooths out unusual distributions and is less influenced by outliers than scaling methods. It does, however, distort correlations and distances within and across features."
msgstr "Las transformaciones de cuantiles ponen todas las características en la misma distribución deseada basándose en la fórmula :math:`G^{-1}(F(X))` donde :math:`F` es la función de distribución acumulada de la característica y :math:`G^{-1}` la `función cuantil <https://en.wikipedia.org/wiki/Quantile_function>`_ de la distribución de salida deseada :math:`G`. Esta fórmula utiliza los dos siguientes hechos: (i) si :math:`X` es una variable aleatoria con una función de distribución acumulada continua :math:`F`, entonces :math:`F(X)` se distribuye uniformemente en :math:`[0, 1]`; (ii) si :math:`U` es una variable aleatoria con distribución uniforme en :math:`[0, 1]` entonces :math:`G^{-1}(U)` tiene distribución :math:`G`. Al realizar una transformación de rango, una transformación de cuantil suaviza las distribuciones inusuales y está menos influenciada por los valores atípicos que los métodos de escalamiento. Sin embargo, distorsiona las correlaciones y distancias dentro y entre características."

#: ../modules/preprocessing.rst:271
msgid "Power transforms are a family of parametric transformations that aim to map data from any distribution to as close to a Gaussian distribution."
msgstr "Las transformaciones de potencia son una familia de transformaciones paramétricas cuyo objetivo es mapear datos de cualquier distribución a lo más parecido a una Distribución Gaussiana."

#: ../modules/preprocessing.rst:275
msgid "Mapping to a Uniform distribution"
msgstr "Mapeo a una Distribución Uniforme"

#: ../modules/preprocessing.rst:277
msgid ":class:`QuantileTransformer` provides a non-parametric transformation to map the data to a uniform distribution with values between 0 and 1::"
msgstr ":class:`QuantileTransformer` proporciona una transformación no paramétrica para mapear los datos a una distribución uniforme con valores entre 0 y 1::"

#: ../modules/preprocessing.rst:291
msgid "This feature corresponds to the sepal length in cm. Once the quantile transformation applied, those landmarks approach closely the percentiles previously defined::"
msgstr "Esta característica corresponde a la longitud del sépalo en cm. Una vez aplicada la transformación de cuantiles, esos hitos se acercan estrechamente a los percentiles definidos anteriormente::"

#: ../modules/preprocessing.rst:299
msgid "This can be confirmed on a independent testing set with similar remarks::"
msgstr "Esto puede confirmarse en un conjunto de pruebas independientes con observaciones similares::"

#: ../modules/preprocessing.rst:309
msgid "Mapping to a Gaussian distribution"
msgstr "Mapeo a una Distribución Gaussiana"

#: ../modules/preprocessing.rst:311
msgid "In many modeling scenarios, normality of the features in a dataset is desirable. Power transforms are a family of parametric, monotonic transformations that aim to map data from any distribution to as close to a Gaussian distribution as possible in order to stabilize variance and minimize skewness."
msgstr "En muchos escenarios de modelado, es deseable la normalidad de las características de un conjunto de datos. Las transformaciones de potencia son una familia de transformaciones paramétricas y monótonas cuyo objetivo es mapear los datos de cualquier distribución a una distribución lo más cercana posible a una distribución Gaussiana con el fin de estabilizar la varianza y minimizar la asimetría."

#: ../modules/preprocessing.rst:316
msgid ":class:`PowerTransformer` currently provides two such power transformations, the Yeo-Johnson transform and the Box-Cox transform."
msgstr ":class:`PowerTransformer` actualmente proporciona dos transformaciones de potencia de este tipo, la transformación Yeo-Johnson y la transformación Box-Cox."

#: ../modules/preprocessing.rst:319
msgid "The Yeo-Johnson transform is given by:"
msgstr "La transformación Yeo-Johnson viene dada por:"

#: ../modules/preprocessing.rst:321
msgid "x_i^{(\\lambda)} =\n"
"\\begin{cases}\n"
" [(x_i + 1)^\\lambda - 1] / \\lambda & \\text{if } \\lambda \\neq 0, x_i \\geq 0, \\\\[8pt]\n"
"\\ln{(x_i + 1)} & \\text{if } \\lambda = 0, x_i \\geq 0 \\\\[8pt]\n"
"-[(-x_i + 1)^{2 - \\lambda} - 1] / (2 - \\lambda) & \\text{if } \\lambda \\neq 2, x_i < 0, \\\\[8pt]\n"
" - \\ln (- x_i + 1) & \\text{if } \\lambda = 2, x_i < 0\n"
"\\end{cases}\n\n"
msgstr "x_i^{(\\lambda)} =\n"
"\\begin{cases}\n"
" [(x_i + 1)^\\lambda - 1] / \\lambda & \\text{if } \\lambda \\neq 0, x_i \\geq 0, \\\\[8pt]\n"
"\\ln{(x_i + 1)} & \\text{if } \\lambda = 0, x_i \\geq 0 \\\\[8pt]\n"
"-[(-x_i + 1)^{2 - \\lambda} - 1] / (2 - \\lambda) & \\text{if } \\lambda \\neq 2, x_i < 0, \\\\[8pt]\n"
" - \\ln (- x_i + 1) & \\text{if } \\lambda = 2, x_i < 0\n"
"\\end{cases}\n\n"

#: ../modules/preprocessing.rst:330
msgid "while the Box-Cox transform is given by:"
msgstr "mientras que la transformación Box-Cox viene dada por:"

#: ../modules/preprocessing.rst:332
msgid "x_i^{(\\lambda)} =\n"
"\\begin{cases}\n"
"\\dfrac{x_i^\\lambda - 1}{\\lambda} & \\text{if } \\lambda \\neq 0, \\\\[8pt]\n"
"\\ln{(x_i)} & \\text{if } \\lambda = 0,\n"
"\\end{cases}\n\n"
msgstr "x_i^{(\\lambda)} =\n"
"\\begin{cases}\n"
"\\dfrac{x_i^\\lambda - 1}{\\lambda} & \\text{if } \\lambda \\neq 0, \\\\[8pt]\n"
"\\ln{(x_i)} & \\text{if } \\lambda = 0,\n"
"\\end{cases}\n\n"

#: ../modules/preprocessing.rst:340
msgid "Box-Cox can only be applied to strictly positive data. In both methods, the transformation is parameterized by :math:`\\lambda`, which is determined through maximum likelihood estimation. Here is an example of using Box-Cox to map samples drawn from a lognormal distribution to a normal distribution::"
msgstr "Box-Cox sólo puede aplicarse a datos estrictamente positivos. En ambos métodos, la transformación está parametrizada por :math:`\\lambda`, que se determina a través de la estimación de máxima verosimilitud. Aquí hay un ejemplo de uso de Box-Cox para mapear muestras extraídas de una distribución lognormal a una distribución normal::"

#: ../modules/preprocessing.rst:356
msgid "While the above example sets the `standardize` option to `False`, :class:`PowerTransformer` will apply zero-mean, unit-variance normalization to the transformed output by default."
msgstr "Mientras que el ejemplo anterior establece la opción `standardize` en `False`, :class:`PowerTransformer` aplicará por defecto una normalización de media cero y varianza unitaria a la salida transformada."

#: ../modules/preprocessing.rst:360
msgid "Below are examples of Box-Cox and Yeo-Johnson applied to various probability distributions.  Note that when applied to certain distributions, the power transforms achieve very Gaussian-like results, but with others, they are ineffective. This highlights the importance of visualizing the data before and after transformation."
msgstr "A continuación se muestran ejemplos de Box-Cox y Yeo-Johnson aplicados a varias distribuciones de probabilidad. Ten en cuenta que cuando se aplican a ciertas distribuciones, las transformaciones de potencia consiguen resultados muy parecidos a los Gaussianos, pero con otras, son ineficaces. Esto resalta la importancia de visualizar los datos antes y después de la transformación."

#: ../modules/preprocessing.rst:371
msgid "It is also possible to map data to a normal distribution using :class:`QuantileTransformer` by setting ``output_distribution='normal'``. Using the earlier example with the iris dataset::"
msgstr "También es posible mapear los datos a una distribución normal usando :class:`QuantileTransformer` estableciendo ``output_distribution='normal'``. Utilizando el ejemplo anterior con el conjunto de datos iris::"

#: ../modules/preprocessing.rst:387
msgid "Thus the median of the input becomes the mean of the output, centered at 0. The normal output is clipped so that the input's minimum and maximum --- corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively --- do not become infinite under the transformation."
msgstr "Así, la mediana de la entrada se convierte en la media de la salida, centrada en 0. La salida normal es recortada para que el mínimo y el máximo de la entrada --- correspondientes a las cantidades 1e-7 y 1 - 1e-7 respectivamente --- no se conviertan en infinitos bajo la transformación."

#: ../modules/preprocessing.rst:395
msgid "Normalization"
msgstr "Normalización"

#: ../modules/preprocessing.rst:397
msgid "**Normalization** is the process of **scaling individual samples to have unit norm**. This process can be useful if you plan to use a quadratic form such as the dot-product or any other kernel to quantify the similarity of any pair of samples."
msgstr "La **normalización** es el proceso de **escalamiento de muestras individuales para tener la norma unitaria**. Este proceso puede ser útil si planeas utilizar una forma cuadrática como el producto punto o cualquier otro kernel para cuantificar la similitud de cualquier par de muestras."

#: ../modules/preprocessing.rst:402
msgid "This assumption is the base of the `Vector Space Model <https://en.wikipedia.org/wiki/Vector_Space_Model>`_ often used in text classification and clustering contexts."
msgstr "Este supuesto es la base del `Modelo de espacio vectorial <https://en.wikipedia.org/wiki/Vector_Space_Model>`_ utilizado a menudo en los contextos de clasificación y agrupamiento de textos."

#: ../modules/preprocessing.rst:406
msgid "The function :func:`normalize` provides a quick and easy way to perform this operation on a single array-like dataset, either using the ``l1``, ``l2``, or ``max`` norms::"
msgstr "La función :func:`normalize` proporciona una forma rápida y sencilla de realizar esta operación en un único conjunto de datos array-like, ya sea utilizando las normas ``l1``, ``l2`` o ``max``::"

#: ../modules/preprocessing.rst:420
msgid "The ``preprocessing`` module further provides a utility class :class:`Normalizer` that implements the same operation using the ``Transformer`` API (even though the ``fit`` method is useless in this case: the class is stateless as this operation treats samples independently)."
msgstr "El módulo ``preprocessing`` proporciona además una clase de utilidad :class:`Normalizer` que implementa la misma operación utilizando la API ``Transformer`` (aunque el método ``fit`` es inútil en este caso: la clase no tiene estado ya que esta operación trata las muestras de forma independiente)."

#: ../modules/preprocessing.rst:425
msgid "This class is hence suitable for use in the early steps of a :class:`~sklearn.pipeline.Pipeline`::"
msgstr "Esta clase es, por tanto, adecuada para su uso en los primeros pasos de un :class:`~sklearn.pipeline.Pipeline`::"

#: ../modules/preprocessing.rst:433
msgid "The normalizer instance can then be used on sample vectors as any transformer::"
msgstr "La instancia del normalizador puede utilizarse en vectores de muestra como cualquier transformador::"

#: ../modules/preprocessing.rst:444
msgid "Note: L2 normalization is also known as spatial sign preprocessing."
msgstr "Nota: La normalización L2 también se conoce como preprocesamiento de signos espaciales."

msgid "Sparse input"
msgstr "Entrada dispersa"

#: ../modules/preprocessing.rst:448
msgid ":func:`normalize` and :class:`Normalizer` accept **both dense array-like and sparse matrices from scipy.sparse as input**."
msgstr ":func:`normalize` and :class:`Normalizer` aceptan **tanto array-like densos como matrices dispersas de scipy.sparse como entrada**."

#: ../modules/preprocessing.rst:451
msgid "For sparse input the data is **converted to the Compressed Sparse Rows representation** (see ``scipy.sparse.csr_matrix``) before being fed to efficient Cython routines. To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream."
msgstr "Para la entrada dispersa los datos son **convertidos a la representación Filas Dispersas Comprimidas ** (ver scipy.sparse.csr_matrix) antes de ser alimentado a las rutinas eficientes de Cython. Para evitar copias de memoria innecesarias, se recomienda elegir la representación CSR de entrada."

#: ../modules/preprocessing.rst:459
msgid "Encoding categorical features"
msgstr "Codificación de características categóricas"

#: ../modules/preprocessing.rst:460
msgid "Often features are not given as continuous values but categorical. For example a person could have features ``[\"male\", \"female\"]``, ``[\"from Europe\", \"from US\", \"from Asia\"]``, ``[\"uses Firefox\", \"uses Chrome\", \"uses Safari\", \"uses Internet Explorer\"]``. Such features can be efficiently coded as integers, for instance ``[\"male\", \"from US\", \"uses Internet Explorer\"]`` could be expressed as ``[0, 1, 3]`` while ``[\"female\", \"from Asia\", \"uses Chrome\"]`` would be ``[1, 2, 1]``."
msgstr "A menudo las características no se dan como valores continuos sino como categóricos. Por ejemplo, una persona podría tener características ``[\"male\", \"female\"]``,``[\"from Europe\", \"from US\", \"from Asia\"]``, ``[\"uses Firefox\", \"uses Chrome\", \"uses Safari\", \"uses Internet Explorer\"]``. Estas características pueden codificarse eficazmente como enteros, por ejemplo ``[\"male\", \"from US\", \"uses Internet Explorer\"]`` podría expresarse como ``[0, 1, 3]`` mientras que ``[\"female\", \"from Asia\", \"uses Chrome\"]`` sería ``[1, 2, 1]``."

#: ../modules/preprocessing.rst:469
msgid "To convert categorical features to such integer codes, we can use the :class:`OrdinalEncoder`. This estimator transforms each categorical feature to one new feature of integers (0 to n_categories - 1)::"
msgstr "Para convertir características categóricas en dichos códigos de enteros, podemos utilizar el :class:`OrdinalEncoder`. Este estimador transforma cada característica categórica en una nueva característica de enteros (0 a n_categorías - 1)::"

#: ../modules/preprocessing.rst:480
msgid "Such integer representation can, however, not be used directly with all scikit-learn estimators, as these expect continuous input, and would interpret the categories as being ordered, which is often not desired (i.e. the set of browsers was ordered arbitrarily)."
msgstr "Sin embargo, esta representación de números enteros no puede utilizarse directamente con todos los estimadores de scikit-learn, ya que éstos esperan una entrada continua, e interpretarían las categorías como si estuvieran ordenadas, lo que a menudo no se desea (es decir, el conjunto de navegadores se ordenó arbitrariamente)."

#: ../modules/preprocessing.rst:485
msgid "Another possibility to convert categorical features to features that can be used with scikit-learn estimators is to use a one-of-K, also known as one-hot or dummy encoding. This type of encoding can be obtained with the :class:`OneHotEncoder`, which transforms each categorical feature with ``n_categories`` possible values into ``n_categories`` binary features, with one of them 1, and all others 0."
msgstr "Otra posibilidad para convertir características categóricas en características que puedan ser utilizadas con los estimadores de scikit-learn es utilizar un one-of-K, también conocido como codificación one-hot o dummy. Este tipo de codificación se puede obtener con el :class:`OneHotEncoder`, que transforma cada característica categórica con ``n_categories`` posibles en ``n_categories`` con características binarias, una de ellas 1, y todas las demás 0."

#: ../modules/preprocessing.rst:493
msgid "Continuing the example above::"
msgstr "Continuando el ejemplo anterior::"

#: ../modules/preprocessing.rst:504
msgid "By default, the values each feature can take is inferred automatically from the dataset and can be found in the ``categories_`` attribute::"
msgstr "Por defecto, los valores que puede tomar cada característica se infieren automáticamente del conjunto de datos y se pueden encontrar en el atributo ``categories_``::"

#: ../modules/preprocessing.rst:510
msgid "It is possible to specify this explicitly using the parameter ``categories``. There are two genders, four possible continents and four web browsers in our dataset::"
msgstr "Es posible especificar esto explícitamente utilizando el parámetro ``categories`. En nuestro conjunto de datos hay dos géneros, cuatro continentes posibles y cuatro navegadores web::"

#: ../modules/preprocessing.rst:530
msgid "If there is a possibility that the training data might have missing categorical features, it can often be better to specify ``handle_unknown='ignore'`` instead of setting the ``categories`` manually as above. When ``handle_unknown='ignore'`` is specified and unknown categories are encountered during transform, no error will be raised but the resulting one-hot encoded columns for this feature will be all zeros (``handle_unknown='ignore'`` is only supported for one-hot encoding)::"
msgstr "Si existe la posibilidad de que los datos de entrenamiento puedan tener características categóricas perdidas, a menudo puede ser mejor especificar ``handle_unknown='ignore'`` en lugar de establecer las ``categories`` manualmente como arriba. Cuando se especifica ``handle_unknown='ignore'`` y se encuentran categorías desconocidas durante la transformación, no se producirá ningún error, pero las columnas codificadas en one-hot para esta característica serán todos ceros (``handle_unknown='ignore'` sólo se admite para la codificación one-hot)::"

#: ../modules/preprocessing.rst:546
msgid "It is also possible to encode each column into ``n_categories - 1`` columns instead of ``n_categories`` columns by using the ``drop`` parameter. This parameter allows the user to specify a category for each feature to be dropped. This is useful to avoid co-linearity in the input matrix in some classifiers. Such functionality is useful, for example, when using non-regularized regression (:class:`LinearRegression <sklearn.linear_model.LinearRegression>`), since co-linearity would cause the covariance matrix to be non-invertible. When this parameter is not None, ``handle_unknown`` must be set to ``error``::"
msgstr "También es posible codificar cada columna en ``n_categories - 1`` columnas en lugar de ``n_categories`` columnas usando el parámetro ``drop``. Este parámetro permite al usuario especificar una categoría para cada característica que se va a descartar. Esto es útil para evitar la colinealidad en la matriz de entrada en algunos clasificadores. Esta funcionalidad es útil, por ejemplo, cuando se utiliza una regresión no regularizada (:class:`LinearRegression <sklearn.linear_model.LinearRegression>`), ya que la colinealidad haría que la matriz de covarianzas no fuera invertible. Cuando este parámetro no None, ``handle_unknown`` debe establecerse como ``error``::"

#: ../modules/preprocessing.rst:565
msgid "One might want to drop one of the two columns only for features with 2 categories. In this case, you can set the parameter `drop='if_binary'`."
msgstr "Es posible que quieras eliminar una de las dos columnas sólo para las características con 2 categorías. En este caso, puedes establecer el parámetro `drop='if_binary'`."

#: ../modules/preprocessing.rst:579
msgid "In the transformed `X`, the first column is the encoding of the feature with categories \"male\"/\"female\", while the remaining 6 columns is the encoding of the 2 features with respectively 3 categories each."
msgstr "En la transformada `X`, la primera columna es la codificación de la característica con las categorías \"male\"/\"female\", mientras que las 6 columnas restantes son la codificación de las 2 características con respectivamente 3 categorías cada una."

#: ../modules/preprocessing.rst:583
msgid ":class:`OneHotEncoder` supports categorical features with missing values by considering the missing values as an additional category::"
msgstr ":class:`OneHotEncoder` soporta características categóricas con valores faltantes considerando los valores faltantes como una categoría adicional::"

#: ../modules/preprocessing.rst:598
msgid "If a feature contains both `np.nan` and `None`, they will be considered separate categories::"
msgstr "Si una característica contiene tanto `np.nan` como `None` se considerarán categorías separadas::"

#: ../modules/preprocessing.rst:611
msgid "See :ref:`dict_feature_extraction` for categorical features that are represented as a dict, not as scalars."
msgstr "Vea :ref:`dict_feature_extraction` para características categóricas que se representan como un diccionario, no como escalares."

#: ../modules/preprocessing.rst:617
msgid "Discretization"
msgstr "Discretización"

#: ../modules/preprocessing.rst:619
msgid "`Discretization <https://en.wikipedia.org/wiki/Discretization_of_continuous_features>`_ (otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes."
msgstr "`Discretización <https://en.wikipedia.org/wiki/Discretization_of_continuous_features>`_ (también conocida como cuantificación o binning) proporciona una forma de dividir características continuas en valores discretos. Ciertos conjuntos de datos con características continuas pueden beneficiarse de la discretización, ya que ésta puede transformar el conjunto de datos de atributos continuos en uno con sólo atributos nominales."

#: ../modules/preprocessing.rst:625
msgid "One-hot encoded discretized features can make a model more expressive, while maintaining interpretability. For instance, pre-processing with a discretizer can introduce nonlinearity to linear models."
msgstr "Las características discretizadas codificadas de One-hot pueden hacer que un modelo sea más expresivo, manteniendo al mismo tiempo la capacidad de interpretación. Por ejemplo, el preprocesamiento con un discretizador puede introducir la no linealidad en los modelos lineales."

#: ../modules/preprocessing.rst:630
msgid "K-bins discretization"
msgstr "Discretización K-clases o intervalos de clase"

#: ../modules/preprocessing.rst:632
msgid ":class:`KBinsDiscretizer` discretizes features into ``k`` bins::"
msgstr ":class:`KBinsDiscretizer` discretiza las características en ``k`` intervalos de clases::"

#: ../modules/preprocessing.rst:639
msgid "By default the output is one-hot encoded into a sparse matrix (See :ref:`preprocessing_categorical_features`) and this can be configured with the ``encode`` parameter. For each feature, the bin edges are computed during ``fit`` and together with the number of bins, they will define the intervals. Therefore, for the current example, these intervals are defined as:"
msgstr "Por defecto, la salida está codificada one-hot en una matriz dispersa (Ver :ref:`preprocessing_categorical_features`) y esto puede configurarse con el parámetro ``encode``. Para cada característica, los límites del intervalo de clase se calculan durante el ``fit`` y junto con el número de intervalos de clase, definirán los intervalos. Por lo tanto, para el ejemplo actual, estos intervalos se definen como:"

#: ../modules/preprocessing.rst:646
msgid "feature 1: :math:`{[-\\infty, -1), [-1, 2), [2, \\infty)}`"
msgstr "característica 1: :math:`{[-\\infty, -1), [-1, 2), [2, \\infty)}`"

#: ../modules/preprocessing.rst:647
msgid "feature 2: :math:`{[-\\infty, 5), [5, \\infty)}`"
msgstr "característica 2: :math:`{[-\\infty, 5), [5, \\infty)}`"

#: ../modules/preprocessing.rst:648
msgid "feature 3: :math:`{[-\\infty, 14), [14, \\infty)}`"
msgstr "característica 3: :math:`{[-\\infty, 14), [14, \\infty)}`"

#: ../modules/preprocessing.rst:650
msgid "Based on these bin intervals, ``X`` is transformed as follows::"
msgstr "Basado en estos intervalos de clase, ``X`` se transforma de la siguiente manera::"

#: ../modules/preprocessing.rst:657
msgid "The resulting dataset contains ordinal attributes which can be further used in a :class:`~sklearn.pipeline.Pipeline`."
msgstr "El conjunto de datos resultante contiene atributos ordinales que pueden utilizarse posteriormente en un :class:`~sklearn.pipeline.Pipeline`."

#: ../modules/preprocessing.rst:660
msgid "Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins."
msgstr "La discretización es similar a la construcción de histogramas para datos continuos. Sin embargo, los histogramas se centran en el recuento de características que caen en determinados intervalos de clase, mientras que la discretización se centra en asignar valores de características a estos intervalos de clases."

#: ../modules/preprocessing.rst:664
msgid ":class:`KBinsDiscretizer` implements different binning strategies, which can be selected with the ``strategy`` parameter. The 'uniform' strategy uses constant-width bins. The 'quantile' strategy uses the quantiles values to have equally populated bins in each feature. The 'kmeans' strategy defines bins based on a k-means clustering procedure performed on each feature independently."
msgstr ":class:`KBinsDiscretizer` implementa diferentes estrategias de binning, que se pueden seleccionar con el parámetro ``strategy``. La estrategia ``uniform'' utiliza intervalos de clase de ancho constante. La estrategia 'quantile' utiliza los valores cuantiles para tener intervalos de claase igualmente poblados en cada característica. La estrategia \"kmeans\" define los intervalos basándose en un procedimiento de agrupamiento por k-medias realizado en cada característica de forma independiente."

#: ../modules/preprocessing.rst:670
msgid "Be aware that one can specify custom bins by passing a callable defining the discretization strategy to :class:`~sklearn.preprocessing.FunctionTransformer`. For instance, we can use the Pandas function :func:`pandas.cut`::"
msgstr "Ten en cuenta que puedes especificar intervalos de clase personalizados pasando un invocable que defina la estrategia de discretización a :class:`~sklearn. reprocessing.FunctionTransformer`. Por ejemplo, podemos utilizar la función de Pandas :func:`pandas.cut`::"

#: ../modules/preprocessing.rst:688
msgid ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization.py`"
msgstr ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization.py`"

#: ../modules/preprocessing.rst:689
msgid ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`"
msgstr ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`"

#: ../modules/preprocessing.rst:690
msgid ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_strategies.py`"
msgstr ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_strategies.py`"

#: ../modules/preprocessing.rst:695
msgid "Feature binarization"
msgstr "Binarización de característica"

#: ../modules/preprocessing.rst:697
msgid "**Feature binarization** is the process of **thresholding numerical features to get boolean values**. This can be useful for downstream probabilistic estimators that make assumption that the input data is distributed according to a multi-variate `Bernoulli distribution <https://en.wikipedia.org/wiki/Bernoulli_distribution>`_. For instance, this is the case for the :class:`~sklearn.neural_network.BernoulliRBM`."
msgstr "La **binarización de características** es el proceso de **fijar umbrales de las características numéricas para obtener valores booleanos**. Esto puede ser útil para estimadores probabilísticos posteriores que suponen que los datos de entrada se distribuyen según una distribución `Bernoulli <https://en.wikipedia.org/wiki/Bernoulli_distribution>`_ multivariante. Por ejemplo, este es el caso de :class:`~sklearn.neural_network.BernoulliRBM`."

#: ../modules/preprocessing.rst:704
msgid "It is also common among the text processing community to use binary feature values (probably to simplify the probabilistic reasoning) even if normalized counts (a.k.a. term frequencies) or TF-IDF valued features often perform slightly better in practice."
msgstr "También es común entre la comunidad de procesadores de texto utilizar valores binarios de las características (probablemente para simplificar el razonamiento probabilístico) aunque los recuentos normalizados (también conocidos como frecuencias de términos) o las características con valores TF-IDF suelen tener un rendimiento ligeramente superior en la práctica."

#: ../modules/preprocessing.rst:709
msgid "As for the :class:`Normalizer`, the utility class :class:`Binarizer` is meant to be used in the early stages of :class:`~sklearn.pipeline.Pipeline`. The ``fit`` method does nothing as each sample is treated independently of others::"
msgstr "En cuanto al :class:`Normalizer`, la clase de utilidad :class:`Binarizer` está pensada para ser utilizada en las primeras etapas de :class:`~sklearn.pipeline.Pipeline`. El método ``fit`` no hace nada ya que cada muestra es tratada independientemente de las demás::"

#: ../modules/preprocessing.rst:727
msgid "It is possible to adjust the threshold of the binarizer::"
msgstr "Es posible ajustar el umbral del binarizador::"

#: ../modules/preprocessing.rst:735
msgid "As for the :class:`Normalizer` class, the preprocessing module provides a companion function :func:`binarize` to be used when the transformer API is not necessary."
msgstr "En cuanto a la clase :class:`Normalizer`, el módulo de preprocesamiento proporciona una función complementaria :func:`binarize` para ser utilizada cuando la API del transformador no es necesaria."

#: ../modules/preprocessing.rst:739
msgid "Note that the :class:`Binarizer` is similar to the :class:`KBinsDiscretizer` when ``k = 2``, and when the bin edge is at the value ``threshold``."
msgstr "Ten en cuenta que el :class:`Binarizer` es similar al :class:`KBinsDiscretizer` cuando ``k = 2``, y cuando el límite del intervalo de clase está en el valor ``threshold``."

#: ../modules/preprocessing.rst:744
msgid ":func:`binarize` and :class:`Binarizer` accept **both dense array-like and sparse matrices from scipy.sparse as input**."
msgstr ":func:`binarize` y :class:`Binarizer` aceptan **tanto array-like densos como matrices dispersas de scipy.sparse como entrada**."

#: ../modules/preprocessing.rst:747
msgid "For sparse input the data is **converted to the Compressed Sparse Rows representation** (see ``scipy.sparse.csr_matrix``). To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream."
msgstr "Para la entrada dispersa los datos son **convertidos a la representación Filas Dispersas Comprimidas ** (ver ``scipy.sparse.csr_matrix``). Para evitar copias de memoria innecesarias, se recomienda elegir la representación CSR antes."

#: ../modules/preprocessing.rst:755
msgid "Imputation of missing values"
msgstr "Imputación de valores faltantes"

#: ../modules/preprocessing.rst:757
msgid "Tools for imputing missing values are discussed at :ref:`impute`."
msgstr "Las herramientas para la imputación de valores faltantes se discuten en :ref:`impute`."

#: ../modules/preprocessing.rst:762
msgid "Generating polynomial features"
msgstr "Generación de características polinómicas"

#: ../modules/preprocessing.rst:764
msgid "Often it's useful to add complexity to the model by considering nonlinear features of the input data. A simple and common method to use is polynomial features, which can get features' high-order and interaction terms. It is implemented in :class:`PolynomialFeatures`::"
msgstr "A menudo es útil añadir complejidad al modelo considerando características no lineales de los datos de entrada. Un método simple y común para utilizar son las características polinómicas, que permiten obtener los términos de alto orden e interacción de las características. Se implementa en :class:`PolinnomialFeatures`::"

#: ../modules/preprocessing.rst:779
msgid "The features of X have been transformed from :math:`(X_1, X_2)` to :math:`(1, X_1, X_2, X_1^2, X_1X_2, X_2^2)`."
msgstr "Las características de X han sido transformadas de :math:`(X_1, X_2)` a :math:`(1, X_1, X_2, X_1^2, X_1X_2, X_2^2)`."

#: ../modules/preprocessing.rst:781
msgid "In some cases, only interaction terms among features are required, and it can be gotten with the setting ``interaction_only=True``::"
msgstr "En algunos casos, sólo se requieren términos de interacción entre las características, y se pueden conseguir con el ajuste ``interaction_only=True``::"

#: ../modules/preprocessing.rst:794
msgid "The features of X have been transformed from :math:`(X_1, X_2, X_3)` to :math:`(1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)`."
msgstr "Las características de X han sido transformadas de :math:`(X_1, X_2, X_3)` a :math:`(1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)`."

#: ../modules/preprocessing.rst:796
msgid "Note that polynomial features are used implicitly in `kernel methods <https://en.wikipedia.org/wiki/Kernel_method>`_ (e.g., :class:`~sklearn.svm.SVC`, :class:`~sklearn.decomposition.KernelPCA`) when using polynomial :ref:`svm_kernels`."
msgstr "Ten en cuenta que las características polinómicas se utilizan implícitamente en los `métodos del kernel <https://en.wikipedia.org/wiki/Kernel_method>`_ (por ejemplo, :class:`~sklearn.svm.SVC`, :class:`~sklearn.decomposition.KernelPCA`) cuando se utilizan polinomios :ref:`svm_kernels`."

#: ../modules/preprocessing.rst:798
msgid "See :ref:`sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py` for Ridge regression using created polynomial features."
msgstr "Ver :ref:`sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py` para la Regresión de Cresta usando características polinómicas creadas."

#: ../modules/preprocessing.rst:803
msgid "Custom transformers"
msgstr "Transformadores personalizados"

#: ../modules/preprocessing.rst:805
msgid "Often, you will want to convert an existing Python function into a transformer to assist in data cleaning or processing. You can implement a transformer from an arbitrary function with :class:`FunctionTransformer`. For example, to build a transformer that applies a log transformation in a pipeline, do::"
msgstr "A menudo, querrás convertir una función existente de Python en un transformador para ayudar a limpiar o procesar datos. Puedes implementar un transformador desde una función arbitraria con :class:`FunctionTransformer`. Por ejemplo, para construir un transformador que aplique una transformación de registro en un pipeline, haz::"

#: ../modules/preprocessing.rst:818
msgid "You can ensure that ``func`` and ``inverse_func`` are the inverse of each other by setting ``check_inverse=True`` and calling ``fit`` before ``transform``. Please note that a warning is raised and can be turned into an error with a ``filterwarnings``::"
msgstr "Puedes asegurarte de que ``func`` e ``inverse_func`` son la inversa de los demás configurando ``check_inverse=True`` y llamando ``fit`` antes de ``transform``. Por favor, ten en cuenta que se producirá una advertencia y se puede convertir en un error con un ``filterwarnings``::"

#: ../modules/preprocessing.rst:827
msgid "For a full code example that demonstrates using a :class:`FunctionTransformer` to extract features from text data see :ref:`sphx_glr_auto_examples_compose_plot_column_transformer.py`"
msgstr "Para ver un ejemplo de código completo que demuestra el uso de :class:`FunctionTransformer` para extraer características de los datos de texto consulta :ref:`sphx_glr_auto_examples_compose_plot_column_transformer.py`"

