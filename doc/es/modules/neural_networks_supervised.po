msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 11:24-0400\n"
"PO-Revision-Date: 2021-05-26 03:41\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/neural_networks_supervised.po\n"
"X-Crowdin-File-ID: 4844\n"
"Language: es_ES\n"

#: ../modules/neural_networks_supervised.rst:5
msgid "Neural network models (supervised)"
msgstr "Modelos de redes neuronales (supervisadas)"

#: ../modules/neural_networks_supervised.rst:12
msgid "This implementation is not intended for large-scale applications. In particular, scikit-learn offers no GPU support. For much faster, GPU-based implementations, as well as frameworks offering much more flexibility to build deep learning architectures, see  :ref:`related_projects`."
msgstr "Esta implementación no está pensada para aplicaciones a gran escala. En particular, scikit-learn no ofrece soporte para GPU. Para implementaciones mucho más rápidas, basadas en la GPU, así como framework que ofrecen mucha más flexibilidad para construir arquitecturas de aprendizaje profundo (deep learning), véase :ref:`related_projects`."

#: ../modules/neural_networks_supervised.rst:20
msgid "Multi-layer Perceptron"
msgstr "Perceptrón multicapa"

#: ../modules/neural_networks_supervised.rst:22
msgid "**Multi-layer Perceptron (MLP)** is a supervised learning algorithm that learns a function :math:`f(\\cdot): R^m \\rightarrow R^o` by training on a dataset, where :math:`m` is the number of dimensions for input and :math:`o` is the number of dimensions for output. Given a set of features :math:`X = {x_1, x_2, ..., x_m}` and a target :math:`y`, it can learn a non-linear function approximator for either classification or regression. It is different from logistic regression, in that between the input and the output layer, there can be one or more non-linear layers, called hidden layers. Figure 1 shows a one hidden layer MLP with scalar output."
msgstr "**El Perceptrón Multicapa (Multi-layer Perceptron , MLP)** es un algoritmo de aprendizaje supervisado que aprende una función :math:`f(\\cdot): R^m \\rightarrow R^o` mediante el entrenamiento en un conjunto de datos, donde :math:`m` es el número de dimensiones de entrada y :math:`o` es el número de dimensiones de la salida. Dado un conjunto de características :math:`X = {x_1, x_2, ..., x_m}` y un objetivo :math:`y`, puede aprender un aproximador de función no lineal para la clasificación o la regresión. Se diferencia de la regresión logística en que, entre la capa de entrada y la de salida, puede haber una o más capas no lineales, llamadas capas ocultas. La figura 1 muestra un MLP de una capa oculta con salida escalar."

#: ../modules/neural_networks_supervised.rst:36
msgid "**Figure 1 : One hidden layer MLP.**"
msgstr "**Figura 1: MLP de una capa oculta .**"

#: ../modules/neural_networks_supervised.rst:38
msgid "The leftmost layer, known as the input layer, consists of a set of neurons :math:`\\{x_i | x_1, x_2, ..., x_m\\}` representing the input features. Each neuron in the hidden layer transforms the values from the previous layer with a weighted linear summation :math:`w_1x_1 + w_2x_2 + ... + w_mx_m`, followed by a non-linear activation function :math:`g(\\cdot):R \\rightarrow R` - like the hyperbolic tan function. The output layer receives the values from the last hidden layer and transforms them into output values."
msgstr "La capa más a la izquierda, conocida como la capa de entrada, consiste en un conjunto de neuronas :math:`\\{x_i | x_1, x_2, ..., x_m\\}` que representan las características de entrada. Cada neurona en la capa oculta transforma los valores de la capa anterior con una suma lineal ponderada :math:`w_1x_1 + w_2x_2 + ... + w_mx_m`, seguida de una función de activación no lineal :math:`g(\\cdot):R \\rightarrow R` - como la función tangente hiperbólica. La capa de salida recibe los valores de la última capa oculta y los transforma en valores de salida."

#: ../modules/neural_networks_supervised.rst:46
msgid "The module contains the public attributes ``coefs_`` and ``intercepts_``. ``coefs_`` is a list of weight matrices, where weight matrix at index :math:`i` represents the weights between layer :math:`i` and layer :math:`i+1`. ``intercepts_`` is a list of bias vectors, where the vector at index :math:`i` represents the bias values added to layer :math:`i+1`."
msgstr "El módulo contiene los atributos públicos ``coefs_`` y ``intercepts_``. ``coefs_`` es una lista de matrices de pesos, donde la matriz de pesos en el índice :math:`i` representa los pesos entre la capa :math:`i` y la capa :math:`i+1`. ``intercepts_`` es una lista de vectores de sesgo, donde el vector en el índice :math:`i` representa los valores de sesgo añadidos a la capa :math:`i+1`."

#: ../modules/neural_networks_supervised.rst:52
msgid "The advantages of Multi-layer Perceptron are:"
msgstr "Las ventajas del Perceptrón Multicapa son:"

#: ../modules/neural_networks_supervised.rst:54
msgid "Capability to learn non-linear models."
msgstr "Capacidad para aprender modelos no lineales."

#: ../modules/neural_networks_supervised.rst:56
msgid "Capability to learn models in real-time (on-line learning) using ``partial_fit``."
msgstr "Capacidad de aprender modelos en tiempo real (aprendizaje en línea) utilizando ``partial_fit``."

#: ../modules/neural_networks_supervised.rst:60
msgid "The disadvantages of Multi-layer Perceptron (MLP) include:"
msgstr "Las desventajas del Perceptrón Multicapa (MLP) incluyen:"

#: ../modules/neural_networks_supervised.rst:62
msgid "MLP with hidden layers have a non-convex loss function where there exists more than one local minimum. Therefore different random weight initializations can lead to different validation accuracy."
msgstr "Los MLP con capas ocultas tienen una función de pérdida no convexa en la que existe más de un mínimo local. Por lo tanto, diferentes inicializaciones de pesos aleatorios pueden conducir a una precisión de validación diferente."

#: ../modules/neural_networks_supervised.rst:66
msgid "MLP requires tuning a number of hyperparameters such as the number of hidden neurons, layers, and iterations."
msgstr "Los MLP requieren el ajuste de una serie de hiperparámetros, como el número de neuronas ocultas, las capas y las iteraciones."

#: ../modules/neural_networks_supervised.rst:69
msgid "MLP is sensitive to feature scaling."
msgstr "MLP es sensible al escalamiento de características."

#: ../modules/neural_networks_supervised.rst:71
msgid "Please see :ref:`Tips on Practical Use <mlp_tips>` section that addresses some of these disadvantages."
msgstr "Por favor consulta la sección :ref:`Consejos de uso práctico <mlp_tips>` que aborda algunas de estas desventajas."

#: ../modules/neural_networks_supervised.rst:76
msgid "Classification"
msgstr "Clasificación"

#: ../modules/neural_networks_supervised.rst:78
msgid "Class :class:`MLPClassifier` implements a multi-layer perceptron (MLP) algorithm that trains using `Backpropagation <http://ufldl.stanford.edu/wiki/index.php/Backpropagation_Algorithm>`_."
msgstr "La clase :class:`MLPClassifier` implementa un algoritmo de perceptrón multicapa (MLP) que se entrena utilizando `Retropropagación (Backpropagation) <http://ufldl.stanford.edu/wiki/index.php/Backpropagation_Algorithm>`_."

#: ../modules/neural_networks_supervised.rst:81
msgid "MLP trains on two arrays: array X of size (n_samples, n_features), which holds the training samples represented as floating point feature vectors; and array y of size (n_samples,), which holds the target values (class labels) for the training samples::"
msgstr "El MLP se entrena en dos arreglos: el arreglo X de tamaño (n_samples, n_features), que contiene las muestras de entrenamiento representadas como vectores de características de punto flotante; y el arreglo y de tamaño (n_samples,), que contiene los valores objetivo (etiquetas de clase) para las muestras de entrenamiento::"

#: ../modules/neural_networks_supervised.rst:96
msgid "After fitting (training), the model can predict labels for new samples::"
msgstr "Después del ajuste (entrenamiento), el modelo puede predecir las etiquetas para nuevas muestras::"

#: ../modules/neural_networks_supervised.rst:101
msgid "MLP can fit a non-linear model to the training data. ``clf.coefs_`` contains the weight matrices that constitute the model parameters::"
msgstr "El MLP puede ajustar un modelo no lineal a los datos de entrenamiento. ``clf.coefs_`` contiene las matrices de pesos que constituyen los parámetros del modelo::"

#: ../modules/neural_networks_supervised.rst:107
msgid "Currently, :class:`MLPClassifier` supports only the Cross-Entropy loss function, which allows probability estimates by running the ``predict_proba`` method."
msgstr "Actualmente, :class:`MLPClassifier` sólo admite la función de pérdida Cross-Entropy, que permite estimar la probabilidad ejecutando el método ``predict_proba``."

#: ../modules/neural_networks_supervised.rst:111
msgid "MLP trains using Backpropagation. More precisely, it trains using some form of gradient descent and the gradients are calculated using Backpropagation. For classification, it minimizes the Cross-Entropy loss function, giving a vector of probability estimates :math:`P(y|x)` per sample :math:`x`::"
msgstr "El MLP se entrena utilizando retropropagación (Backpropagation). Más concretamente, se entrena utilizando alguna forma de descenso de gradiente y los gradientes se calculan utilizando Backpropagation. Para la clasificación, minimiza la función de pérdida de entropía cruzada (Cross-Entropy), dando un vector de estimaciones de probabilidad :math:`P(y|x)` por muestra :math:`x`::"

#: ../modules/neural_networks_supervised.rst:120
msgid ":class:`MLPClassifier` supports multi-class classification by applying `Softmax <https://en.wikipedia.org/wiki/Softmax_activation_function>`_ as the output function."
msgstr ":class:`MLPClassifier` soporta la clasificación multiclase aplicando `Softmax <https://en.wikipedia.org/wiki/Softmax_activation_function>`_ como función de salida."

#: ../modules/neural_networks_supervised.rst:124
msgid "Further, the model supports :ref:`multi-label classification <multiclass>` in which a sample can belong to more than one class. For each class, the raw output passes through the logistic function. Values larger or equal to `0.5` are rounded to `1`, otherwise to `0`. For a predicted output of a sample, the indices where the value is `1` represents the assigned classes of that sample::"
msgstr "Además, el modelo admite :ref:`clasificación multi-etiqueta <multiclass>` en la que una muestra puede pertenecer a más de una clase. Para cada clase, la salida en bruto pasa por la función logística. Los valores mayores o iguales a `0,5` son redondeados a `1`, de lo contrario a `0`. Para una salida predicha de una muestra, los índices donde el valor es `1` representan las clases asignadas de esa muestra::"

#: ../modules/neural_networks_supervised.rst:143
msgid "See the examples below and the docstring of :meth:`MLPClassifier.fit` for further information."
msgstr "Puedes ver los siguientes ejemplos y la cadena de documentación de :meth:`MLPClassifier.fit` para obtener más información."

#: ../modules/neural_networks_supervised.rst:148
msgid ":ref:`sphx_glr_auto_examples_neural_networks_plot_mlp_training_curves.py`"
msgstr ":ref:`sphx_glr_auto_examples_neural_networks_plot_mlp_training_curves.py`"

#: ../modules/neural_networks_supervised.rst:149
msgid ":ref:`sphx_glr_auto_examples_neural_networks_plot_mnist_filters.py`"
msgstr ":ref:`sphx_glr_auto_examples_neural_networks_plot_mnist_filters.py`"

#: ../modules/neural_networks_supervised.rst:152
msgid "Regression"
msgstr "Regresión"

#: ../modules/neural_networks_supervised.rst:154
msgid "Class :class:`MLPRegressor` implements a multi-layer perceptron (MLP) that trains using backpropagation with no activation function in the output layer, which can also be seen as using the identity function as activation function. Therefore, it uses the square error as the loss function, and the output is a set of continuous values."
msgstr "La clase :class:`MLPRegressor` implementa un perceptrón múlticapa (MLP) que se entrena mediante retropropagación (backpropagation) sin función de activación en la capa de salida, lo que también puede ser visto como el uso de la función de identidad como función de activación. Por lo tanto, utiliza el error cuadrado como función de pérdida, y la salida es un conjunto de valores continuos."

#: ../modules/neural_networks_supervised.rst:160
msgid ":class:`MLPRegressor` also supports multi-output regression, in which a sample can have more than one target."
msgstr ":class:`MLPRegressor` también admite la regresión de salida múltiple, en la que una muestra puede tener más de un objetivo."

#: ../modules/neural_networks_supervised.rst:164
msgid "Regularization"
msgstr "Regularización"

#: ../modules/neural_networks_supervised.rst:166
msgid "Both :class:`MLPRegressor` and :class:`MLPClassifier` use parameter ``alpha`` for regularization (L2 regularization) term which helps in avoiding overfitting by penalizing weights with large magnitudes. Following plot displays varying decision function with value of alpha."
msgstr "Tanto :class:`MLPRegressor` como :class:`MLPClassifier` utilizan el parámetro ``alpha`` para el término regularización (L2 regularization) que ayuda a evitar sobreajuste penalizando pesos con grandes magnitudes. El siguiente gráfico muestra la variación de la función de decisión con el valor de alfa (alpha)."

#: ../modules/neural_networks_supervised.rst:176
msgid "See the examples below for further information."
msgstr "Consulta los siguientes ejemplos para obtener más información."

#: ../modules/neural_networks_supervised.rst:180
msgid ":ref:`sphx_glr_auto_examples_neural_networks_plot_mlp_alpha.py`"
msgstr ":ref:`sphx_glr_auto_examples_neural_networks_plot_mlp_alpha.py`"

#: ../modules/neural_networks_supervised.rst:183
msgid "Algorithms"
msgstr "Algoritmos"

#: ../modules/neural_networks_supervised.rst:185
msgid "MLP trains using `Stochastic Gradient Descent <https://en.wikipedia.org/wiki/Stochastic_gradient_descent>`_, `Adam <https://arxiv.org/abs/1412.6980>`_, or `L-BFGS <https://en.wikipedia.org/wiki/Limited-memory_BFGS>`__. Stochastic Gradient Descent (SGD) updates parameters using the gradient of the loss function with respect to a parameter that needs adaptation, i.e."
msgstr "El MPL se entrena utilizando `El descenso de gradiente estocástico (Stochastic Gradient Descent) <https://en.wikipedia.org/wiki/Stochastic_gradient_descent>`_, `Adam <https://arxiv.org/abs/1412.6980>`_, o `L-BFGS <https://en.wikipedia.org/wiki/Limited-memory_BFGS>`__. El Descenso Gradiente Estocástico (SGD) actualiza los parámetros utilizando el gradiente de la función de pérdida con respecto a un parámetro que necesita adaptación, es decir."

#: ../modules/neural_networks_supervised.rst:192
msgid "w \\leftarrow w - \\eta (\\alpha \\frac{\\partial R(w)}{\\partial w}\n"
"+ \\frac{\\partial Loss}{\\partial w})"
msgstr "w \\leftarrow w - \\eta (\\alpha \\frac{\\partial R(w)}{\\partial w}\n"
"+ \\frac{\\partial Loss}{\\partial w})"

#: ../modules/neural_networks_supervised.rst:197
msgid "where :math:`\\eta` is the learning rate which controls the step-size in the parameter space search.  :math:`Loss` is the loss function used for the network."
msgstr "donde :math:`\\eta` es la tasa de aprendizaje que controla el tamaño del paso en la búsqueda del espacio de parámetros. :math:`Loss` es la función de pérdida utilizada para la red."

#: ../modules/neural_networks_supervised.rst:201
msgid "More details can be found in the documentation of `SGD <http://scikit-learn.org/stable/modules/sgd.html>`_"
msgstr "Puedes encontrar más detalles en la documentación de `SGD <http://scikit-learn.org/stable/modules/sgd.html>`_"

#: ../modules/neural_networks_supervised.rst:204
msgid "Adam is similar to SGD in a sense that it is a stochastic optimizer, but it can automatically adjust the amount to update parameters based on adaptive estimates of lower-order moments."
msgstr "Adam es similar al SGD en el sentido de que es un optimizador estocástico, pero puede ajustar automáticamente la cantidad para actualizar los parámetros basándose en las estimaciones adaptativas de los momentos de orden inferior."

#: ../modules/neural_networks_supervised.rst:208
msgid "With SGD or Adam, training supports online and mini-batch learning."
msgstr "Con SGD o Adam, el entrenamiento admite aprendizaje en línea y en mini lotes."

#: ../modules/neural_networks_supervised.rst:210
msgid "L-BFGS is a solver that approximates the Hessian matrix which represents the second-order partial derivative of a function. Further it approximates the inverse of the Hessian matrix to perform parameter updates. The implementation uses the Scipy version of `L-BFGS <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html>`_."
msgstr "L-BFGS es un solucionador que aproxima la matriz Hessiana que representa la derivada parcial de segundo orden de una función. Además, aproxima la inversa de la matriz Hessiana para realizar actualizaciones de parámetros. La implementación utiliza la versión Scipy de `L-BFGS <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html>`_."

#: ../modules/neural_networks_supervised.rst:216
msgid "If the selected solver is 'L-BFGS', training does not support online nor mini-batch learning."
msgstr "Si el solucionador seleccionado es 'L-BFGS', el entrenamiento no admite el aprendizaje en línea ni en mini lotes."

#: ../modules/neural_networks_supervised.rst:221
msgid "Complexity"
msgstr "Complejidad"

#: ../modules/neural_networks_supervised.rst:223
msgid "Suppose there are :math:`n` training samples, :math:`m` features, :math:`k` hidden layers, each containing :math:`h` neurons - for simplicity, and :math:`o` output neurons.  The time complexity of backpropagation is :math:`O(n\\cdot m \\cdot h^k \\cdot o \\cdot i)`, where :math:`i` is the number of iterations. Since backpropagation has a high time complexity, it is advisable to start with smaller number of hidden neurons and few hidden layers for training."
msgstr "Supongamos que hay :math:`n` muestras de entrenamiento, :math:`m` características, :math:`k` capas ocultas, cada una de las cuales contiene :math:`h` neuronas - para simplificar, y :math:`o` neuronas de salida.  La complejidad temporal de la retropropagación es :math:`O(n\\cdot m \\cdot h^k \\cdot o \\cdot i)`, donde :math:`i` es el número de iteraciones. Dado que la retropropagación tiene una alta complejidad temporal, es aconsejable empezar con un número menor de neuronas ocultas y pocas capas ocultas para el entrenamiento."

#: ../modules/neural_networks_supervised.rst:233
msgid "Mathematical formulation"
msgstr "Formulación matemática"

#: ../modules/neural_networks_supervised.rst:235
msgid "Given a set of training examples :math:`(x_1, y_1), (x_2, y_2), \\ldots, (x_n, y_n)` where :math:`x_i \\in \\mathbf{R}^n` and :math:`y_i \\in \\{0, 1\\}`, a one hidden layer one hidden neuron MLP learns the function :math:`f(x) = W_2 g(W_1^T x + b_1) + b_2` where :math:`W_1 \\in \\mathbf{R}^m` and :math:`W_2, b_1, b_2 \\in \\mathbf{R}` are model parameters. :math:`W_1, W_2` represent the weights of the input layer and hidden layer, respectively; and :math:`b_1, b_2` represent the bias added to the hidden layer and the output layer, respectively. :math:`g(\\cdot) : R \\rightarrow R` is the activation function, set by default as the hyperbolic tan. It is given as,"
msgstr "Dado un conjunto de ejemplos de entrenamiento :math:`(x_1, y_1), (x_2, y_2), \\ldots, (x_n, y_n)` donde :math:`x_i \\in \\mathbf{R}^n` y :math:`y_i \\in \\0, 1\\}`, un MLP de una capa oculta y una neurona oculta aprende la función :math:`f(x) = W_2 g(W_1^T x + b_1) + b_2` donde :math:`W_1 \\in \\mathbf{R}^m` y :math:`W_2, b_1, b_2 \\in \\mathbf{R}` son parámetros del modelo. :math:`W_1, W_2` representan los pesos de la capa de entrada y de la capa oculta, respectivamente; y :math:`b_1, b_2` representan el sesgo añadido a la capa oculta y a la capa de salida, respectivamente. :math:`g(\\cdot) : R \\rightarrow R` es la función de activación, establecida por defecto como la tangente hiperbólica. Está dado como,"

#: ../modules/neural_networks_supervised.rst:245
msgid "g(z)= \\frac{e^z-e^{-z}}{e^z+e^{-z}}\n\n"
msgstr "g(z)= \\frac{e^z-e^{-z}}{e^z+e^{-z}}\n\n"

#: ../modules/neural_networks_supervised.rst:248
msgid "For binary classification, :math:`f(x)` passes through the logistic function :math:`g(z)=1/(1+e^{-z})` to obtain output values between zero and one. A threshold, set to 0.5, would assign samples of outputs larger or equal 0.5 to the positive class, and the rest to the negative class."
msgstr "Para la clasificación binaria, :math:`f(x)` pasa por la función logística :math:`g(z)=1/(1+e^{-z})` para obtener valores de salida entre cero y uno. Un umbral, fijado en 0,5, asignaría muestras de salida mayores o iguales 0,5 a la clase positiva, y el resto a la clase negativa."

#: ../modules/neural_networks_supervised.rst:253
msgid "If there are more than two classes, :math:`f(x)` itself would be a vector of size (n_classes,). Instead of passing through logistic function, it passes through the softmax function, which is written as,"
msgstr "Si hay más de dos clases, :math:`f(x)` sería un vector de tamaño (n_classes,). En lugar de pasar por la función logística, pasa por la función softmax, que se escribe como,"

#: ../modules/neural_networks_supervised.rst:257
msgid "\\text{softmax}(z)_i = \\frac{\\exp(z_i)}{\\sum_{l=1}^k\\exp(z_l)}\n\n"
msgstr "\\text{softmax}(z)_i = \\frac{\\exp(z_i)}{\\sum_{l=1}^k\\exp(z_l)}\n\n"

#: ../modules/neural_networks_supervised.rst:260
msgid "where :math:`z_i` represents the :math:`i` th element of the input to softmax, which corresponds to class :math:`i`, and :math:`K` is the number of classes. The result is a vector containing the probabilities that sample :math:`x` belong to each class. The output is the class with the highest probability."
msgstr "donde :math:`z_i` representa el :math:`i` ésimo elemento de la entrada a softmax, que corresponde a la clase :math:`i`, y :math:`K` es el número de clases. El resultado es un vector que contiene las probabilidades de que la muestra :math:`x` pertenece a cada clase. La salida es la clase con la mayor probabilidad."

#: ../modules/neural_networks_supervised.rst:265
msgid "In regression, the output remains as :math:`f(x)`; therefore, output activation function is just the identity function."
msgstr "En regresión, la salida permanece como :math:`f(x)`; por lo tanto, la función de activación de salida es solo la función identidad."

#: ../modules/neural_networks_supervised.rst:268
msgid "MLP uses different loss functions depending on the problem type. The loss function for classification is Cross-Entropy, which in binary case is given as,"
msgstr "El MLP utiliza diferentes funciones de pérdida dependiendo del tipo de problema. La función de pérdida para la clasificación es la entropía cruzada (Cross-Entroped), que en el caso binario se da como,"

#: ../modules/neural_networks_supervised.rst:271
msgid "Loss(\\hat{y},y,W) = -y \\ln {\\hat{y}} - (1-y) \\ln{(1-\\hat{y})} + \\alpha ||W||_2^2"
msgstr "Loss(\\hat{y},y,W) = -y \\ln {\\hat{y}} - (1-y) \\ln{(1-\\hat{y})} + \\alpha ||W||_2^2"

#: ../modules/neural_networks_supervised.rst:275
msgid "where :math:`\\alpha ||W||_2^2` is an L2-regularization term (aka penalty) that penalizes complex models; and :math:`\\alpha > 0` is a non-negative hyperparameter that controls the magnitude of the penalty."
msgstr "donde :math:`\\alpha ||W||_2^2` es un término de regularización L2 (también conocido como penalización) que penaliza los modelos complejos; y :math:`\\alpha > 0` es un hiperparámetro no negativo que controla la magnitud de la penalización."

#: ../modules/neural_networks_supervised.rst:279
msgid "For regression, MLP uses the Square Error loss function; written as,"
msgstr "Para la regresión, el MLP utiliza la función de pérdida del Error Cuadrado; escrita como,"

#: ../modules/neural_networks_supervised.rst:281
msgid "Loss(\\hat{y},y,W) = \\frac{1}{2}||\\hat{y} - y ||_2^2 + \\frac{\\alpha}{2} ||W||_2^2"
msgstr "Loss(\\hat{y},y,W) = \\frac{1}{2}||\\hat{y} - y ||_2^2 + \\frac{\\alpha}{2} ||W||_2^2"

#: ../modules/neural_networks_supervised.rst:286
msgid "Starting from initial random weights, multi-layer perceptron (MLP) minimizes the loss function by repeatedly updating these weights. After computing the loss, a backward pass propagates it from the output layer to the previous layers, providing each weight parameter with an update value meant to decrease the loss."
msgstr "A partir de los pesos aleatorios iniciales, el perceptrón multicapa (MLP) minimiza la función de pérdida al actualizar repetidamente estos pesos. Después de calcular la pérdida, un paso hacia atrás la propaga desde la capa de salida a las capas anteriores, proporcionando cada parámetro de peso con un valor de actualización destinado a disminuir la pérdida."

#: ../modules/neural_networks_supervised.rst:292
msgid "In gradient descent, the gradient :math:`\\nabla Loss_{W}` of the loss with respect to the weights is computed and deducted from :math:`W`. More formally, this is expressed as,"
msgstr "En el descenso del gradiente, el gradiente :math:`\\nabla Loss_{W}` de la pérdida con respecto a los pesos se calcula y se deduce de :math:`W`. Más formalmente, esto se expresa como,"

#: ../modules/neural_networks_supervised.rst:296
msgid "W^{i+1} = W^i - \\epsilon \\nabla {Loss}_{W}^{i}\n\n"
msgstr "W^{i+1} = W^i - \\epsilon \\nabla {Loss}_{W}^{i}\n\n"

#: ../modules/neural_networks_supervised.rst:300
msgid "where :math:`i` is the iteration step, and :math:`\\epsilon` is the learning rate with a value larger than 0."
msgstr "donde :math:`i` es el paso de iteración, y :math:`\\epsilon` es la tasa de aprendizaje con un valor mayor que 0."

#: ../modules/neural_networks_supervised.rst:303
msgid "The algorithm stops when it reaches a preset maximum number of iterations; or when the improvement in loss is below a certain, small number."
msgstr "El algoritmo se detiene cuando alcanza un número máximo preestablecido de iteraciones; o cuando la mejora de la pérdida está por debajo de un número determinado y pequeño."

#: ../modules/neural_networks_supervised.rst:311
msgid "Tips on Practical Use"
msgstr "Consejos de Uso Práctico"

#: ../modules/neural_networks_supervised.rst:313
msgid "Multi-layer Perceptron is sensitive to feature scaling, so it is highly recommended to scale your data. For example, scale each attribute on the input vector X to [0, 1] or [-1, +1], or standardize it to have mean 0 and variance 1. Note that you must apply the *same* scaling to the test set for meaningful results. You can use :class:`StandardScaler` for standardization."
msgstr "El Perceptrón Multicapa es sensible al escalamiento de características, por lo que es altamente recomendable escalar los datos. Por ejemplo, escale cada atributo del vector de entrada X a [0, 1] o [-1, +1], o estandarizalo para que tenga una media 0 y una varianza 1. Ten en cuenta que debes aplicar el *mismo* escalamiento al conjunto de pruebas para obtener resultados significativos. Puede utilizar :class:`StandardScaler` para la estandarización."

#: ../modules/neural_networks_supervised.rst:328
msgid "An alternative and recommended approach is to use :class:`StandardScaler` in a :class:`Pipeline`"
msgstr "Un enfoque alternativo y recomendado es utilizar :class:`StandardScaler` en un :class:`Pipeline`"

#: ../modules/neural_networks_supervised.rst:331
msgid "Finding a reasonable regularization parameter :math:`\\alpha` is best done using :class:`GridSearchCV`, usually in the range ``10.0 ** -np.arange(1, 7)``."
msgstr "La mejor manera de encontrar un parámetro de regularización razonable :math:`\\alpha` es utilizar :class:`GridSearchCV`, normalmente en el rango ``10.0 ** -np.arange(1, 7)``."

#: ../modules/neural_networks_supervised.rst:335
msgid "Empirically, we observed that `L-BFGS` converges faster and with better solutions on small datasets. For relatively large datasets, however, `Adam` is very robust. It usually converges quickly and gives pretty good performance. `SGD` with momentum or nesterov's momentum, on the other hand, can perform better than those two algorithms if learning rate is correctly tuned."
msgstr "Empíricamente, observamos que `L-BFGS` converge más rápido y con mejores soluciones en conjuntos de datos pequeños. Sin embargo, para conjuntos de datos relativamente grandes, `Adam` es muy robusto. Suele converger rápidamente y ofrece un rendimiento bastante bueno. Por otro lado, `SGD` con impulso o impulso de Nesterov, puede tener un mejor rendimiento que estos dos algoritmos si la tasa de aprendizaje se ajusta correctamente."

#: ../modules/neural_networks_supervised.rst:343
msgid "More control with warm_start"
msgstr "Más control con warm_start"

#: ../modules/neural_networks_supervised.rst:344
msgid "If you want more control over stopping criteria or learning rate in SGD, or want to do additional monitoring, using ``warm_start=True`` and ``max_iter=1`` and iterating yourself can be helpful::"
msgstr "Si quieres tener más control sobre los criterios de parada o la tasa de aprendizaje en SGD, o quieres hacer una supervisión adicional, utiliza ``warm_start=True`` y ``max_iter=1`` e iterar tú mismo puede ser útil::"

#: ../modules/neural_networks_supervised.rst:358
msgid "`\"Learning representations by back-propagating errors.\" <https://www.iro.umontreal.ca/~pift6266/A06/refs/backprop_old.pdf>`_ Rumelhart, David E., Geoffrey E. Hinton, and Ronald J. Williams."
msgstr "`\"Learning representations by back-propagating errors.\" <https://www.iro.umontreal.ca/~pift6266/A06/refs/backprop_old.pdf>`_ Rumelhart, David E., Geoffrey E. Hinton, and Ronald J. Williams."

#: ../modules/neural_networks_supervised.rst:362
msgid "`\"Stochastic Gradient Descent\" <https://leon.bottou.org/projects/sgd>`_ L. Bottou - Website, 2010."
msgstr "`\"Stochastic Gradient Descent\" <https://leon.bottou.org/projects/sgd>`_ L. Bottou - Website, 2010."

#: ../modules/neural_networks_supervised.rst:364
msgid "`\"Backpropagation\" <http://ufldl.stanford.edu/wiki/index.php/Backpropagation_Algorithm>`_ Andrew Ng, Jiquan Ngiam, Chuan Yu Foo, Yifan Mai, Caroline Suen - Website, 2011."
msgstr "`\"Backpropagation\" <http://ufldl.stanford.edu/wiki/index.php/Backpropagation_Algorithm>`_ Andrew Ng, Jiquan Ngiam, Chuan Yu Foo, Yifan Mai, Caroline Suen - Website, 2011."

#: ../modules/neural_networks_supervised.rst:367
msgid "`\"Efficient BackProp\" <http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf>`_ Y. LeCun, L. Bottou, G. Orr, K. Müller - In Neural Networks: Tricks of the Trade 1998."
msgstr "`\"Efficient BackProp\" <http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf>`_ Y. LeCun, L. Bottou, G. Orr, K. Müller - In Neural Networks: Tricks of the Trade 1998."

#: ../modules/neural_networks_supervised.rst:371
msgid "`\"Adam: A method for stochastic optimization.\" <https://arxiv.org/pdf/1412.6980v8.pdf>`_ Kingma, Diederik, and Jimmy Ba. arXiv preprint arXiv:1412.6980 (2014)."
msgstr "`\"Adam: A method for stochastic optimization.\" <https://arxiv.org/pdf/1412.6980v8.pdf>`_ Kingma, Diederik, and Jimmy Ba. arXiv preprint arXiv:1412.6980 (2014)."

