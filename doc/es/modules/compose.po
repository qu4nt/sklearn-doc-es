msgid ""
msgstr ""
"Project-Id-Version: scikit-learn\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 11:24-0400\n"
"PO-Revision-Date: 2021-04-15 04:38\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: scikit-learn\n"
"X-Crowdin-Project-ID: 450526\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /main/doc/en/modules/compose.po\n"
"X-Crowdin-File-ID: 4802\n"
"Language: es_ES\n"

#: ../modules/compose.rst:6
msgid "Pipelines and composite estimators"
msgstr ""

#: ../modules/compose.rst:8
msgid "Transformers are usually combined with classifiers, regressors or other estimators to build a composite estimator.  The most common tool is a :ref:`Pipeline <pipeline>`. Pipeline is often used in combination with :ref:`FeatureUnion <feature_union>` which concatenates the output of transformers into a composite feature space.  :ref:`TransformedTargetRegressor <transformed_target_regressor>` deals with transforming the :term:`target` (i.e. log-transform :term:`y`). In contrast, Pipelines only transform the observed data (:term:`X`)."
msgstr ""

#: ../modules/compose.rst:20
msgid "Pipeline: chaining estimators"
msgstr ""

#: ../modules/compose.rst:24
msgid ":class:`Pipeline` can be used to chain multiple estimators into one. This is useful as there is often a fixed sequence of steps in processing the data, for example feature selection, normalization and classification. :class:`Pipeline` serves multiple purposes here:"
msgstr ""

#: ../modules/compose.rst:30
msgid "Convenience and encapsulation"
msgstr ""

#: ../modules/compose.rst:30
msgid "You only have to call :term:`fit` and :term:`predict` once on your data to fit a whole sequence of estimators."
msgstr ""

#: ../modules/compose.rst:33
msgid "Joint parameter selection"
msgstr ""

#: ../modules/compose.rst:33
msgid "You can :ref:`grid search <grid_search>` over parameters of all estimators in the pipeline at once."
msgstr ""

#: ../modules/compose.rst:38
msgid "Safety"
msgstr ""

#: ../modules/compose.rst:36
msgid "Pipelines help avoid leaking statistics from your test data into the trained model in cross-validation, by ensuring that the same samples are used to train the transformers and predictors."
msgstr ""

#: ../modules/compose.rst:40
msgid "All estimators in a pipeline, except the last one, must be transformers (i.e. must have a :term:`transform` method). The last estimator may be any type (transformer, classifier, etc.)."
msgstr ""

#: ../modules/compose.rst:46 ../modules/compose.rst:349
msgid "Usage"
msgstr ""

#: ../modules/compose.rst:49
msgid "Construction"
msgstr ""

#: ../modules/compose.rst:51
msgid "The :class:`Pipeline` is built using a list of ``(key, value)`` pairs, where the ``key`` is a string containing the name you want to give this step and ``value`` is an estimator object::"
msgstr ""

#: ../modules/compose.rst:63
msgid "The utility function :func:`make_pipeline` is a shorthand for constructing pipelines; it takes a variable number of estimators and returns a pipeline, filling in the names automatically::"
msgstr ""

#: ../modules/compose.rst:75
msgid "Accessing steps"
msgstr ""

#: ../modules/compose.rst:77
msgid "The estimators of a pipeline are stored as a list in the ``steps`` attribute, but can be accessed by index or name by indexing (with ``[idx]``) the Pipeline::"
msgstr ""

#: ../modules/compose.rst:88
msgid "Pipeline's `named_steps` attribute allows accessing steps by name with tab completion in interactive environments::"
msgstr ""

#: ../modules/compose.rst:94
msgid "A sub-pipeline can also be extracted using the slicing notation commonly used for Python Sequences such as lists or strings (although only a step of 1 is permitted). This is convenient for performing only some of the transformations (or their inverse):"
msgstr ""

#: ../modules/compose.rst:108
msgid "Nested parameters"
msgstr ""

#: ../modules/compose.rst:110
msgid "Parameters of the estimators in the pipeline can be accessed using the ``<estimator>__<parameter>`` syntax::"
msgstr ""

#: ../modules/compose.rst:116
msgid "This is particularly important for doing grid searches::"
msgstr ""

#: ../modules/compose.rst:123
msgid "Individual steps may also be replaced as parameters, and non-final steps may be ignored by setting them to ``'passthrough'``::"
msgstr ""

#: ../modules/compose.rst:132
msgid "The estimators of the pipeline can be retrieved by index:"
msgstr ""

#: ../modules/compose.rst:137
msgid "or by name::"
msgstr ""

#: ../modules/compose.rst:144
msgid ":ref:`sphx_glr_auto_examples_feature_selection_plot_feature_selection_pipeline.py`"
msgstr ""

#: ../modules/compose.rst:145
msgid ":ref:`sphx_glr_auto_examples_model_selection_grid_search_text_feature_extraction.py`"
msgstr ""

#: ../modules/compose.rst:146
msgid ":ref:`sphx_glr_auto_examples_compose_plot_digits_pipe.py`"
msgstr ""

#: ../modules/compose.rst:147
msgid ":ref:`sphx_glr_auto_examples_miscellaneous_plot_kernel_approximation.py`"
msgstr ""

#: ../modules/compose.rst:148
msgid ":ref:`sphx_glr_auto_examples_svm_plot_svm_anova.py`"
msgstr ""

#: ../modules/compose.rst:149 ../modules/compose.rst:240
msgid ":ref:`sphx_glr_auto_examples_compose_plot_compare_reduction.py`"
msgstr ""

#: ../modules/compose.rst:153
msgid ":ref:`composite_grid_search`"
msgstr ""

#: ../modules/compose.rst:157
msgid "Notes"
msgstr ""

#: ../modules/compose.rst:159
msgid "Calling ``fit`` on the pipeline is the same as calling ``fit`` on each estimator in turn, ``transform`` the input and pass it on to the next step. The pipeline has all the methods that the last estimator in the pipeline has, i.e. if the last estimator is a classifier, the :class:`Pipeline` can be used as a classifier. If the last estimator is a transformer, again, so is the pipeline."
msgstr ""

#: ../modules/compose.rst:169
msgid "Caching transformers: avoid repeated computation"
msgstr ""

#: ../modules/compose.rst:173
msgid "Fitting transformers may be computationally expensive. With its ``memory`` parameter set, :class:`Pipeline` will cache each transformer after calling ``fit``. This feature is used to avoid computing the fit transformers within a pipeline if the parameters and input data are identical. A typical example is the case of a grid search in which the transformers can be fitted only once and reused for each configuration."
msgstr ""

#: ../modules/compose.rst:181
msgid "The parameter ``memory`` is needed in order to cache the transformers. ``memory`` can be either a string containing the directory where to cache the transformers or a `joblib.Memory <https://pythonhosted.org/joblib/memory.html>`_ object::"
msgstr ""

#: ../modules/compose.rst:200
msgid "**Side effect of caching transformers**"
msgstr ""

#: ../modules/compose.rst:202
msgid "Using a :class:`Pipeline` without cache enabled, it is possible to inspect the original instance such as::"
msgstr ""

#: ../modules/compose.rst:216
msgid "Enabling caching triggers a clone of the transformers before fitting. Therefore, the transformer instance given to the pipeline cannot be inspected directly. In following example, accessing the :class:`PCA` instance ``pca2`` will raise an ``AttributeError`` since ``pca2`` will be an unfitted transformer. Instead, use the attribute ``named_steps`` to inspect estimators within the pipeline::"
msgstr ""

#: ../modules/compose.rst:245
msgid "Transforming target in regression"
msgstr ""

#: ../modules/compose.rst:247
msgid ":class:`~sklearn.compose.TransformedTargetRegressor` transforms the targets ``y`` before fitting a regression model. The predictions are mapped back to the original space via an inverse transform. It takes as an argument the regressor that will be used for prediction, and the transformer that will be applied to the target variable::"
msgstr ""

#: ../modules/compose.rst:274
msgid "For simple transformations, instead of a Transformer object, a pair of functions can be passed, defining the transformation and its inverse mapping::"
msgstr ""

#: ../modules/compose.rst:282
msgid "Subsequently, the object is created as::"
msgstr ""

#: ../modules/compose.rst:292
msgid "By default, the provided functions are checked at each fit to be the inverse of each other. However, it is possible to bypass this checking by setting ``check_inverse`` to ``False``::"
msgstr ""

#: ../modules/compose.rst:309
msgid "The transformation can be triggered by setting either ``transformer`` or the pair of functions ``func`` and ``inverse_func``. However, setting both options will raise an error."
msgstr ""

#: ../modules/compose.rst:315
msgid ":ref:`sphx_glr_auto_examples_compose_plot_transformed_target.py`"
msgstr ""

#: ../modules/compose.rst:321
msgid "FeatureUnion: composite feature spaces"
msgstr ""

#: ../modules/compose.rst:325
msgid ":class:`FeatureUnion` combines several transformer objects into a new transformer that combines their output. A :class:`FeatureUnion` takes a list of transformer objects. During fitting, each of these is fit to the data independently. The transformers are applied in parallel, and the feature matrices they output are concatenated side-by-side into a larger matrix."
msgstr ""

#: ../modules/compose.rst:332
msgid "When you want to apply different transformations to each field of the data, see the related class :class:`~sklearn.compose.ColumnTransformer` (see :ref:`user guide <column_transformer>`)."
msgstr ""

#: ../modules/compose.rst:336
msgid ":class:`FeatureUnion` serves the same purposes as :class:`Pipeline` - convenience and joint parameter estimation and validation."
msgstr ""

#: ../modules/compose.rst:339
msgid ":class:`FeatureUnion` and :class:`Pipeline` can be combined to create complex models."
msgstr ""

#: ../modules/compose.rst:342
msgid "(A :class:`FeatureUnion` has no way of checking whether two transformers might produce identical features. It only produces a union when the feature sets are disjoint, and making sure they are is the caller's responsibility.)"
msgstr ""

#: ../modules/compose.rst:351
msgid "A :class:`FeatureUnion` is built using a list of ``(key, value)`` pairs, where the ``key`` is the name you want to give to a given transformation (an arbitrary string; it only serves as an identifier) and ``value`` is an estimator object::"
msgstr ""

#: ../modules/compose.rst:366
msgid "Like pipelines, feature unions have a shorthand constructor called :func:`make_union` that does not require explicit naming of the components."
msgstr ""

#: ../modules/compose.rst:370
msgid "Like ``Pipeline``, individual steps may be replaced using ``set_params``, and ignored by setting to ``'drop'``::"
msgstr ""

#: ../modules/compose.rst:379
msgid ":ref:`sphx_glr_auto_examples_compose_plot_feature_union.py`"
msgstr ""

#: ../modules/compose.rst:385
msgid "ColumnTransformer for heterogeneous data"
msgstr ""

#: ../modules/compose.rst:387
msgid "Many datasets contain features of different types, say text, floats, and dates, where each type of feature requires separate preprocessing or feature extraction steps.  Often it is easiest to preprocess data before applying scikit-learn methods, for example using `pandas <https://pandas.pydata.org/>`__. Processing your data before passing it to scikit-learn might be problematic for one of the following reasons:"
msgstr ""

#: ../modules/compose.rst:394
msgid "Incorporating statistics from test data into the preprocessors makes cross-validation scores unreliable (known as *data leakage*), for example in the case of scalers or imputing missing values."
msgstr ""

#: ../modules/compose.rst:397
msgid "You may want to include the parameters of the preprocessors in a :ref:`parameter search <grid_search>`."
msgstr ""

#: ../modules/compose.rst:400
msgid "The :class:`~sklearn.compose.ColumnTransformer` helps performing different transformations for different columns of the data, within a :class:`~sklearn.pipeline.Pipeline` that is safe from data leakage and that can be parametrized. :class:`~sklearn.compose.ColumnTransformer` works on arrays, sparse matrices, and `pandas DataFrames <https://pandas.pydata.org/pandas-docs/stable/>`__."
msgstr ""

#: ../modules/compose.rst:407
msgid "To each column, a different transformation can be applied, such as preprocessing or a specific feature extraction method::"
msgstr ""

#: ../modules/compose.rst:418
msgid "For this data, we might want to encode the ``'city'`` column as a categorical variable using :class:`~sklearn.preprocessing.OneHotEncoder` but apply a :class:`~sklearn.feature_extraction.text.CountVectorizer` to the ``'title'`` column. As we might use multiple feature extraction methods on the same column, we give each transformer a unique name, say ``'city_category'`` and ``'title_bow'``. By default, the remaining rating columns are ignored (``remainder='drop'``)::"
msgstr ""

#: ../modules/compose.rst:451
msgid "In the above example, the :class:`~sklearn.feature_extraction.text.CountVectorizer` expects a 1D array as input and therefore the columns were specified as a string (``'title'``). However, :class:`~sklearn.preprocessing.OneHotEncoder` as most of other transformers expects 2D data, therefore in that case you need to specify the column as a list of strings (``['city']``)."
msgstr ""

#: ../modules/compose.rst:458
msgid "Apart from a scalar or a single item list, the column selection can be specified as a list of multiple items, an integer array, a slice, a boolean mask, or with a :func:`~sklearn.compose.make_column_selector`. The :func:`~sklearn.compose.make_column_selector` is used to select columns based on data type or column name::"
msgstr ""

#: ../modules/compose.rst:478
msgid "Strings can reference columns if the input is a DataFrame, integers are always interpreted as the positional columns."
msgstr ""

#: ../modules/compose.rst:481
msgid "We can keep the remaining rating columns by setting ``remainder='passthrough'``. The values are appended to the end of the transformation::"
msgstr ""

#: ../modules/compose.rst:496
msgid "The ``remainder`` parameter can be set to an estimator to transform the remaining rating columns. The transformed values are appended to the end of the transformation::"
msgstr ""

#: ../modules/compose.rst:514
msgid "The :func:`~sklearn.compose.make_column_transformer` function is available to more easily create a :class:`~sklearn.compose.ColumnTransformer` object. Specifically, the names will be given automatically. The equivalent for the above example would be::"
msgstr ""

#: ../modules/compose.rst:533
msgid "Visualizing Composite Estimators"
msgstr ""

#: ../modules/compose.rst:535
msgid "Estimators can be displayed with a HTML representation when shown in a jupyter notebook. This can be useful to diagnose or visualize a Pipeline with many estimators. This visualization is activated by setting the `display` option in :func:`~sklearn.set_config`::"
msgstr ""

#: ../modules/compose.rst:545
msgid "An example of the HTML output can be seen in the **HTML representation of Pipeline** section of :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py`. As an alternative, the HTML can be written to a file using :func:`~sklearn.utils.estimator_html_repr`::"
msgstr ""

#: ../modules/compose.rst:557
msgid ":ref:`sphx_glr_auto_examples_compose_plot_column_transformer.py`"
msgstr ""

#: ../modules/compose.rst:558
msgid ":ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py`"
msgstr ""

