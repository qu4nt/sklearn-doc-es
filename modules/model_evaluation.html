

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>3.3. Métricas y puntuación: cuantificar la calidad de las predicciones &mdash; documentación de scikit-learn - 0.24.2</title>
  
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/model_evaluation.html" />

  
  <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  <link rel="stylesheet" href="../_static/css/vendor/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
<script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
<script src="../_static/jquery.js"></script> 
</head>
<body>
<nav id="navbar" class="sk-docs-navbar navbar navbar-expand-md navbar-light bg-light py-0">
  <div class="container-fluid sk-docs-container px-0">
      <a class="navbar-brand py-0" href="../index.html">
        <img
          class="sk-brand-img"
          src="../_static/scikit-learn-logo-small.png"
          alt="logo"/>
      </a>
    <button
      id="sk-navbar-toggler"
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="sk-navbar-collapse collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../install.html">Instalación</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../user_guide.html">Manual de Usuario</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="classes.html">API</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../auto_examples/index.html">Ejemplos</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../getting_started.html">¿Cómo empezar?</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../tutorial/index.html">Tutorial</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../whats_new/v0.24.html">Novedades</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../glossary.html">Glosario</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../developers/index.html">Desarrollo</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../faq.html">FAQ</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../support.html">Soporte</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../related_projects.html">Paquetes relacionados</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../roadmap.html">Hoja de ruta</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../about.html">Sobre nosotros</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://github.com/scikit-learn/scikit-learn">GitHub</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://scikit-learn.org/dev/versions.html">Otras versiones y descargas</a>
        </li>
        <li class="nav-item dropdown nav-more-item-dropdown">
          <a class="sk-nav-link nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Más</a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
              <a class="sk-nav-dropdown-item dropdown-item" href="../getting_started.html">¿Cómo empezar?</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../tutorial/index.html">Tutorial</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../whats_new/v0.24.html">Novedades</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../glossary.html">Glosario</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../developers/index.html">Desarrollo</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../faq.html">FAQ</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../support.html">Soporte</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../related_projects.html">Paquetes relacionados</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../roadmap.html">Hoja de ruta</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../about.html">Sobre nosotros</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://github.com/scikit-learn/scikit-learn">GitHub</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://scikit-learn.org/dev/versions.html">Otras versiones y descargas</a>
          </div>
        </li>
      </ul>
      <div id="searchbox" role="search">
          <div class="searchformwrapper">
          <form class="search" action="../search.html" method="get">
            <input class="sk-search-text-input" type="text" name="q" aria-labelledby="searchlabel" />
            <input class="sk-search-text-btn" type="submit" value="Ir a" />
          </form>
          </div>
      </div>
    </div>
  </div>
</nav>
<div class="d-flex" id="sk-doc-wrapper">
    <input type="checkbox" name="sk-toggle-checkbox" id="sk-toggle-checkbox">
    <label id="sk-sidemenu-toggle" class="sk-btn-toggle-toc btn sk-btn-primary" for="sk-toggle-checkbox">Alternar menú</label>
    <div id="sk-sidebar-wrapper" class="border-right">
      <div class="sk-sidebar-toc-wrapper">
        <div class="sk-sidebar-toc-logo">
          <a href="../index.html">
            <img
              class="sk-brand-img"
              src="../_static/scikit-learn-logo-small.png"
              alt="logo"/>
          </a>
        </div>
        <div class="btn-group w-100 mb-2" role="group" aria-label="rellinks">
            <a href="grid_search.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="3.2. Ajustar los hiperparámetros de un estimador">Prev</a><a href="../model_selection.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="3. Selección y evaluación del modelo">Arriba</a>
            <a href="learning_curve.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="3.4. Curvas de validación: dibujar las puntuaciones para evaluar los modelos">Sig.</a>
        </div>
        <div class="alert alert-danger p-1 mb-2" role="alert">
          <p class="text-center mb-0">
          <strong>scikit-learn 0.24.2</strong><br/>
          <a href="http://scikit-learn.org/dev/versions.html">Otras versiones</a>
          </p>
        </div>
        <div class="alert alert-warning p-1 mb-2" role="alert">
          <p class="text-center mb-0">
            Por favor <a class="font-weight-bold" href="../about.html#citing-scikit-learn"><string>cítanos</string></a> si usas el software.
          </p>
        </div>
            <div class="sk-sidebar-toc">
              <ul>
<li><a class="reference internal" href="#">3.3. Métricas y puntuación: cuantificar la calidad de las predicciones</a><ul>
<li><a class="reference internal" href="#the-scoring-parameter-defining-model-evaluation-rules">3.3.1. El parámetro <code class="docutils literal notranslate"><span class="pre">scoring</span></code>: definir las reglas de evaluación del modelo</a><ul>
<li><a class="reference internal" href="#common-cases-predefined-values">3.3.1.1. Casos comunes: valores predefinidos</a></li>
<li><a class="reference internal" href="#defining-your-scoring-strategy-from-metric-functions">3.3.1.2. Definir tu estrategia de puntuación a partir de funciones métricas</a></li>
<li><a class="reference internal" href="#implementing-your-own-scoring-object">3.3.1.3. Implementando tu propio objeto de puntuación</a></li>
<li><a class="reference internal" href="#using-multiple-metric-evaluation">3.3.1.4. Utilizando evaluación métrica múltiple</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classification-metrics">3.3.2. Métricas de clasificación</a><ul>
<li><a class="reference internal" href="#from-binary-to-multiclass-and-multilabel">3.3.2.1. De binario a multiclase y multietiqueta</a></li>
<li><a class="reference internal" href="#accuracy-score">3.3.2.2. Puntuación de precisión</a></li>
<li><a class="reference internal" href="#top-k-accuracy-score">3.3.2.3. Puntuación de precisión de Top-k</a></li>
<li><a class="reference internal" href="#balanced-accuracy-score">3.3.2.4. Puntuación de precisión balanceada</a></li>
<li><a class="reference internal" href="#cohen-s-kappa">3.3.2.5. Kappa de Cohen</a></li>
<li><a class="reference internal" href="#confusion-matrix">3.3.2.6. Matriz de confusión</a></li>
<li><a class="reference internal" href="#classification-report">3.3.2.7. Reporte de clasificación</a></li>
<li><a class="reference internal" href="#hamming-loss">3.3.2.8. Pérdida de Hamming</a></li>
<li><a class="reference internal" href="#precision-recall-and-f-measures">3.3.2.9. Precisión, recuperación y medidas F</a><ul>
<li><a class="reference internal" href="#binary-classification">3.3.2.9.1. Clasificación binaria</a></li>
<li><a class="reference internal" href="#multiclass-and-multilabel-classification">3.3.2.9.2. Clasificación multiclase y multietiqueta</a></li>
</ul>
</li>
<li><a class="reference internal" href="#jaccard-similarity-coefficient-score">3.3.2.10. Puntuación del coeficiente de similitud de Jaccard</a></li>
<li><a class="reference internal" href="#hinge-loss">3.3.2.11. Pérdida de la bisagra</a></li>
<li><a class="reference internal" href="#log-loss">3.3.2.12. Pérdida logística</a></li>
<li><a class="reference internal" href="#matthews-correlation-coefficient">3.3.2.13. Coeficiente de correlación Matthews</a></li>
<li><a class="reference internal" href="#multi-label-confusion-matrix">3.3.2.14. Matriz de confusión multietiqueta</a></li>
<li><a class="reference internal" href="#receiver-operating-characteristic-roc">3.3.2.15. Receptor operativo característico (ROC)</a><ul>
<li><a class="reference internal" href="#binary-case">3.3.2.15.1. Caso binario</a></li>
<li><a class="reference internal" href="#multi-class-case">3.3.2.15.2. Caso de clases múltiples</a></li>
<li><a class="reference internal" href="#multi-label-case">3.3.2.15.3. Caso multietiquetas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detection-error-tradeoff-det">3.3.2.16. Compensación de errores de detección (DET)</a></li>
<li><a class="reference internal" href="#zero-one-loss">3.3.2.17. Pérdida cero uno</a></li>
<li><a class="reference internal" href="#brier-score-loss">3.3.2.18. Pérdida de puntuación en Brier</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multilabel-ranking-metrics">3.3.3. Métricas de clasificación multietiqueta</a><ul>
<li><a class="reference internal" href="#coverage-error">3.3.3.1. Error de cobertura</a></li>
<li><a class="reference internal" href="#label-ranking-average-precision">3.3.3.2. Precisión promedio de clasificación de etiquetas</a></li>
<li><a class="reference internal" href="#ranking-loss">3.3.3.3. Pérdida de clasificación</a></li>
<li><a class="reference internal" href="#normalized-discounted-cumulative-gain">3.3.3.4. Ganancia acumulada descontada normalizada</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regression-metrics">3.3.4. Métricas de Regresión</a><ul>
<li><a class="reference internal" href="#explained-variance-score">3.3.4.1. Puntuación de varianza explicada</a></li>
<li><a class="reference internal" href="#max-error">3.3.4.2. Error máximo</a></li>
<li><a class="reference internal" href="#mean-absolute-error">3.3.4.3. Error medio absoluto</a></li>
<li><a class="reference internal" href="#mean-squared-error">3.3.4.4. Error cuadrático medio</a></li>
<li><a class="reference internal" href="#mean-squared-logarithmic-error">3.3.4.5. Error logarítmico medio cuadrático</a></li>
<li><a class="reference internal" href="#mean-absolute-percentage-error">3.3.4.6. Error porcentual medio absoluto</a></li>
<li><a class="reference internal" href="#median-absolute-error">3.3.4.7. Mediana del error absoluto</a></li>
<li><a class="reference internal" href="#r2-score-the-coefficient-of-determination">3.3.4.8. La puntuación R², el coeficiente de determinación</a></li>
<li><a class="reference internal" href="#mean-poisson-gamma-and-tweedie-deviances">3.3.4.9. Desviaciones medias de Poisson, Gamma y Tweedie</a></li>
</ul>
</li>
<li><a class="reference internal" href="#clustering-metrics">3.3.5. Métricas de agrupamiento</a></li>
<li><a class="reference internal" href="#dummy-estimators">3.3.6. Estimadores de prueba</a></li>
</ul>
</li>
</ul>

            </div>
      </div>
    </div>
    <div id="sk-page-content-wrapper">
      <div class="sk-page-content container-fluid body px-md-3" role="main">
        
  <section id="metrics-and-scoring-quantifying-the-quality-of-predictions">
<span id="model-evaluation"></span><h1><span class="section-number">3.3. </span>Métricas y puntuación: cuantificar la calidad de las predicciones<a class="headerlink" href="#metrics-and-scoring-quantifying-the-quality-of-predictions" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Hay 3 APIs diferentes para evaluar la calidad de las predicciones de un modelo:</p>
<ul class="simple">
<li><p><strong>Método de puntuación de los estimadores</strong>: Los estimadores tienen un método de <code class="docutils literal notranslate"><span class="pre">score</span></code> que proporciona un criterio de evaluación predeterminada para el problema que están diseñados para resolver. Esto no se discute en esta página, sino en la documentación de cada estimador.</p></li>
<li><p><strong>Parámetro de puntuación</strong>: Las herramientas de evaluación de modelos que utilizan <a class="reference internal" href="cross_validation.html#cross-validation"><span class="std std-ref">validación cruzada</span></a> (como <a class="reference internal" href="generated/sklearn.model_selection.cross_val_score.html#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_selection.cross_val_score</span></code></a> y <a class="reference internal" href="generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">model_selection.GridSearchCV</span></code></a>) dependen de una estrategia interna de <em>puntuación</em>. Esto se discute en la sección <a class="reference internal" href="#scoring-parameter"><span class="std std-ref">El parámetro scoring: definir las reglas de evaluación del modelo</span></a>.</p></li>
<li><p><strong>Funciones métricas</strong>: El módulo <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics</span></code></a> implementa funciones que evalúan el error de predicción con fines específicos. Estas métricas se detallan en las secciones de <a class="reference internal" href="#classification-metrics"><span class="std std-ref">Métricas de clasificación</span></a>, <a class="reference internal" href="#multilabel-ranking-metrics"><span class="std std-ref">Métricas de clasificación multietiqueta</span></a>, <a class="reference internal" href="#regression-metrics"><span class="std std-ref">Métricas de Regresión</span></a> y <a class="reference internal" href="#clustering-metrics"><span class="std std-ref">Métricas de agrupamiento</span></a>.</p></li>
</ul>
<p>Finalmente, <a class="reference internal" href="#dummy-estimators"><span class="std std-ref">Estimadores de prueba</span></a> son útiles para obtener un valor de referencia de esas métricas para predicciones aleatorias.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Para las métricas «por pares», entre <em>muestras</em> y no estimadores o predicciones, ver la sección <a class="reference internal" href="metrics.html#metrics"><span class="std std-ref">Métricas por pares, afinidades y núcleos</span></a>.</p>
</div>
<section id="the-scoring-parameter-defining-model-evaluation-rules">
<span id="scoring-parameter"></span><h2><span class="section-number">3.3.1. </span>El parámetro <code class="docutils literal notranslate"><span class="pre">scoring</span></code>: definir las reglas de evaluación del modelo<a class="headerlink" href="#the-scoring-parameter-defining-model-evaluation-rules" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La selección y evaluación de modelos mediante herramientas, como <a class="reference internal" href="generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">model_selection.GridSearchCV</span></code></a> y <a class="reference internal" href="generated/sklearn.model_selection.cross_val_score.html#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_selection.cross_val_score</span></code></a>, toman un parámetro <code class="docutils literal notranslate"><span class="pre">scoring</span></code> que controla qué métrica aplican a los estimadores evaluados.</p>
<section id="common-cases-predefined-values">
<h3><span class="section-number">3.3.1.1. </span>Casos comunes: valores predefinidos<a class="headerlink" href="#common-cases-predefined-values" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para los casos de uso más comunes, puede designar un objeto puntuador con el parámetro <code class="docutils literal notranslate"><span class="pre">puntuación</span></code>; la tabla siguiente muestra todos los valores posibles. Todos los objetos calificadores siguen la convención de que <strong>los valores de retorno más altos son mejores que los valores de retorno más bajos</strong>.  Así, las métricas que miden la distancia entre el modelo y los datos, como <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_squared_error</span></code></a>, están disponibles como neg_mean_squared_error que devuelve el valor negado de la métrica.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 40%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Puntuación</p></th>
<th class="head"><p>Función</p></th>
<th class="head"><p>Comentario</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Clasificación</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“accuracy”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.accuracy_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“balanced_accuracy”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score.html#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.balanced_accuracy_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“top_k_accuracy”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.top_k_accuracy_score.html#sklearn.metrics.top_k_accuracy_score" title="sklearn.metrics.top_k_accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.top_k_accuracy_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“average_precision”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.average_precision_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“neg_brier_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.brier_score_loss.html#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.brier_score_loss</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“f1”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.f1_score</span></code></a></p></td>
<td><p>para objetivos binarios</p></td>
</tr>
<tr class="row-odd"><td><p>“f1_micro”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.f1_score</span></code></a></p></td>
<td><p>micro-promedio</p></td>
</tr>
<tr class="row-even"><td><p>“f1_macro”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.f1_score</span></code></a></p></td>
<td><p>micro-promedio</p></td>
</tr>
<tr class="row-odd"><td><p>“f1_weighted”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.f1_score</span></code></a></p></td>
<td><p>promedio ponderado</p></td>
</tr>
<tr class="row-even"><td><p>“f1_samples”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.f1_score</span></code></a></p></td>
<td><p>por muestra multietiqueta</p></td>
</tr>
<tr class="row-odd"><td><p>“neg_log_loss”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.log_loss</span></code></a></p></td>
<td><p>requiere soporte <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code></p></td>
</tr>
<tr class="row-even"><td><p>“precisión”, etc.</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.precision_score</span></code></a></p></td>
<td><p>los sufijos se aplican como con “f1”</p></td>
</tr>
<tr class="row-odd"><td><p>“recuperación” etc.</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.recall_score</span></code></a></p></td>
<td><p>los sufijos se aplican como con “f1”</p></td>
</tr>
<tr class="row-even"><td><p>“jaccard” etc.</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.jaccard_score</span></code></a></p></td>
<td><p>los sufijos se aplican como con “f1”</p></td>
</tr>
<tr class="row-odd"><td><p>“roc_auc”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.roc_auc_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“roc_auc_ovr”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.roc_auc_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“roc_auc_ovo”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.roc_auc_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“roc_auc_ovr_weighted”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.roc_auc_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“roc_auc_ovo_weighted”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.roc_auc_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>Análisis de conglomerados</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“adjusted_mutual_info_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.adjusted_mutual_info_score.html#sklearn.metrics.adjusted_mutual_info_score" title="sklearn.metrics.adjusted_mutual_info_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.adjusted_mutual_info_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“adjusted_rand_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.adjusted_rand_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“completeness_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.completeness_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“fowlkes_mallows_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.fowlkes_mallows_score.html#sklearn.metrics.fowlkes_mallows_score" title="sklearn.metrics.fowlkes_mallows_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.fowlkes_mallows_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“homogeneity_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.homogeneity_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“mutual_info_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mutual_info_score.html#sklearn.metrics.mutual_info_score" title="sklearn.metrics.mutual_info_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mutual_info_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“normalized_mutual_info_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.normalized_mutual_info_score.html#sklearn.metrics.normalized_mutual_info_score" title="sklearn.metrics.normalized_mutual_info_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.normalized_mutual_info_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“rand_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.rand_score.html#sklearn.metrics.rand_score" title="sklearn.metrics.rand_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.rand_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“v_measure_score”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.v_measure_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>Regresión</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“explained_variance”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.explained_variance_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“max_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.max_error</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“neg_mean_absolute_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_absolute_error</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“neg_mean_squared_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_squared_error</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“neg_root_mean_squared_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_squared_error</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“neg_mean_squared_log_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error.html#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_squared_log_error</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“neg_median_absolute_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.median_absolute_error</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“r2”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.r2_score</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“neg_mean_poisson_deviance”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_poisson_deviance.html#sklearn.metrics.mean_poisson_deviance" title="sklearn.metrics.mean_poisson_deviance"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_poisson_deviance</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>“neg_mean_gamma_deviance”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_gamma_deviance.html#sklearn.metrics.mean_gamma_deviance" title="sklearn.metrics.mean_gamma_deviance"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_gamma_deviance</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>“neg_mean_absolute_percentage_error”</p></td>
<td><p><a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.mean_absolute_percentage_error</span></code></a></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ejemplos de uso:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span><span class="p">,</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;recall_macro&#39;</span><span class="p">)</span>
<span class="go">array([0.96..., 0.96..., 0.96..., 0.93..., 1.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;wrong_choice&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ValueError</span>: <span class="n">&#39;wrong_choice&#39; is not a valid scoring value. Use sorted(sklearn.metrics.SCORERS.keys()) to get valid options.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los valores listados por la excepción <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> corresponden a las funciones que miden la precisión de la predicción descritas en las siguientes secciones. Los objetos de puntuación para esas funciones se almacenan en el diccionario <code class="docutils literal notranslate"><span class="pre">sklearn.metrics.SCORERS</span></code>.</p>
</div>
</section>
<section id="defining-your-scoring-strategy-from-metric-functions">
<span id="scoring"></span><h3><span class="section-number">3.3.1.2. </span>Definir tu estrategia de puntuación a partir de funciones métricas<a class="headerlink" href="#defining-your-scoring-strategy-from-metric-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El módulo <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics</span></code></a> también expone un conjunto de funciones simples que miden un error de predicción dado basado en evidencia y predicción:</p>
<ul class="simple">
<li><p>las funciones que terminan con <code class="docutils literal notranslate"><span class="pre">_score</span></code> devuelven un valor a maximizar, cuanto más alto mejor.</p></li>
<li><p>las funciones que terminan con <code class="docutils literal notranslate"><span class="pre">_error</span></code> o <code class="docutils literal notranslate"><span class="pre">_loss</span></code> devuelven un valor a minimizar, cuanto más bajo mejor.  Cuando se convierta en un objeto anotador usando <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_scorer</span></code></a>, establece el parámetro <code class="docutils literal notranslate"><span class="pre">mayor_es_mejor</span></code> a <code class="docutils literal notranslate"><span class="pre">False</span></code> (<code class="docutils literal notranslate"><span class="pre">True</span></code> por defecto; ver la descripción del parámetro más abajo).</p></li>
</ul>
<p>Las métricas disponibles para diversas tareas de aprendizaje automático se detallan en las secciones siguientes.</p>
<p>Muchas métricas no reciben nombres para ser utilizadas como valores de <code class="docutils literal notranslate"><span class="pre">puntuación</span></code>, a veces porque requieren parámetros adicionales, como <a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">fbeta_score</span></code></a>. En estos casos, es necesario generar un objeto de puntuación apropiado.  La forma más sencilla de generar un objeto de llamada para la puntuación es utilizando <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_scorer</span></code></a>. Esta función convierte las métricas en objetos llamables que pueden utilizarse para la evaluación del modelo.</p>
<p>Un caso de uso típico es envolver una función métrica existente de la biblioteca con valores no predeterminados para sus parámetros, como el parámetro <code class="docutils literal notranslate"><span class="pre">beta</span></code> para la función <a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">fbeta_score</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">fbeta_score</span><span class="p">,</span> <span class="n">make_scorer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftwo_scorer</span> <span class="o">=</span> <span class="n">make_scorer</span><span class="p">(</span><span class="n">fbeta_score</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">LinearSVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">LinearSVC</span><span class="p">(),</span> <span class="n">param_grid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]},</span>
<span class="gp">... </span>                    <span class="n">scoring</span><span class="o">=</span><span class="n">ftwo_scorer</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>El segundo caso de uso es construir un objeto de puntuación completamente personalizado a partir de una simple función de python utilizando <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_scorer</span></code></a>, que puede tomar varios parámetros:</p>
<ul class="simple">
<li><p>la función de python que desea utilizar (<code class="docutils literal notranslate"><span class="pre">mi_pérdida_personalizada_func</span></code> en el ejemplo siguiente)</p></li>
<li><p>si la función python devuelve una puntuación (<code class="docutils literal notranslate"><span class="pre">greater_is_better=Verdadero</span></code>, por defecto) o una pérdida (<code class="docutils literal notranslate"><span class="pre">greater_is_better=Falso</span></code>).  Si se trata de una pérdida, la salida de la función python es negada por el objeto de puntuación, conforme a la convención de validación cruzada de que las puntuaciones devuelven valores más altos para los mejores modelos.</p></li>
<li><p>sólo para las métricas de clasificación: si la función python proporcionada requiere certezas de decisión continuas (<code class="docutils literal notranslate"><span class="pre">needs_threshold=True</span></code>).  El valor predeterminado es False.</p></li>
<li><p>cualquier parámetro adicional, como <code class="docutils literal notranslate"><span class="pre">beta</span></code> o <code class="docutils literal notranslate"><span class="pre">labels</span></code> en <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">f1_score</span></code></a>.</p></li>
</ul>
<p>Aquí hay un ejemplo de construcción de marcadores personalizados, y del uso del parámetro <code class="docutils literal notranslate"><span class="pre">greater_is_better</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_custom_loss_func</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># score will negate the return value of my_custom_loss_func,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># which will be np.log(2), 0.693, given the values for X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and y defined below.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">make_scorer</span><span class="p">(</span><span class="n">my_custom_loss_func</span><span class="p">,</span> <span class="n">greater_is_better</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.dummy</span> <span class="kn">import</span> <span class="n">DummyClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">DummyClassifier</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;most_frequent&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_custom_loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">0.69...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">-0.69...</span>
</pre></div>
</div>
</section>
<section id="implementing-your-own-scoring-object">
<span id="diy-scoring"></span><h3><span class="section-number">3.3.1.3. </span>Implementando tu propio objeto de puntuación<a class="headerlink" href="#implementing-your-own-scoring-object" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Puedes generar modelos de puntuación aún más flexibles construyendo tu propio objeto de puntuación desde cero, sin utilizar la fábrica <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_scorer</span></code></a>. Para que una llamada sea un puntuador, debe cumplir el protocolo especificado por las dos reglas siguientes:</p>
<ul class="simple">
<li><p>Se puede llamar con los parámetros <code class="docutils literal notranslate"><span class="pre">(estimador,</span> <span class="pre">X,</span> <span class="pre">y)</span></code>, donde <code class="docutils literal notranslate"><span class="pre">estimator</span></code> es el modelo que debe ser evaluado, <code class="docutils literal notranslate"><span class="pre">X</span></code> son los datos de validación, y <code class="docutils literal notranslate"><span class="pre">y</span></code> es el objetivo basado en evidencia para <code class="docutils literal notranslate"><span class="pre">X</span></code> (en el caso supervisado) o <code class="docutils literal notranslate"><span class="pre">None</span></code> (en el caso no supervisado).</p></li>
<li><p>Devuelve un número de punto flotante que cuantifica la calidad de la predicción del <code class="docutils literal notranslate"><span class="pre">estimator</span></code> en <code class="docutils literal notranslate"><span class="pre">X</span></code>, con referencia a <code class="docutils literal notranslate"><span class="pre">y</span></code>. De nuevo, por convención los números más altos son mejores, así que si su estimador devuelve una pérdida, ese valor debe ser negado.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong>Usando puntuaciones personalizadas en funciones donde n_jobs &gt; 1</strong></p>
<p>Aunque la definición de la función de puntuación personalizada junto con la función de llamada debería funcionar de forma inmediata con el backend de joblib por defecto (loky), importarla desde otro módulo será un enfoque más robusto y funcionará independientemente del backend de joblib.</p>
<p>Por ejemplo, para usar <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> mayor que 1 en el ejemplo de abajo, la función <code class="docutils literal notranslate"><span class="pre">custom_scoring_function</span></code> se guarda en un módulo creado por el usuario (<code class="docutils literal notranslate"><span class="pre">custom_scorer_module.py</span></code>) e importado:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">custom_scorer_module</span> <span class="kn">import</span> <span class="n">custom_scoring_function</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">X_train</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">y_train</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">scoring</span><span class="o">=</span><span class="n">make_scorer</span><span class="p">(</span><span class="n">custom_scoring_function</span><span class="p">,</span> <span class="n">greater_is_better</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
<span class="gp">... </span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> 
</pre></div>
</div>
</div>
</section>
<section id="using-multiple-metric-evaluation">
<span id="multimetric-scoring"></span><h3><span class="section-number">3.3.1.4. </span>Utilizando evaluación métrica múltiple<a class="headerlink" href="#using-multiple-metric-evaluation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Scikit-learn también permite la evaluación de múltiples métricas en <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code>, <code class="docutils literal notranslate"><span class="pre">RandomizedSearchCV`</span> <span class="pre">y</span> <span class="pre">``cross_validate</span></code>.</p>
<p>Hay tres maneras de especificar múltiples métricas de puntuación para el parámetro <code class="docutils literal notranslate"><span class="pre">scoring</span></code>:</p>
<ul>
<li><dl>
<dt>Como un iterable de métricas de cadena:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Como un <code class="docutils literal notranslate"><span class="pre">dict</span></code> que mapea el nombre del puntuador a la función de puntuación:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">make_scorer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">make_scorer</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">),</span>
<span class="gp">... </span>           <span class="s1">&#39;prec&#39;</span><span class="p">:</span> <span class="s1">&#39;precision&#39;</span><span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>Ten en cuenta que los valores del dict pueden ser funciones de puntuación o una de las cadenas métricas predefinidas.</p>
</li>
<li><p>Como un invocable que devuelve un diccionario de puntuaciones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_validate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A sample toy binary classification dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">make_classification</span><span class="p">(</span><span class="n">n_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">svm</span> <span class="o">=</span> <span class="n">LinearSVC</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">confusion_matrix_scorer</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>     <span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">... </span>     <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;tn&#39;</span><span class="p">:</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;fp&#39;</span><span class="p">:</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>             <span class="s1">&#39;fn&#39;</span><span class="p">:</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;tp&#39;</span><span class="p">:</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv_results</span> <span class="o">=</span> <span class="n">cross_validate</span><span class="p">(</span><span class="n">svm</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">scoring</span><span class="o">=</span><span class="n">confusion_matrix_scorer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Getting the test set true positive scores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cv_results</span><span class="p">[</span><span class="s1">&#39;test_tp&#39;</span><span class="p">])</span>
<span class="go">[10  9  8  7  8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Getting the test set false negative scores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cv_results</span><span class="p">[</span><span class="s1">&#39;test_fn&#39;</span><span class="p">])</span>
<span class="go">[0 1 2 3 2]</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="classification-metrics">
<span id="id1"></span><h2><span class="section-number">3.3.2. </span>Métricas de clasificación<a class="headerlink" href="#classification-metrics" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics</span></code></a> implementa varias funciones de pérdida, puntuación y utilidad para medir el rendimiento de la clasificación. Algunas métricas pueden requerir estimaciones de probabilidad de la clase positiva, valores de confianza o valores de decisiones binarias. La mayoría de las implementaciones permiten que cada muestra proporcione una contribución ponderada a la puntuación global, a través del parámetro <code class="docutils literal notranslate"><span class="pre">sample_weight</span></code>.</p>
<p>Algunos de estos están restringidos al caso de clasificación binaria:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precision_recall_curve</span></code></a></p></td>
<td><p>Calcula los pares de precisión-recuerdo para diferentes umbrales de probabilidad.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roc_curve</span></code></a></p></td>
<td><p>Calcula la característica operativa del receptor (ROC).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.det_curve.html#sklearn.metrics.det_curve" title="sklearn.metrics.det_curve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_curve</span></code></a></p></td>
<td><p>Calcula las tasas de error para diferentes umbrales de probabilidad.</p></td>
</tr>
</tbody>
</table>
<p>Otros también trabajan en el caso multiclase:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score.html#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">balanced_accuracy_score</span></code></a></p></td>
<td><p>Calcula la precisión balanceada.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.cohen_kappa_score.html#sklearn.metrics.cohen_kappa_score" title="sklearn.metrics.cohen_kappa_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cohen_kappa_score</span></code></a></p></td>
<td><p>Kappa de Cohen: estadística que mide el acuerdo entre anotadores.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">confusion_matrix</span></code></a></p></td>
<td><p>Calcula la matriz de confusión para evaluar la precisión de una clasificación.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hinge_loss</span></code></a></p></td>
<td><p>Pérdida media de la bisagra (no regularizada).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matthews_corrcoef</span></code></a></p></td>
<td><p>Calcula el coeficiente de correlación Matthews (CMC).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a></p></td>
<td><p>Calcula el Área Bajo la Curva Característica Operativa del Receptor (ROC AUC) a partir de las puntuaciones de predicción.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.top_k_accuracy_score.html#sklearn.metrics.top_k_accuracy_score" title="sklearn.metrics.top_k_accuracy_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">top_k_accuracy_score</span></code></a></p></td>
<td><p>Puntuación de la clasificación de precisión Top-k.</p></td>
</tr>
</tbody>
</table>
<p>Algunos también trabajan en el caso multietiquetas:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">accuracy_score</span></code></a></p></td>
<td><p>Puntuación de la clasificación de precisión.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><code class="xref py py-obj docutils literal notranslate"><span class="pre">classification_report</span></code></a></p></td>
<td><p>Construye un informe de texto que muestre las principales métricas de clasificación.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f1_score</span></code></a></p></td>
<td><p>Calcula la puntuación F1, también conocida como puntuación F equilibrada o medición F.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fbeta_score</span></code></a></p></td>
<td><p>Calcula la puntuación F-beta.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.hamming_loss.html#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hamming_loss</span></code></a></p></td>
<td><p>Calcula la pérdida media de Hamming.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jaccard_score</span></code></a></p></td>
<td><p>Puntuación del coeficiente de similitud de Jaccard.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_loss</span></code></a></p></td>
<td><p>Pérdida logarítmica, también conocida como pérdida logística o pérdida de entropía cruzada.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multilabel_confusion_matrix</span></code></a></p></td>
<td><p>Calcula una matriz de confusión para cada clase o muestra.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precision_recall_fscore_support</span></code></a></p></td>
<td><p>Calcula precisión, recuerda, la medición F y soporte para cada clase.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precision_score</span></code></a></p></td>
<td><p>Calcula la precisión.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recall_score</span></code></a></p></td>
<td><p>Calcula la recuperación.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a></p></td>
<td><p>Calcula el Área Bajo la Curva Característica Operativa del Receptor (ROC AUC) a partir de las puntuaciones de predicción.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zero_one_loss</span></code></a></p></td>
<td><p>Pérdida de clasificación cero a uno.</p></td>
</tr>
</tbody>
</table>
<p>Y algunos trabajan con problemas binarios y multietiquetas (pero no multiclase):</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_precision_score</span></code></a></p></td>
<td><p>Calcula la precisión media (AP) de los puntajes de predicción.</p></td>
</tr>
</tbody>
</table>
<p>En las siguientes subsecciones, describiremos cada una de esas funciones, precedidas de algunas notas sobre la API común y la definición métrica.</p>
<section id="from-binary-to-multiclass-and-multilabel">
<span id="average"></span><h3><span class="section-number">3.3.2.1. </span>De binario a multiclase y multietiqueta<a class="headerlink" href="#from-binary-to-multiclass-and-multilabel" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Algunas métricas están esencialmente definidas para tareas de clasificación binaria (por ejemplo, <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">f1_score</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a>). En estos casos, por defecto sólo se evalúa la etiqueta positiva, asumiendo por defecto que la clase positiva está etiquetada como <code class="docutils literal notranslate"><span class="pre">1</span></code> (aunque esto puede ser configurable a través del parámetro <code class="docutils literal notranslate"><span class="pre">pos_label</span></code>).</p>
<p>Al extender una métrica binaria a problemas multiclase o multietiqueta, los datos se tratan como una colección de problemas binarios, uno por cada clase. Hay entonces un número de maneras de promediar los cálculos de la métrica binaria a través del conjunto de clases, cada una de las cuales puede ser útil en algún escenario. Cuando esté disponible, deberás seleccionar entre ellas utilizando el parámetro <code class="docutils literal notranslate"><span class="pre">average</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;macro&quot;</span></code> simplemente calcula la media de las métricas binarias, dando la misma ponderación a cada clase.  En los problemas en los que las clases poco frecuentes son, sin embargo, importantes, el macro-promedio puede ser un medio para destacar su rendimiento. Por otro lado, la suposición de que todas las clases son igual de importantes es a menudo falsa, de modo que el macro-promedio enfatizará en exceso el rendimiento típicamente bajo de una clase poco frecuente.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code> tiene en cuenta el desequilibrio de clases calculando la media de las métricas binarias en las que la puntuación de cada clase está ponderada por su presencia en la muestra de datos reales.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;micro&quot;</span></code> da a cada par de clase muestra una contribución igual a la métrica global (excepto como resultado de la ponderación de la muestra). En lugar de sumar la métrica por clase, se suman los dividendos y divisores que componen las métricas por clase para calcular un cociente global. El micropromedio puede ser preferible en entornos de etiquetas múltiples, incluida la clasificación multiclase en la que se debe ignorar una clase mayoritaria.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;samples&quot;</span></code> aplican sólo a los problemas multietiqueta. No calcula una medida por clase, sino que calcula la métrica sobre las clases verdaderas y predichas para cada muestra en los datos de evaluación, y devuelve su promedio (<code class="docutils literal notranslate"><span class="pre">sample_weight</span></code> ponderada).</p></li>
<li><p>Al seleccionar <code class="docutils literal notranslate"><span class="pre">average=None</span></code> se devolverá una matriz con la puntuación para cada clase.</p></li>
</ul>
<p>Mientras que los datos de multiclase se proporcionan a la métrica, como objetivos binarios, como una matriz de etiquetas de clase, los datos multietiquetas se especifican como una matriz de indicadores, en la que la celda <code class="docutils literal notranslate"><span class="pre">[i,</span> <span class="pre">j]</span></code> tiene valor 1 si la muestra <code class="docutils literal notranslate"><span class="pre">i</span></code> tiene la etiqueta <code class="docutils literal notranslate"><span class="pre">j</span></code> y valor 0 de lo contrario.</p>
</section>
<section id="accuracy-score">
<span id="id2"></span><h3><span class="section-number">3.3.2.2. </span>Puntuación de precisión<a class="headerlink" href="#accuracy-score" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">accuracy_score</span></code></a> calcula la <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">precisión</a>, ya sea la fracción (predeterminado) o el contador (normalize=False) de predicciones correctas.</p>
<p>En la clasificación multietiqueta, la función devuelve la precisión del subconjunto. Si todo el conjunto de etiquetas predecidas para una muestra coincide estrictamente con el conjunto verdadero de etiquetas, entonces la precisión del subconjunto es 1.0; de lo contrario es 0.0.</p>
<p>Si <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> es el valor predicho de la muestra <span class="math notranslate nohighlight">\(i\)</span>-ésima y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces la fracción de predicciones correctas sobre <span class="math notranslate nohighlight">\(n_\text{samples}\)</span> se define como</p>
<div class="math notranslate nohighlight">
\[\texttt{accuracy}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} 1(\hat{y}_i = y_i)\]</div>
<p>donde <span class="math notranslate nohighlight">\(1(x)\)</span> es la <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">función indicadora</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>En el caso multietiqueta con indicadores de etiqueta binaria:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.5</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Example:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/feature_selection/plot_permutation_test_for_classification.html#sphx-glr-auto-examples-feature-selection-plot-permutation-test-for-classification-py"><span class="std std-ref">Evalúa con permutaciones la importancia de una puntuación de clasificación</span></a> para un ejemplo de uso de puntuación de precisión usando permutaciones del conjunto de datos.</p></li>
</ul>
</div>
</section>
<section id="top-k-accuracy-score">
<span id="id3"></span><h3><span class="section-number">3.3.2.3. </span>Puntuación de precisión de Top-k<a class="headerlink" href="#top-k-accuracy-score" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.top_k_accuracy_score.html#sklearn.metrics.top_k_accuracy_score" title="sklearn.metrics.top_k_accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">top_k_accuracy_score</span></code></a> es una generalización de <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">accuracy_score</span></code></a>. La diferencia es que una predicción se considera correcta siempre y cuando la etiqueta verdadera esté asociada con uno de los puntajes predecidos más altos <code class="docutils literal notranslate"><span class="pre">k</span></code>. <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">accuracy_score</span></code></a> es el caso especial de <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<p>La función abarca los casos de clasificación binaria y multiclase, pero no el caso multietiqueta.</p>
<p>Si <span class="math notranslate nohighlight">\(\hat{f}_{i,j}\)</span> es la clase predecida para la <span class="math notranslate nohighlight">\(i\)</span>-ésima muestra correspondiente a la <span class="math notranslate nohighlight">\(j\)</span>-th mayor puntuación predicha y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces la fracción de predicciones correctas sobre <span class="math notranslate nohighlight">\(n_\text{samples}\)</span> se define como</p>
<div class="math notranslate nohighlight">
\[\texttt{top-k accuracy}(y, \hat{f}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} \sum_{j=1}^{k} 1(\hat{f}_{i,j} = y_i)\]</div>
<p>donde <span class="math notranslate nohighlight">\(k\)</span> es el número de suposiciones permitidas y <span class="math notranslate nohighlight">\(1(x)\)</span> es la <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">función indicador</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">top_k_accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top_k_accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Not normalizing gives the number of &quot;correctly&quot; classified samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top_k_accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</section>
<section id="balanced-accuracy-score">
<span id="id5"></span><h3><span class="section-number">3.3.2.4. </span>Puntuación de precisión balanceada<a class="headerlink" href="#balanced-accuracy-score" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score.html#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">balanced_accuracy_score</span></code></a> calcula la <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">precisión balanceada</a>, que evita las estimaciones de rendimiento infladas en conjuntos de datos desbalanceados. Se trata del macropromedio de las puntuaciones de recuperación por clase o, de forma equivalente, de la precisión bruta, en la que cada muestra se pondera según la prevalencia inversa de su clase verdadera. Así, para los conjuntos de datos equilibrados, la puntuación es igual a la precisión.</p>
<p>En el caso binario la precisión balanceada es igual a la media aritmética de <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">sensibilidad</a> (verdadero tipo positivo) y <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">especificidad</a> (tasa verdadera negativa), o el área debajo de la curva ROC con predicciones binarias en lugar de puntuaciones:</p>
<div class="math notranslate nohighlight">
\[\texttt{balanced-accuracy} = \frac{1}{2}\left( \frac{TP}{TP + FN} + \frac{TN}{TN + FP}\right )\]</div>
<p>Si el clasificador funciona igual de bien en ambas clases, este término se reduce a la precisión convencional (es decir, el número de predicciones correctas dividido por el número total de predicciones).</p>
<p>En contraste, si la precisión convencional está por encima de la posibilidad sólo porque el clasificador se aprovecha de un conjunto de pruebas desequilibrado entonces la precisión balanceada, según corresponda, caerá a <span class="math notranslate nohighlight">\(\frac{1}{n\_classes}\)</span>.</p>
<p>La puntuación oscila entre 0 y 1, o cuando se utiliza <code class="docutils literal notranslate"><span class="pre">adjusted=True</span></code>. se reescaló al rango <span class="math notranslate nohighlight">\(\frac{1}{1 - n\_classes}\)</span> a 1, inclusive, con rendimiento a puntuación aleatoria 0.</p>
<p>Si <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero de la muestra <code class="docutils literal notranslate"><span class="pre">i</span></code>-ésima de :math:, y <span class="math notranslate nohighlight">\(w_i\)</span> es la ponderación de muestra correspondiente, luego ajustamos la ponderación de la muestra a:</p>
<div class="math notranslate nohighlight">
\[\hat{w}_i = \frac{w_i}{\sum_j{1(y_j = y_i) w_j}}\]</div>
<p>donde <span class="math notranslate nohighlight">\(1(x)\)</span> es la <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">función indicadora</a>. Dado que se predice <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> para la muestra <span class="math notranslate nohighlight">\(i\)</span>, la precisión equilibrada se define como:</p>
<div class="math notranslate nohighlight">
\[\texttt{balanced-accuracy}(y, \hat{y}, w) = \frac{1}{\sum{\hat{w}_i}} \sum_i 1(\hat{y}_i = y_i) \hat{w}_i\]</div>
<p>Con <code class="docutils literal notranslate"><span class="pre">adjusted=True</span></code>, la precisión balanceada reporta el aumento relativo de <span class="math notranslate nohighlight">\(\texttt{balanced-accuracy}(y, \mathbf{0}, w) = \frac{1}{n\_classes}\)</span>. En el caso binario, esto también se conoce como <a class="reference external" href="https://en.wikipedia.org/wiki/Youden%27s_J_statistic">*estadísticas de J de Youden*</a>, o <em>informado</em>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La definición de múltiples clases parece la extensión más razonable de la métrica utilizada en la clasificación binaria, aunque no existe un consenso seguro en la literatura:</p>
<ul class="simple">
<li><p>Nuestra definición: <a class="reference internal" href="#mosley2013" id="id7"><span>[Mosley2013]</span></a>, <a class="reference internal" href="#kelleher2015" id="id8"><span>[Kelleher2015]</span></a> y <a class="reference internal" href="#guyon2015" id="id10"><span>[Guyon2015]</span></a>, donde <a class="reference internal" href="#guyon2015" id="id9"><span>[Guyon2015]</span></a> adopta la versión ajustada para asegurar que las predicciones aleatorias tengan una puntuación de <span class="math notranslate nohighlight">\(0\)</span> y las predicciones perfectas tienen una puntuación de <span class="math notranslate nohighlight">\(1\)</span>..</p></li>
<li><p>Precisión balanceada de la clase como se describe en <a class="reference internal" href="#mosley2013" id="id11"><span>[Mosley2013]</span></a>: se calcula el mínimo entre la precisión y el recordatorio para cada clase. Esos valores son entonces promediados sobre el número total de clases para obtener la precisión balanceada.</p></li>
<li><p>Precisión balanceada como se describe en <a class="reference internal" href="#urbanowicz2015" id="id12"><span>[Urbanowicz2015]</span></a>: el promedio de sensibilidad y especificidad se calcula para cada clase y luego se promedia sobre el número total de clases.</p></li>
</ul>
</div>
<div class="topic">
<p class="topic-title">Referencias:</p>
<dl class="citation">
<dt class="label" id="guyon2015"><span class="brackets">Guyon2015</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>I. Guyon, K. Bennett, G. Cawley, H.J. Escalante, S. Escalera, T.K. Ho, N. Macià,
B. Ray, M. Saeed, A.R. Statnikov, E. Viegas, <a class="reference external" href="https://ieeexplore.ieee.org/document/7280767">Design of the 2015 ChaLearn AutoML Challenge</a>,
IJCNN 2015.</p>
</dd>
<dt class="label" id="mosley2013"><span class="brackets">Mosley2013</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>L. Mosley, <a class="reference external" href="https://lib.dr.iastate.edu/etd/13537/">A balanced approach to the multi-class imbalance problem</a>,
IJCV 2010.</p>
</dd>
<dt class="label" id="kelleher2015"><span class="brackets"><a class="fn-backref" href="#id8">Kelleher2015</a></span></dt>
<dd><p>John. D. Kelleher, Brian Mac Namee, Aoife D’Arcy, <a class="reference external" href="https://mitpress.mit.edu/books/fundamentals-machine-learning-predictive-data-analytics">Fundamentals of
Machine Learning for Predictive Data Analytics: Algorithms, Worked Examples,
and Case Studies</a>,
2015.</p>
</dd>
<dt class="label" id="urbanowicz2015"><span class="brackets"><a class="fn-backref" href="#id12">Urbanowicz2015</a></span></dt>
<dd><p>Urbanowicz R.J.,  Moore, J.H. <a class="reference external" href="https://doi.org/10.1007/s12065-015-0128-8">ExSTraCS 2.0: description and evaluation of a scalable learning
classifier system</a>, Evol. Intel. (2015) 8: 89.</p>
</dd>
</dl>
</div>
</section>
<section id="cohen-s-kappa">
<span id="cohen-kappa"></span><h3><span class="section-number">3.3.2.5. </span>Kappa de Cohen<a class="headerlink" href="#cohen-s-kappa" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.cohen_kappa_score.html#sklearn.metrics.cohen_kappa_score" title="sklearn.metrics.cohen_kappa_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">cohen_kappa_score</span></code></a> calcula la estadística <a class="reference external" href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen’s kappa</a>. Esta medida está pensada para comparar etiquetados por diferentes anotadores humanos, no un clasificador frente a uno basado en evidencia.</p>
<p>La puntuación de kappa (ver cadena de documentación) es un número entre -1 y 1. Las puntuaciones sobre .8 se consideran generalmente como un buen acuerdo; cero o menor significa ningún acuerdo (etiquetas prácticamente aleatorias).</p>
<p>Las puntuaciones de Kappa pueden ser calculadas para problemas binarios o multiclase, pero no para problemas multietiqueta (excepto calculando manualmente un puntaje por etiqueta) y no para más de dos anotadores.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">cohen_kappa_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cohen_kappa_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.4285714285714286</span>
</pre></div>
</div>
</section>
<section id="confusion-matrix">
<span id="id14"></span><h3><span class="section-number">3.3.2.6. </span>Matriz de confusión<a class="headerlink" href="#confusion-matrix" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">confusion_matrix</span></code></a> evalúa la precisión de la clasificación calculando la <a class="reference external" href="https://en.wikipedia.org/wiki/Confusion_matrix">matriz de confusión</a> con cada fila correspondiente a la clase verdadera (Wikipedia y otras referencias pueden utilizar una convención diferente para los ejes).</p>
<p>Por definición, la entrada <span class="math notranslate nohighlight">\(i, j\)</span> en una matriz de confusión es el número de observaciones en el grupo <span class="math notranslate nohighlight">\(i\)</span>, pero se espera que esté en el grupo <span class="math notranslate nohighlight">\(j\)</span>. Aquí hay un ejemplo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">array([[2, 0, 0],</span>
<span class="go">       [0, 0, 1],</span>
<span class="go">       [1, 0, 2]])</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/sklearn.metrics.plot_confusion_matrix.html#sklearn.metrics.plot_confusion_matrix" title="sklearn.metrics.plot_confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_confusion_matrix</span></code></a> puede ser usado para representar visualmente una matriz de confusión como se muestra en el ejemplo <a class="reference internal" href="../auto_examples/model_selection/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py"><span class="std std-ref">Matriz de confusión</span></a> que crea la siguiente figura:</p>
<a class="reference external image-reference" href="../auto_examples/model_selection/plot_confusion_matrix.html"><img alt="../_images/sphx_glr_plot_confusion_matrix_001.png" class="align-center" src="../_images/sphx_glr_plot_confusion_matrix_001.png" style="width: 480.0px; height: 360.0px;" /></a>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">normalize</span></code> permite informar de tasas en lugar de recuentos. La matriz de confusión puede ser normalizada de 3 maneras diferentes: <code class="docutils literal notranslate"><span class="pre">'pred'</span></code>, <code class="docutils literal notranslate"><span class="pre">'true'</span></code>, y <code class="docutils literal notranslate"><span class="pre">'all'</span></code> que dividirá los recuentos por la suma de cada columna, fila o la matriz completa, respectivamente.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="go">array([[0.25 , 0.125],</span>
<span class="go">       [0.25 , 0.375]])</span>
</pre></div>
</div>
<p>Para problemas binarios, podemos obtener cuentas de verdaderos negativos, falsos positivos, falsos negativos y verdaderos positivos como sigue:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tn</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tn</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tp</span>
<span class="go">(2, 1, 2, 3)</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Example:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py"><span class="std std-ref">Matriz de confusión</span></a> para un ejemplo de uso de una matriz de confusión para evaluar la calidad de salida del clasificador.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/classification/plot_digits_classification.html#sphx-glr-auto-examples-classification-plot-digits-classification-py"><span class="std std-ref">Reconocimiento de dígitos escritos a mano</span></a> para un ejemplo de uso de una matriz de confusión para clasificar dígitos escritos a mano.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups.html#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Clasificación de documentos de texto utilizando características dispersas</span></a> para un ejemplo de uso de una matriz de confusión para clasificar documentos de texto.</p></li>
</ul>
</div>
</section>
<section id="classification-report">
<span id="id16"></span><h3><span class="section-number">3.3.2.7. </span>Reporte de clasificación<a class="headerlink" href="#classification-report" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><code class="xref py py-func docutils literal notranslate"><span class="pre">classification_report</span></code></a> construye un reporte de texto que muestra las principales métricas de clasificación. Aquí hay un pequeño ejemplo con <code class="docutils literal notranslate"><span class="pre">target_names</span></code> personalizados y etiquetas inferidas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;class 0&#39;</span><span class="p">,</span> <span class="s1">&#39;class 1&#39;</span><span class="p">,</span> <span class="s1">&#39;class 2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">target_names</span><span class="o">=</span><span class="n">target_names</span><span class="p">))</span>
<span class="go">              precision    recall  f1-score   support</span>

<span class="go">     class 0       0.67      1.00      0.80         2</span>
<span class="go">     class 1       0.00      0.00      0.00         1</span>
<span class="go">     class 2       1.00      0.50      0.67         2</span>

<span class="go">    accuracy                           0.60         5</span>
<span class="go">   macro avg       0.56      0.50      0.49         5</span>
<span class="go">weighted avg       0.67      0.60      0.59         5</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Example:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/classification/plot_digits_classification.html#sphx-glr-auto-examples-classification-plot-digits-classification-py"><span class="std std-ref">Reconocimiento de dígitos escritos a mano</span></a> para un ejemplo de uso del informe de clasificación para dígitos escritos a mano.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups.html#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Clasificación de documentos de texto utilizando características dispersas</span></a> para un ejemplo de uso del informe de clasificación para documentos de texto.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits.html#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Estimación de parámetros utilizando la búsqueda en cuadrícula con validación cruzada</span></a> para ver un ejemplo de uso del informe de clasificación para la búsqueda en cuadrícula con validación cruzada anidada.</p></li>
</ul>
</div>
</section>
<section id="hamming-loss">
<span id="id17"></span><h3><span class="section-number">3.3.2.8. </span>Pérdida de Hamming<a class="headerlink" href="#hamming-loss" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <a class="reference internal" href="generated/sklearn.metrics.hamming_loss.html#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">hamming_loss</span></code></a> calcula la pérdida media de Hamming o <a class="reference external" href="https://en.wikipedia.org/wiki/Hamming_distance">distancia Hamming</a> entre dos conjuntos de muestras.</p>
<p>Si <span class="math notranslate nohighlight">\(hat{y}_j\)</span> es el valor predicho para la <span class="math notranslate nohighlight">\(j\)</span>-ésima etiqueta de una muestra dada, <span class="math notranslate nohighlight">\(y_j\)</span> es el valor verdadero correspondiente, y <span class="math notranslate nohighlight">\(n_\text{labels}\)</span> es el número de clases o etiquetas, entonces la pérdida de Hamming <span class="math notranslate nohighlight">\(L_{Hamming}\)</span> entre dos muestras se define como:</p>
<div class="math notranslate nohighlight">
\[L_{Hamming}(y, \hat{y}) = \frac{1}{n_\text{labels}} \sum_{j=0}^{n_\text{labels} - 1} 1(\hat{y}_j \not= y_j)\]</div>
<p>donde <span class="math notranslate nohighlight">\(1(x)\)</span> es la <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">función indicadora</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">hamming_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
<p>En el caso multietiqueta con indicadores de etiqueta binaria:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.75</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En la clasificación multiclase, la pérdida Hamming corresponde a la distancia Hamming entre <code class="docutils literal notranslate"><span class="pre">y_true</span></code> y <code class="docutils literal notranslate"><span class="pre">y_pred</span></code>, que es similar a la función <a class="reference internal" href="#zero-one-loss"><span class="std std-ref">Pérdida cero uno</span></a>.  Sin embargo, mientras que la pérdida cero a uno penaliza los conjuntos de predicción que no coinciden estrictamente con los conjuntos verdaderos, la pérdida Hamming penaliza las etiquetas individuales.  Por lo tanto, la pérdida de Hamming, limitada por la pérdida de cero a uno, está siempre entre cero y uno, inclusive; y la predicción de un subconjunto o superconjunto adecuado de las etiquetas verdaderas dará una pérdida de Hamming entre cero y uno, exclusivamente.</p>
</div>
</section>
<section id="precision-recall-and-f-measures">
<span id="precision-recall-f-measure-metrics"></span><h3><span class="section-number">3.3.2.9. </span>Precisión, recuperación y medidas F<a class="headerlink" href="#precision-recall-and-f-measures" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Intuitivamente, la <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Precision">precisión</a> es la capacidad del clasificador de no etiquetar como positiva una muestra que es negativa, y la <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recuperación</a> es la capacidad del clasificador de encontrar todas las muestras positivas.</p>
<p>La <a class="reference external" href="https://en.wikipedia.org/wiki/F1_score">medida F</a> (medidas <span class="math notranslate nohighlight">\(F_\beta\)</span> y <span class="math notranslate nohighlight">\(F_1\)</span>) puede interpretarse como una media armónica ponderada de la precisión y la recuperación. Una medida <span class="math notranslate nohighlight">\(F_\beta\)</span> alcanza su mejor valor en 1 y su peor puntuación en 0. Con <span class="math notranslate nohighlight">\(\beta = 1\)</span>, <span class="math notranslate nohighlight">\(F_\beta\)</span> y <span class="math notranslate nohighlight">\(F_1\)</span> son equivalentes, y el recuerdo y la precisión son igualmente importantes.</p>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_recall_curve</span></code></a> calcula una curva de recuperación de precisión a partir de la etiqueta basada en evidencia y una puntuación dada por el clasificador variando un umbral de decisión.</p>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">average_precision_score</span></code></a> calcula la <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Information_retrieval&amp;oldid=793358396#Average_precision">precisión promedio</a> (AP) a partir de las puntuaciones de las predicciones. El valor está entre 0 y 1 y cuanto más alto mejor. La AP se define como</p>
<div class="math notranslate nohighlight">
\[\text{AP} = \sum_n (R_n - R_{n-1}) P_n\]</div>
<p>donde <span class="math notranslate nohighlight">\(P_n\)</span> y <span class="math notranslate nohighlight">\(R_n\)</span> son la precisión y recuperación en el n-ésimo umbral. Con predicciones aleatorias, el AP es la fracción de muestras positivas.</p>
<p>Las referencias <a class="reference internal" href="#manning2008" id="id19"><span>[Manning2008]</span></a> y <a class="reference internal" href="#everingham2010" id="id20"><span>[Everingham2010]</span></a> presentan variantes alternativas de AP que interpolan la curva de recuperación de precisión. Actualmente, <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">average_precision_score</span></code></a> no implementa ninguna variante interpolada. Las referencias <a class="reference internal" href="#davis2006" id="id21"><span>[Davis2006]</span></a> y <a class="reference internal" href="#flach2015" id="id22"><span>[Flach2015]</span></a> describen por qué una interpolación lineal de puntos en la curva de recuperación de precisión proporciona una medida excesivamente optimista del rendimiento del clasificador. Esta interpolación lineal se utiliza al calcular el área bajo la curva con la regla trapezoidal en <a class="reference internal" href="generated/sklearn.metrics.auc.html#sklearn.metrics.auc" title="sklearn.metrics.auc"><code class="xref py py-func docutils literal notranslate"><span class="pre">auc</span></code></a>.</p>
<p>Varias funciones te permiten analizar la puntuación de precisión, recuperación y mediciones F:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_precision_score</span></code></a></p></td>
<td><p>Calcula la precisión media (AP) de los puntajes de predicción.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f1_score</span></code></a></p></td>
<td><p>Calcula la puntuación F1, también conocida como puntuación F equilibrada o medición F.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fbeta_score</span></code></a></p></td>
<td><p>Calcula la puntuación F-beta.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precision_recall_curve</span></code></a></p></td>
<td><p>Calcula los pares de precisión-recuerdo para diferentes umbrales de probabilidad.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precision_recall_fscore_support</span></code></a></p></td>
<td><p>Calcula precisión, recuerda, la medición F y soporte para cada clase.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precision_score</span></code></a></p></td>
<td><p>Calcula la precisión.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recall_score</span></code></a></p></td>
<td><p>Calcula la recuperación.</p></td>
</tr>
</tbody>
</table>
<p>Ten en cuenta que la función <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_recall_curve</span></code></a> está restringida al caso binario. La función <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">average_precision_score</span></code></a> sólo funciona en la clasificación binaria y en el formato de indicador multietiqueta. La función <a class="reference internal" href="generated/sklearn.metrics.plot_precision_recall_curve.html#sklearn.metrics.plot_precision_recall_curve" title="sklearn.metrics.plot_precision_recall_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_precision_recall_curve</span></code></a> traza la precisión de recuperación de la siguiente manera.</p>
<a class="reference external image-reference" href="../auto_examples/model_selection/plot_precision_recall.html#plot-the-precision-recall-curve"><img alt="../_images/sphx_glr_plot_precision_recall_001.png" class="align-center" src="../_images/sphx_glr_plot_precision_recall_001.png" style="width: 480.0px; height: 360.0px;" /></a>
<div class="topic">
<p class="topic-title">Ejemplos:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups.html#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Clasificación de documentos de texto utilizando características dispersas</span></a> para un ejemplo de uso de <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">f1_score</span></code></a> para clasificar documentos de texto.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits.html#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Estimación de parámetros utilizando la búsqueda en cuadrícula con validación cruzada</span></a> para un ejemplo de uso de <a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_score</span></code></a> y <a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">recall_score</span></code></a> para estimar parámetros utilizando la búsqueda en la cuadrícula con validación cruzada anidada.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_precision_recall.html#sphx-glr-auto-examples-model-selection-plot-precision-recall-py"><span class="std std-ref">Precisión-Exhaustividad</span></a> para un ejemplo de uso de <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_recall_curve</span></code></a> para evaluar la calidad de la salida del clasificador.</p></li>
</ul>
</div>
<div class="topic">
<p class="topic-title">Referencias:</p>
<dl class="citation">
<dt class="label" id="manning2008"><span class="brackets"><a class="fn-backref" href="#id19">Manning2008</a></span></dt>
<dd><p>C.D. Manning, P. Raghavan, H. Schütze, <a class="reference external" href="https://nlp.stanford.edu/IR-book/html/htmledition/evaluation-of-ranked-retrieval-results-1.html">Introduction to Information Retrieval</a>,
2008.</p>
</dd>
<dt class="label" id="everingham2010"><span class="brackets"><a class="fn-backref" href="#id20">Everingham2010</a></span></dt>
<dd><p>M. Everingham, L. Van Gool, C.K.I. Williams, J. Winn, A. Zisserman,
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.157.5766&amp;rep=rep1&amp;type=pdf">The Pascal Visual Object Classes (VOC) Challenge</a>,
IJCV 2010.</p>
</dd>
<dt class="label" id="davis2006"><span class="brackets"><a class="fn-backref" href="#id21">Davis2006</a></span></dt>
<dd><p>J. Davis, M. Goadrich, <a class="reference external" href="http://www.machinelearning.org/proceedings/icml2006/030_The_Relationship_Bet.pdf">The Relationship Between Precision-Recall and ROC Curves</a>,
ICML 2006.</p>
</dd>
<dt class="label" id="flach2015"><span class="brackets"><a class="fn-backref" href="#id22">Flach2015</a></span></dt>
<dd><p>P.A. Flach, M. Kull, <a class="reference external" href="https://papers.nips.cc/paper/5867-precision-recall-gain-curves-pr-analysis-done-right.pdf">Precision-Recall-Gain Curves: PR Analysis Done Right</a>,
NIPS 2015.</p>
</dd>
</dl>
</div>
<section id="binary-classification">
<h4><span class="section-number">3.3.2.9.1. </span>Clasificación binaria<a class="headerlink" href="#binary-classification" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En una tarea de clasificación binaria, los términos “”positivo”” y “”negativo”” se refieren a la predicción del clasificador, y los términos “”verdadero”” y “”falso”” se refieren a si esa predicción corresponde al juicio externo (a veces conocido como “”observación””). Dadas estas definiciones, podemos formular la siguiente tabla:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 39%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td colspan="2"><p>Clase real (observación)</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>Clase predicha (expectativa)</p></td>
<td><p>tp (verdadero positivo) Resultado correcto</p></td>
<td><p>fp (falso positivo) Resultado inesperado</p></td>
</tr>
<tr class="row-odd"><td><p>fn (falso negativo) Resultado ausente</p></td>
<td><p>tn (verdadero negativo) Ausencia correcta de resultado</p></td>
</tr>
</tbody>
</table>
<p>En este contexto, podemos definir las nociones de precisión, recuperación y medidas F:</p>
<div class="math notranslate nohighlight">
\[\text{precision} = \frac{tp}{tp + fp},\]</div>
<div class="math notranslate nohighlight">
\[\text{recall} = \frac{tp}{tp + fn},\]</div>
<div class="math notranslate nohighlight">
\[F_\beta = (1 + \beta^2) \frac{\text{precision} \times \text{recall}}{\beta^2 \text{precision} + \text{recall}}.\]</div>
<p>Aquí hay algunos ejemplos pequeños en clasificación binaria:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.66...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.83...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.66...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.55...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_recall_fscore_support</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">(array([0.66..., 1.        ]), array([1. , 0.5]), array([0.71..., 0.83...]), array([2, 2]))</span>


<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_recall_curve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">average_precision_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_scores</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span>
<span class="go">array([0.66..., 0.5       , 1.        , 1.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span>
<span class="go">array([1. , 0.5, 0.5, 0. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span>
<span class="go">array([0.35, 0.4 , 0.8 ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">average_precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_scores</span><span class="p">)</span>
<span class="go">0.83...</span>
</pre></div>
</div>
</section>
<section id="multiclass-and-multilabel-classification">
<h4><span class="section-number">3.3.2.9.2. </span>Clasificación multiclase y multietiqueta<a class="headerlink" href="#multiclass-and-multilabel-classification" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En las tareas de clasificación multiclase y multietiqueta, las nociones de precisión, recuperación y medidas F pueden aplicarse a cada etiqueta de forma independiente. Hay algunas formas de combinar los resultados entre las etiquetas, especificadas por el argumento <code class="docutils literal notranslate"><span class="pre">average</span></code> de <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">average_precision_score</span></code></a> (sólo multietiqueta), <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">f1_score</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">fbeta_score</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_recall_fscore_support</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_score</span></code></a> y <a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">recall_score</span></code></a>, como se describe <a class="reference internal" href="#average"><span class="std std-ref">arriba</span></a>. Ten en cuenta que si se incluyen todas las etiquetas, el promedio «micro» en un entorno multiclase producirá precisión, recuperación y <span class="math notranslate nohighlight">\(F\)</span> que son idénticos a la precisión. También ten en cuenta que el promedio «ponderado» puede producir una puntuación F que no está entre la precisión y la recuperación.</p>
<p>Para hacer esto más explícito, considere la siguiente notación:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(y\)</span> el conjunto de pares <em>predichos</em> <span class="math notranslate nohighlight">\((sample, label)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(hat{y}\)</span> el conjunto de pares <em>true</em> <span class="math notranslate nohighlight">\((sample, label)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> el conjunto de etiquetas</p></li>
<li><p><span class="math notranslate nohighlight">\(S\)</span> el conjunto de muestras</p></li>
<li><p><span class="math notranslate nohighlight">\(y_s\)</span> el subconjunto de <span class="math notranslate nohighlight">\(y\)</span> con la muestra <span class="math notranslate nohighlight">\(s\)</span>, es decir, <span class="math notranslate nohighlight">\(y_s := \left\{(s', l) \in y | s' = s\right\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_l\)</span> el subconjunto de <span class="math notranslate nohighlight">\(y\)</span> con la etiqueta <span class="math notranslate nohighlight">\(l\)</span></p></li>
<li><p>similarmente, <span class="math notranslate nohighlight">\(\hat{y}_s\)</span> y <span class="math notranslate nohighlight">\(\hat{y}_l\)</span> son subconjuntos de <span class="math notranslate nohighlight">\(\hat{y}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P(A, B) := \frac{\left| Un \cap B \right|}{\left|A\right|}\)</span> para algunos conjuntos <span class="math notranslate nohighlight">\(A\)</span> y <span class="math notranslate nohighlight">\(B\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(R(A, B) := \frac{\left| A \cap B \right|}{\left|B\right|}\)</span> (Las convenciones varían en el manejo <span class="math notranslate nohighlight">\(B = \emptyset\)</span>; esta implementación usa <span class="math notranslate nohighlight">\(R(A, B):=0\)</span>, y similar para <span class="math notranslate nohighlight">\(P\)</span>.)</p></li>
<li><p><span class="math notranslate nohighlight">\(F_\beta(A, B) := \left(1 + \beta^2\right) \frac{P(A, B) \times R(A, B)}{\beta^2 P(A, B) + R(A, B)}\)</span></p></li>
</ul>
<p>Luego las métricas se definen como:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 4%" />
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">promedio</span></code></p></th>
<th class="head"><p>Precisión</p></th>
<th class="head"><p>Recuperación</p></th>
<th class="head"><p>F_beta</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;micro&quot;</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(P(y, \hat{y})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(R(y, \hat{y})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(F_\beta(y, \hat{y})\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;samples&quot;</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|S\right|} \sum_{s \in S} P(y_s, \hat{y}_s)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|S\right|} \sum_{s \in S} R(y_s, \hat{y}_s)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|S\right|} \sum_{s \in S} F_\beta(y_s, \hat{y}_s)\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;macro&quot;</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|L\right|} \sum_{l \in L} P(y_l, \hat{y}_l)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|L\right|} \sum_{l \in L} R(y_l, \hat{y}_l)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|L\right|} \sum_{l \in L} F_\beta(y_l, \hat{y}_l)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| P(y_l, \hat{y}_l)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| R(y_l, \hat{y}_l)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| F_\beta(y_l, \hat{y}_l)\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\langle P(y_l, \hat{y}_l) | l \in L \rangle\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\langle R(y_l, \hat{y}_l) | l \in L \rangle\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\langle F_\beta(y_l, \hat{y}_l) | l \in L \rangle\)</span></p></td>
</tr>
</tbody>
</table>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;macro&#39;</span><span class="p">)</span>
<span class="go">0.22...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;micro&#39;</span><span class="p">)</span>
<span class="go">0.33...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span>
<span class="go">0.26...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fbeta_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;macro&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.23...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_recall_fscore_support</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">(array([0.66..., 0.        , 0.        ]), array([1., 0., 0.]), array([0.71..., 0.        , 0.        ]), array([2, 2, 2]...))</span>
</pre></div>
</div>
<p>Para la clasificación multiclase con una «clase negativa», es posible excluir algunas etiquetas:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;micro&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="c1"># excluding 0, no labels were correctly recalled</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>De manera similar, las etiquetas que no están presentes en la muestra de datos pueden contabilizarse en la macropromedio.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;macro&#39;</span><span class="p">)</span>
<span class="go">0.166...</span>
</pre></div>
</div>
</section>
</section>
<section id="jaccard-similarity-coefficient-score">
<span id="jaccard-similarity-score"></span><h3><span class="section-number">3.3.2.10. </span>Puntuación del coeficiente de similitud de Jaccard<a class="headerlink" href="#jaccard-similarity-coefficient-score" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">jaccard_score</span></code></a> calcula el promedio de <a class="reference external" href="https://en.wikipedia.org/wiki/Jaccard_index">los coeficientes de similitud de Jaccard</a>, también llamado índice de Jaccard, entre pares de conjuntos de etiquetas.</p>
<p>El coeficiente de similitud de Jaccard de las muestras <span class="math notranslate nohighlight">\(i\)</span>-ésimas, con un conjunto de etiquetas basada en evidencia <span class="math notranslate nohighlight">\(y_i\)</span> y un conjunto de etiquetas predichas <span class="math notranslate nohighlight">\(hat{y}_i\)</span>, se define como</p>
<div class="math notranslate nohighlight">
\[J(y_i, \hat{y}_i) = \frac{|y_i \cap \hat{y}_i|}{|y_i \cup \hat{y}_i|}.\]</div>
<p><a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">jaccard_score</span></code></a> funciona como <a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code class="xref py py-func docutils literal notranslate"><span class="pre">precision_recall_fscore_support</span></code></a> como una medida ingenua de conjunto que se aplica de forma nativa a objetivos binarios, y se extiende para aplicarse a multietiquetas y multiclases mediante el uso de <code class="docutils literal notranslate"><span class="pre">promedio</span></code> (ver <a class="reference internal" href="#average"><span class="std std-ref">sobre</span></a>).</p>
<p>En caso binario:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">jaccard_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0.6666...</span>
</pre></div>
</div>
<p>En el caso multietiqueta con indicadores de etiqueta binaria:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;samples&#39;</span><span class="p">)</span>
<span class="go">0.5833...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;macro&#39;</span><span class="p">)</span>
<span class="go">0.6666...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([0.5, 0.5, 1. ])</span>
</pre></div>
</div>
<p>Los problemas de múltiples clases son binarizados y tratados como el correspondiente problema multietiqueta:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([1. , 0. , 0.33...])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;macro&#39;</span><span class="p">)</span>
<span class="go">0.44...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jaccard_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;micro&#39;</span><span class="p">)</span>
<span class="go">0.33...</span>
</pre></div>
</div>
</section>
<section id="hinge-loss">
<span id="id23"></span><h3><span class="section-number">3.3.2.11. </span>Pérdida de la bisagra<a class="headerlink" href="#hinge-loss" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">hinge_loss</span></code></a> calcula la distancia media entre el modelo y los datos utilizando la <a class="reference external" href="https://en.wikipedia.org/wiki/Hinge_loss">pérdida de bisagra</a>, una métrica unilateral que sólo considera los errores de predicción. (La pérdida de bisagra se utiliza en los clasificadores de margen máximo, como las máquinas de vectores de soporte.)</p>
<p>Si las etiquetas están codificadas con +1 y -1,  <span class="math notranslate nohighlight">\(y\)</span>: es el valor verdadero, y <span class="math notranslate nohighlight">\(w\)</span> son las decisiones predichas como salida por <code class="docutils literal notranslate"><span class="pre">decision_function</span></code>, entonces la pérdida de la bisagra se define como:</p>
<div class="math notranslate nohighlight">
\[L_\text{Hinge}(y, w) = \max\left\{1 - wy, 0\right\} = \left|1 - wy\right|_+\]</div>
<p>Si hay más de dos etiquetas, <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">hinge_loss</span></code></a> utiliza una variante multiclase debido a Crammer &amp; Singer. <a class="reference external" href="http://jmlr.csail.mit.edu/papers/volume2/crammer01a/crammer01a.pdf">Aquí</a> es el artículo que lo describe.</p>
<p>Si <span class="math notranslate nohighlight">\(y_w\)</span> es la decisión predicha para la etiqueta verdadera y <span class="math notranslate nohighlight">\(y_t\)</span> es el máximo de las decisiones predichas para todas las demás etiquetas, donde las decisiones predichas son salida por función de decisión, entonces la pérdida de bisagras multiclase es definida por:</p>
<div class="math notranslate nohighlight">
\[L_\text{Hinge}(y_w, y_t) = \max\left\{1 + y_t - y_w, 0\right\}\]</div>
<p>Aquí un pequeño ejemplo que demuestra el uso de la función <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">hinge_loss</span></code></a> con un clasificador svm en un problema de clase binaria:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">hinge_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">LinearSVC</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">LinearSVC(random_state=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_decision</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">decision_function</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_decision</span>
<span class="go">array([-2.18...,  2.36...,  0.09...])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hinge_loss</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pred_decision</span><span class="p">)</span>
<span class="go">0.3...</span>
</pre></div>
</div>
<p>Aquí hay un ejemplo demostrando el uso de la función <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">hinge_loss</span></code></a> con un clasificador svm en un problema de multiclase:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">LinearSVC</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="go">LinearSVC()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_decision</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">decision_function</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hinge_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">pred_decision</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="go">0.56...</span>
</pre></div>
</div>
</section>
<section id="log-loss">
<span id="id25"></span><h3><span class="section-number">3.3.2.12. </span>Pérdida logística<a class="headerlink" href="#log-loss" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La pérdida logística, también llamada pérdida de regresión logística o pérdida de entropía cruzada, se define sobre las estimaciones de probabilidad.  Se utiliza habitualmente en la regresión logística (multinomial) y en las redes neuronales, así como en algunas variantes de la maximización de expectativas, y puede utilizarse para evaluar las salidas de probabilidad (<code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>) de un clasificador en lugar de sus predicciones discretas.</p>
<p>Para la clasificación binaria con una etiqueta verdadera <span class="math notranslate nohighlight">\(y \in {0,1\}\)</span> y una estimación de probabilidad <span class="math notranslate nohighlight">\(p = \operatorname{Pr}(y = 1)\)</span>, la pérdida logística por muestra es la log-verosimilitud negativa del clasificador dada la etiqueta verdadera:</p>
<div class="math notranslate nohighlight">
\[L_{\log}(y, p) = -\log \operatorname{Pr}(y|p) = -(y \log (p) + (1 - y) \log (1 - p))\]</div>
<p>Esto se extiende al caso multiclase, de la siguiente manera. Dejemos que las etiquetas verdaderas para un conjunto de muestras sean codificadas como una matriz de indicador binario de 1 a K <span class="math notranslate nohighlight">\(Y\)</span>, i. ., <span class="math notranslate nohighlight">\(y_{i,k} = 1\)</span> si la muestra <span class="math notranslate nohighlight">\(i\)</span> tiene la etiqueta <span class="math notranslate nohighlight">\(k\)</span> tomada de un conjunto de etiquetas <span class="math notranslate nohighlight">\(K\)</span>. Dejemos que <span class="math notranslate nohighlight">\(P\)</span> sea una matriz de estimaciones de probabilidad, con <span class="math notranslate nohighlight">\(p_{i,k} = \operatorname{Pr}(y_{i,k} = 1)\)</span>. Entonces la pérdida logística de todo el conjunto es</p>
<div class="math notranslate nohighlight">
\[L_{\log}(Y, P) = -\log \operatorname{Pr}(Y|P) = - \frac{1}{N} \sum_{i=0}^{N-1} \sum_{k=0}^{K-1} y_{i,k} \log p_{i,k}\]</div>
<p>Para ver cómo esto generaliza la pérdida logarítmica binaria dada anteriormente, observe que en el caso binario, <span class="math notranslate nohighlight">\(p_{i,0} = 1 - p_{i,1}\)</span> y <span class="math notranslate nohighlight">\(y_{i,0} = 1 - y_{i,1}\)</span>, por lo que al expandir la suma interna sobre <span class="math notranslate nohighlight">\(y_{i,k} \en {0,1\}\)</span> da la pérdida logarítmica binaria.</p>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">log_loss</span></code></a> calcula la pérdida logística dada una lista de etiquetas basadas en evidencia y una matriz de probabilidad, como devuelve el método <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> de un estimador.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">log_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">.9</span><span class="p">,</span> <span class="mf">.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">.8</span><span class="p">,</span> <span class="mf">.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">.3</span><span class="p">,</span> <span class="mf">.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">.01</span><span class="p">,</span> <span class="mf">.99</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.1738...</span>
</pre></div>
</div>
<p>El primer <code class="docutils literal notranslate"><span class="pre">[.9,</span> <span class="pre">.1]</span></code> en <code class="docutils literal notranslate"><span class="pre">y_pred</span></code> denota una probabilidad del 90% de que la primera muestra tenga la etiqueta 0. La pérdida logística no es negativa.</p>
</section>
<section id="matthews-correlation-coefficient">
<span id="matthews-corrcoef"></span><h3><span class="section-number">3.3.2.13. </span>Coeficiente de correlación Matthews<a class="headerlink" href="#matthews-correlation-coefficient" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code class="xref py py-func docutils literal notranslate"><span class="pre">matthews_corrcoef</span></code></a> calcula el coeficiente de correlación de <a class="reference external" href="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient">Matthew (MCC)</a> para clases binarias. Citando Wikipedia:</p>
<blockquote>
<div><p>«El coeficiente de correlación Matthews se utiliza en el aprendizaje automático como medida de la calidad de las clasificaciones binarias (dos clases). Tiene en cuenta los verdaderos y falsos positivos y negativos y, en general, se considera una medida balanceada que puede utilizarse incluso si las clases son de tamaños muy diferentes. El MCC es en esencia un valor de coeficiente de correlación entre -1 y +1. Un coeficiente de +1 representa una predicción perfecta, 0 una predicción aleatoria promedio y -1 una predicción inversa. El estadístico también se conoce como el coeficiente phi.»</p>
</div></blockquote>
<p>En el caso binario (dos clases), <span class="math notranslate nohighlight">\(tp\)</span>, <span class="math notranslate nohighlight">\(tn\)</span>, <span class="math notranslate nohighlight">\(fp\)</span> y <span class="math notranslate nohighlight">\(fn\)</span> son respectivamente el número de verdaderos positivos, negativos verdaderos, falsos positivos y negativos falsos, el MCC se define como</p>
<div class="math notranslate nohighlight">
\[MCC = \frac{tp \times tn - fp \times fn}{\sqrt{(tp + fp)(tp + fn)(tn + fp)(tn + fn)}}.\]</div>
<p>En el caso de multiclase, el coeficiente de correlación Matthews puede ser <a class="reference external" href="http://rk.kvl.dk/introduction/index.html">definido</a> en términos de un <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">confusion_matrix</span></code></a> <span class="math notranslate nohighlight">\(C\)</span> para las clases <span class="math notranslate nohighlight">\(K\)</span>. Para simplificar la definición, considere las siguientes variables intermedias:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(t_k=\su_{i}^{K} C_{ik}\)</span> el número de veces que la clase <span class="math notranslate nohighlight">\(k\)</span> realmente ha ocurrido,</p></li>
<li><p><span class="math notranslate nohighlight">\(p_k=\su_{i}^{K} C_{ki}\)</span> se predijo el número de veces que la clase <span class="math notranslate nohighlight">\(k\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(c=\su_{k}^{K} C_{kk}\)</span> el número total de muestras predicho correctamente,</p></li>
<li><p><span class="math notranslate nohighlight">\(s=\su_{i}^{K} \su_{j}^{K} C_{ij}\)</span> el número total de muestras.</p></li>
</ul>
<p>Entonces el MCC multiclase se define como:</p>
<div class="math notranslate nohighlight">
\[MCC = \frac{
    c \times s - \sum_{k}^{K} p_k \times t_k
}{\sqrt{
    (s^2 - \sum_{k}^{K} p_k^2) \times
    (s^2 - \sum_{k}^{K} t_k^2)
}}\]</div>
<p>Cuando hay más de dos etiquetas, el valor del MCC ya no estará entre -1 y +1. En su lugar, el valor mínimo será entre -1 y 0 dependiendo del número y la distribución de las etiquetas basadas en evidencia. El valor máximo es siempre +1.</p>
<p>Aquí hay un pequeño ejemplo que ilustra el uso de la función <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code class="xref py py-func docutils literal notranslate"><span class="pre">matthews_corrcoef</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">matthews_corrcoef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matthews_corrcoef</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">-0.33...</span>
</pre></div>
</div>
</section>
<section id="multi-label-confusion-matrix">
<span id="multilabel-confusion-matrix"></span><h3><span class="section-number">3.3.2.14. </span>Matriz de confusión multietiqueta<a class="headerlink" href="#multi-label-confusion-matrix" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">multilabel_confusion_matrix</span></code></a> calcula la matriz de confusión multietiqueta de una clase (predeterminado) o de una muestra (samplewise=True) para evaluar la precisión de una clasificación. multilabel_confusion_matrix también trata los datos de varias clases como si fueran de varias etiquetas, ya que se trata de una transformación que se suele aplicar para evaluar problemas de varias clases con métricas de clasificación binarias (como la precisión, la recuperación, etc.).</p>
<p>Al calcular la matriz de confusión multietiquetas en la clase <span class="math notranslate nohighlight">\(C\)</span>, el reconteo de verdaderos negativos para la clase <span class="math notranslate nohighlight">\(i\)</span> es <span class="math notranslate nohighlight">\(C_{i,0,0}\)</span>, falsos negativos es <span class="math notranslate nohighlight">\(C_{i,1,0}\)</span>, verdaderos positivos es <span class="math notranslate nohighlight">\(C_{i,1,1}\)</span> y falsos positivos es <span class="math notranslate nohighlight">\(C_{i,0,1}\)</span>.</p>
<p>Aquí hay un ejemplo que demuestra el uso de la función <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">multilabel_confusion_matrix</span></code></a> con la entrada <a class="reference internal" href="../glossary.html#term-multilabel-indicator-matrix"><span class="xref std std-term">multilabel indicator matrix</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">multilabel_confusion_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multilabel_confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">array([[[1, 0],</span>
<span class="go">        [0, 1]],</span>

<span class="go">       [[1, 0],</span>
<span class="go">        [0, 1]],</span>

<span class="go">       [[0, 1],</span>
<span class="go">        [1, 0]]])</span>
</pre></div>
</div>
<p>O se puede construir una matriz de confusión para las etiquetas de cada muestra:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">multilabel_confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">samplewise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[[1, 0],</span>
<span class="go">        [1, 1]],</span>

<span class="go">       [[1, 1],</span>
<span class="go">        [0, 1]]])</span>
</pre></div>
</div>
<p>Aquí hay un ejemplo demostrando el uso de la función <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">multilabel_confusion_matrix</span></code></a> con la entrada <a class="reference internal" href="../glossary.html#term-multiclass"><span class="xref std std-term">multiclass</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;bird&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multilabel_confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;bird&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">])</span>
<span class="go">array([[[3, 1],</span>
<span class="go">        [0, 2]],</span>

<span class="go">       [[5, 0],</span>
<span class="go">        [1, 0]],</span>

<span class="go">       [[2, 1],</span>
<span class="go">        [1, 2]]])</span>
</pre></div>
</div>
<p>A continuación se muestran algunos ejemplos que demuestran el uso de la función <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">multilabel_confusion_matrix</span></code></a> para calcular la recuperación (o la sensibilidad), la especificidad, el fallo y la tasa de error para cada clase en un problema con una matriz indicadora multietiqueta de entrada.</p>
<p>Calculando <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">recuperación</a> (también llamado la verdadera tasa positiva o la sensibilidad) para cada clase:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mcm</span> <span class="o">=</span> <span class="n">multilabel_confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tn</span> <span class="o">=</span> <span class="n">mcm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tp</span> <span class="o">=</span> <span class="n">mcm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">mcm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">mcm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tp</span> <span class="o">/</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span>
<span class="go">array([1. , 0.5, 0. ])</span>
</pre></div>
</div>
<p>Calculando <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">especificidad</a> (también llamado el verdadero tipo negativo) para cada clase:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tn</span> <span class="o">/</span> <span class="p">(</span><span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">array([1. , 0. , 0.5])</span>
</pre></div>
</div>
<p>Calculando <a class="reference external" href="https://en.wikipedia.org/wiki/False_positive_rate">caída</a> (también llamado el falso tipo positivo) para cada clase:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="n">fp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span>
<span class="go">array([0. , 1. , 0.5])</span>
</pre></div>
</div>
<p>Calculando <a class="reference external" href="https://en.wikipedia.org/wiki/False_positives_and_false_negatives">tasa de omisión</a> (también llamado el falso tipo negativo) para cada clase:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">/</span> <span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="n">tp</span><span class="p">)</span>
<span class="go">array([0. , 0.5, 1. ])</span>
</pre></div>
</div>
</section>
<section id="receiver-operating-characteristic-roc">
<span id="roc-metrics"></span><h3><span class="section-number">3.3.2.15. </span>Receptor operativo característico (ROC)<a class="headerlink" href="#receiver-operating-characteristic-roc" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_curve</span></code></a> calcula la curva de operación <a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">receptor operativo característico, o la curva ROC</a>. Citando Wikipedia :</p>
<blockquote>
<div><p>«Una curva de características operativas del receptor (ROC), o simplemente curva ROC, es un gráfico que ilustra el rendimiento de un sistema clasificador binario al variar su umbral de discriminación. Se crea trazando la fracción de verdaderos positivos de los positivos (TPR = tasa de verdaderos positivos) frente a la fracción de falsos positivos de los negativos (FPR = tasa de falsos positivos), en varios ajustes de umbral. La TPR también se conoce como sensibilidad, y la FPR es uno menos la especificidad o tasa de verdaderos negativos.»</p>
</div></blockquote>
<p>Esta función requiere el verdadero valor binario y las puntuaciones de destino, que pueden ser estimaciones de probabilidad de la clase positiva, valores de confianza o decisiones binarias. Aquí hay un pequeño ejemplo de cómo usar la función <a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_curve</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span>
<span class="go">array([0. , 0. , 0.5, 0.5, 1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tpr</span>
<span class="go">array([0. , 0.5, 0.5, 1. , 1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span>
<span class="go">array([1.8 , 0.8 , 0.4 , 0.35, 0.1 ])</span>
</pre></div>
</div>
<p>Esta imagen muestra un ejemplo de dicha curva ROC:</p>
<a class="reference external image-reference" href="../auto_examples/model_selection/plot_roc.html"><img alt="../_images/sphx_glr_plot_roc_001.png" class="align-center" src="../_images/sphx_glr_plot_roc_001.png" style="width: 480.0px; height: 360.0px;" /></a>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a> calcula el área bajo la curva de características operativas del receptor (ROC), que también se denomina AUC o AUROC.  Al calcular el área bajo la curva roc, la información de la curva se resume en un número. Para más información, consulta el artículo de la Wikipedia sobre AUC &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve">https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve</a>&gt;`_.</p>
<p>Comparado con las métricas como la precisión del subconjunto, la pérdida de Hamming, o la puntuación de F1, ROC no requiere optimizar un umbral para cada etiqueta.</p>
<section id="binary-case">
<span id="roc-auc-binary"></span><h4><span class="section-number">3.3.2.15.1. </span>Caso binario<a class="headerlink" href="#binary-case" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En el <strong>caso binario</strong>, puedes proporcionar las estimaciones de probabilidad, utilizando el método <code class="docutils literal notranslate"><span class="pre">classifier.predict_proba()</span></code>, o los valores de decisión no retenidos por el método <code class="docutils literal notranslate"><span class="pre">classifier.decision_function()</span></code>. En el caso de proporcionar las estimaciones de probabilidad, se debe proporcionar la probabilidad de la clase con la «etiqueta mayor». La «etiqueta mayor» corresponde a <code class="docutils literal notranslate"><span class="pre">classifier.</span> <span class="pre">lasses_[1]</span></code> y así <code class="docutils literal notranslate"><span class="pre">classifier.predict_proba(X)[:,</span> <span class="pre">1]</span></code>. Por lo tanto, el parámetro <code class="docutils literal notranslate"><span class="pre">y_score</span></code> es de tamaño (n_samples,).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_breast_cancer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;liblinear&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">classes_</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<p>Podemos usar las estimaciones de probabilidad correspondientes a <code class="docutils literal notranslate"><span class="pre">clf.classes_[1]</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_score</span><span class="p">)</span>
<span class="go">0.99...</span>
</pre></div>
</div>
<p>De lo contrario, podemos utilizar los valores de decisión no restringidos</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">0.99...</span>
</pre></div>
</div>
</section>
<section id="multi-class-case">
<span id="roc-auc-multiclass"></span><h4><span class="section-number">3.3.2.15.2. </span>Caso de clases múltiples<a class="headerlink" href="#multi-class-case" title="Enlazar permanentemente con este título">¶</a></h4>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a> también puede utilizarse en la <strong>clasificación multiclase</strong>. Actualmente se admiten dos estrategias de promediación: el algoritmo one-vs-one calcula la media de las puntuaciones ROC AUC por pares, y el algoritmo one-vs-rest calcula la media de las puntuaciones ROC AUC de cada clase frente a todas las demás. En ambos casos, las etiquetas predichas se proporcionan en una matriz con valores de 0 a <code class="docutils literal notranslate"><span class="pre">n_classes</span></code>, y las puntuaciones corresponden a las estimaciones de probabilidad de que una muestra pertenezca a una clase concreta. Los algoritmos OvO y OvR admiten la ponderación uniforme (<code class="docutils literal notranslate"><span class="pre">average='macro'</span></code>) y por prevalencia (<code class="docutils literal notranslate"><span class="pre">average='weighted'</span></code>).</p>
<p><strong>Algoritmo One-vs-one</strong>: Calcula el AUC promedio de todas las combinaciones posibles de clases. <a class="reference internal" href="#ht2001" id="id26"><span>[HT2001]</span></a> define una métrica de AUC multiclase ponderada uniformemente:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{c(c-1)}\sum_{j=1}^{c}\sum_{k &gt; j}^c (\text{AUC}(j | k) +
\text{AUC}(k | j))\]</div>
<p>donde <span class="math notranslate nohighlight">\(c\)</span> es el número de clases y <span class="math notranslate nohighlight">\(\text{AUC}(j | k)\)</span> es el AUC con la clase <span class="math notranslate nohighlight">\(j\)</span> como la clase positiva y la clase <span class="math notranslate nohighlight">\(k\)</span> como la clase negativa. En general, <span class="math notranslate nohighlight">\(\text{AUC}(j | k) \neq \text{AUC}(k | j)\)</span> en el caso multiclase. Este algoritmo se utiliza estableciendo el argumento de palabra clave <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> a <code class="docutils literal notranslate"><span class="pre">'ovo'</span></code> y <code class="docutils literal notranslate"><span class="pre">average</span></code> a <code class="docutils literal notranslate"><span class="pre">'macro'</span></code>.</p>
<p>La métrica AUC de <a class="reference internal" href="#ht2001" id="id27"><span>[HT2001]</span></a> multiclase puede ser extendida para ser ponderada por la prevalencia:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{c(c-1)}\sum_{j=1}^{c}\sum_{k &gt; j}^c p(j \cup k)(
\text{AUC}(j | k) + \text{AUC}(k | j))\]</div>
<p>donde <span class="math notranslate nohighlight">\(c\)</span> es el número de clases. Este algoritmo se utiliza estableciendo el argumento de la palabra clave <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> a <code class="docutils literal notranslate"><span class="pre">'ovo'`</span> <span class="pre">y</span> <span class="pre">``average</span></code> a <code class="docutils literal notranslate"><span class="pre">'weighted'</span></code>. La opción <code class="docutils literal notranslate"><span class="pre">'weighted'</span></code> devuelve un promedio ponderado de prevalencia como se describe en <a class="reference internal" href="#fc2009" id="id28"><span>[FC2009]</span></a>.</p>
<p><strong>Algoritmo One-vs-rest</strong>: Calcula el AUC de cada clase contra el resto <a class="reference internal" href="#pd2000" id="id29"><span>[PD2000]</span></a>. El algoritmo es funcionalmente el mismo que el caso multietiqueta. Para activar este algoritmo establece el argumento de palabra clave <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> a <code class="docutils literal notranslate"><span class="pre">'ovr'</span></code>. Al igual que OvO, OvR soporta dos tipos de promedio: <code class="docutils literal notranslate"><span class="pre">'macro'</span></code> <a class="reference internal" href="#f2006" id="id30"><span>[F2006]</span></a> y <code class="docutils literal notranslate"><span class="pre">'weighted'</span></code> <a class="reference internal" href="#f2001" id="id31"><span>[F2001]</span></a>.</p>
<p>En aplicaciones donde una alta tasa de falsos positivos no es tolerable, el parámetro <code class="docutils literal notranslate"><span class="pre">max_fpr</span></code> de <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a> puede utilizarse para resumir la curva ROC hasta el límite dado.</p>
<a class="reference external image-reference" href="../auto_examples/model_selection/plot_roc.html"><img alt="../_images/sphx_glr_plot_roc_002.png" class="align-center" src="../_images/sphx_glr_plot_roc_002.png" style="width: 480.0px; height: 360.0px;" /></a>
</section>
<section id="multi-label-case">
<span id="roc-auc-multilabel"></span><h4><span class="section-number">3.3.2.15.3. </span>Caso multietiquetas<a class="headerlink" href="#multi-label-case" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En la <strong>clasificación multietiqueta</strong>, la función <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">roc_auc_score</span></code></a> se extiende al promediar sobre las etiquetas como <a class="reference internal" href="#average"><span class="std std-ref">arriba</span></a>. En este caso, debe proporcionar un <code class="docutils literal notranslate"><span class="pre">y_score</span></code> de la forma <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_classes)</span></code>. Por lo tanto, al usar las estimaciones de probabilidad, se necesita seleccionar la probabilidad de la clase con la etiqueta mayor para cada salida.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_multilabel_classification</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.multioutput</span> <span class="kn">import</span> <span class="n">MultiOutputClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_multilabel_classification</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inner_clf</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;liblinear&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">MultiOutputClassifier</span><span class="p">(</span><span class="n">inner_clf</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">y_pred</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">y_pred</span> <span class="ow">in</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_score</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([0.82..., 0.86..., 0.94..., 0.85... , 0.94...])</span>
</pre></div>
</div>
<p>Y los valores de decisión no requieren tal procesamiento.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">RidgeClassifierCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">RidgeClassifierCV</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_score</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([0.81..., 0.84... , 0.93..., 0.87..., 0.94...])</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Ejemplos:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py"><span class="std std-ref">Característica operativa del receptor (ROC)</span></a> para un ejemplo de uso de ROC para evaluar la calidad de la salida de un clasificador.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_roc_crossval.html#sphx-glr-auto-examples-model-selection-plot-roc-crossval-py"><span class="std std-ref">Característica operativa del receptor (Receiver Operating Characteristic, ROC) con validación cruzada</span></a> para un ejemplo de uso de ROC para evaluar la calidad de la salida del clasificador, utilizando la validación cruzada.</p></li>
<li><p>Ver <a class="reference internal" href="../auto_examples/applications/plot_species_distribution_modeling.html#sphx-glr-auto-examples-applications-plot-species-distribution-modeling-py"><span class="std std-ref">Modelización de la distribución de las especies</span></a> para un ejemplo de uso de ROC para modelar la distribución de especies.</p></li>
</ul>
</div>
<div class="topic">
<p class="topic-title">Referencias:</p>
<dl class="citation">
<dt class="label" id="ht2001"><span class="brackets">HT2001</span><span class="fn-backref">(<a href="#id26">1</a>,<a href="#id27">2</a>)</span></dt>
<dd><p>Hand, D.J. and Till, R.J., (2001). <a class="reference external" href="http://link.springer.com/article/10.1023/A:1010920819831">A simple generalisation
of the area under the ROC curve for multiple class classification problems.</a>
Machine learning, 45(2), pp.171-186.</p>
</dd>
<dt class="label" id="fc2009"><span class="brackets"><a class="fn-backref" href="#id28">FC2009</a></span></dt>
<dd><p>Ferri, Cèsar &amp; Hernandez-Orallo, Jose &amp; Modroiu, R. (2009).
<a class="reference external" href="https://www.math.ucdavis.edu/~saito/data/roc/ferri-class-perf-metrics.pdf">An Experimental Comparison of Performance Measures for Classification.</a>
Pattern Recognition Letters. 30. 27-38.</p>
</dd>
<dt class="label" id="pd2000"><span class="brackets"><a class="fn-backref" href="#id29">PD2000</a></span></dt>
<dd><p>Provost, F., Domingos, P. (2000). Well-trained PETs: Improving
probability estimation trees (Section 6.2), CeDER Working Paper #IS-00-04,
Stern School of Business, New York University.</p>
</dd>
<dt class="label" id="f2006"><span class="brackets"><a class="fn-backref" href="#id30">F2006</a></span></dt>
<dd><p>Fawcett, T., 2006. <a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S016786550500303X">An introduction to ROC analysis.</a>
Pattern Recognition Letters, 27(8), pp. 861-874.</p>
</dd>
<dt class="label" id="f2001"><span class="brackets"><a class="fn-backref" href="#id31">F2001</a></span></dt>
<dd><p>Fawcett, T., 2001. <a class="reference external" href="http://ieeexplore.ieee.org/document/989510/">Using rule sets to maximize
ROC performance</a>
In Data Mining, 2001.
Proceedings IEEE International Conference, pp. 131-138.</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="detection-error-tradeoff-det">
<span id="det-curve"></span><h3><span class="section-number">3.3.2.16. </span>Compensación de errores de detección (DET)<a class="headerlink" href="#detection-error-tradeoff-det" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.det_curve.html#sklearn.metrics.det_curve" title="sklearn.metrics.det_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">det_curve</span></code></a> calcula la curva de error de detección (DET) de la curva <a class="reference internal" href="#wikipediadet2017" id="id32"><span>[WikipediaDET2017]</span></a>. Citando Wikipedia:</p>
<blockquote>
<div><p>«Un gráfico de compensación de errores de detección (DET) es un gráfico de las tasas de error de los sistemas de clasificación binarios, que representa la tasa de falsos rechazos frente a la tasa de falsos aceptados. Los ejes x e y se escalan de forma no lineal por sus desviaciones normales estándar (o simplemente por transformación logarítmica), dando lugar a curvas de compensación que son más lineales que las curvas ROC, y utilizan la mayor parte del área de la imagen para destacar las diferencias de importancia en la región operativa crítica.»</p>
</div></blockquote>
<p>Las curvas DET son una variación de las curvas de características operativas del receptor (ROC) en las que la tasa de falsos negativos se representa en el eje Y en lugar de la tasa de verdaderos positivos. Las curvas DET se suelen trazar en escala de desviación normal por transformación con <span class="math notranslate nohighlight">\(\phi^{-1}\)</span> (siendo <span class="math notranslate nohighlight">\(\phi\)</span> la función de distribución acumulativa). Las curvas de rendimiento resultantes visualizan explícitamente la compensación de los tipos de error para determinados algoritmos de clasificación. Ver <a class="reference internal" href="#martin1997" id="id33"><span>[Martin1997]</span></a> para ver ejemplos y una mayor motivación.</p>
<p>Esta imagen compara las curvas ROC y DET de dos clasificadores de ejemplo en la misma tarea de clasificación:</p>
<a class="reference external image-reference" href="../auto_examples/model_selection/plot_det.html"><img alt="../_images/sphx_glr_plot_det_001.png" class="align-center" src="../_images/sphx_glr_plot_det_001.png" style="width: 825.0px; height: 375.0px;" /></a>
<p><strong>Propiedades:</strong></p>
<ul class="simple">
<li><p>Las curvas DET forman una curva lineal en escala de desviación normal si las puntuaciones de detección están distribuidas normalmente (o casi normalmente). <a class="reference internal" href="#navratil2007" id="id34"><span>[Navratil2007]</span></a> demostró que lo contrario no es necesariamente cierto y que incluso distribuciones más generales pueden producir curvas DET lineales.</p></li>
<li><p>La transformación de la escala normal desviada distribuye los puntos de forma que se ocupa un espacio comparativamente mayor del gráfico. Por lo tanto, las curvas con un rendimiento de clasificación similar podrían ser más fáciles de distinguir en un gráfico DET.</p></li>
<li><p>Dado que la tasa de falsos negativos es «inversa» a la tasa de verdaderos positivos, el punto de perfección de las curvas DET es el origen (en contraste con la esquina superior izquierda de las curvas ROC).</p></li>
</ul>
<p><strong>Aplicaciones y limitaciones:</strong></p>
<p>Las curvas DET son de lectura intuitiva y, por tanto, permiten una rápida evaluación visual del rendimiento de un clasificador. Además, las curvas DET pueden consultarse para el análisis de umbrales y la selección del punto de funcionamiento. Esto es especialmente útil si se requiere una comparación de los tipos de error.</p>
<p>Por otro lado, las curvas DET no proporcionan su métrica como un único número. Por lo tanto, para la evaluación automatizada o la comparación con otras tareas de clasificación, podrían ser más adecuadas métricas como el área derivada bajo la curva ROC.</p>
<div class="topic">
<p class="topic-title">Ejemplos:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/model_selection/plot_det.html#sphx-glr-auto-examples-model-selection-plot-det-py"><span class="std std-ref">Curva de compensación de errores de detección (DET)</span></a> para ver un ejemplo de comparación entre las curvas de características operativas del receptor (ROC) y las curvas de compensación de errores de detección (DET).</p></li>
</ul>
</div>
<div class="topic">
<p class="topic-title">Referencias:</p>
<dl class="citation">
<dt class="label" id="wikipediadet2017"><span class="brackets"><a class="fn-backref" href="#id32">WikipediaDET2017</a></span></dt>
<dd><p>Colaboradores de Wikipedia. Detection error tradeoff. Wikipedia, The Free Encyclopedia. 4 de septiembre de 2017, 23:33 UTC. Disponible en: <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Detection_error_tradeoff&amp;oldid=798982054">https://en.wikipedia.org/w/index.php?title=Detection_error_tradeoff&amp;oldid=798982054</a>. Accedido el 19 de febrero de 2018.</p>
</dd>
<dt class="label" id="martin1997"><span class="brackets"><a class="fn-backref" href="#id33">Martin1997</a></span></dt>
<dd><p>A. Martin, G. Doddington, T. Kamm, M. Ordowski, and M. Przybocki,
<a class="reference external" href="http://www.dtic.mil/docs/citations/ADA530509">The DET Curve in Assessment of Detection Task Performance</a>,
NIST 1997.</p>
</dd>
<dt class="label" id="navratil2007"><span class="brackets"><a class="fn-backref" href="#id34">Navratil2007</a></span></dt>
<dd><p>J. Navractil and D. Klusacek,
«<a class="reference external" href="http://www.research.ibm.com/CBG/papers/icassp07_navratil.pdf">On Linear DETs,</a>»
2007 IEEE International Conference on Acoustics,
Speech and Signal Processing - ICASSP “07, Honolulu,
HI, 2007, pp. IV-229-IV-232.</p>
</dd>
</dl>
</div>
</section>
<section id="zero-one-loss">
<span id="id35"></span><h3><span class="section-number">3.3.2.17. </span>Pérdida cero uno<a class="headerlink" href="#zero-one-loss" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">zero_one_loss</span></code></a> calcula la suma o la media de la pérdida de clasificación 0-1 (<span class="math notranslate nohighlight">\(L_{0-1}\)</span>) sobre <span class="math notranslate nohighlight">\(n_{text{samples}}. Por defecto, la función se normaliza sobre la muestra. Para obtener la suma de :math:\)</span>, establezca <code class="docutils literal notranslate"><span class="pre">normalize</span></code> como <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>En la clasificación multietiqueta, la <code class="xref py py-func docutils literal notranslate"><span class="pre">cero_one_loss</span></code> puntúa un subconjunto como uno si sus etiquetas coinciden estrictamente con las predicciones, y como un cero si hay algún error.  Por defecto, la función devuelve el porcentaje de subconjuntos con predicciones imperfectas.  Para obtener el recuento de dichos subconjuntos, establezca <code class="docutils literal notranslate"><span class="pre">normalize</span></code> a <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<p>Si <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> es el valor predicho de la muestra <span class="math notranslate nohighlight">\(i\)</span>-ésima y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces la pérdida 0-1 <span class="math notranslate nohighlight">\(L_{0-1}\)</span> está definida como:</p>
<div class="math notranslate nohighlight">
\[L_{0-1}(y_i, \hat{y}_i) = 1(\hat{y}_i \not= y_i)\]</div>
<p>donde <span class="math notranslate nohighlight">\(1(x)\)</span> es la <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">función indicadora</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">zero_one_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>En el caso multietiqueta con indicadores de etiquetas binarias, donde la primera etiqueta [0,1] tiene un error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">0.5</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>  <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Example:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/feature_selection/plot_rfe_with_cross_validation.html#sphx-glr-auto-examples-feature-selection-plot-rfe-with-cross-validation-py"><span class="std std-ref">Eliminación recursiva de características con validación cruzada</span></a> para un ejemplo de uso de pérdida cero uno para realizar la eliminación recursiva de características con validación cruzada.</p></li>
</ul>
</div>
</section>
<section id="brier-score-loss">
<span id="id37"></span><h3><span class="section-number">3.3.2.18. </span>Pérdida de puntuación en Brier<a class="headerlink" href="#brier-score-loss" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.brier_score_loss.html#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">brier_score_loss</span></code></a> calcula la <a class="reference external" href="https://en.wikipedia.org/wiki/Brier_score">puntuación Brier</a> para las clases binarias <a class="reference internal" href="#brier1950" id="id38"><span>[Brier1950]</span></a>. Citando Wikipedia:</p>
<blockquote>
<div><p>«La puntuación de Brier es una función de puntuación propia que mide la precisión de las predicciones probabilísticas. Es aplicable a tareas en las que las predicciones deben asignar probabilidades a un conjunto de resultados discretos mutuamente excluyentes.»</p>
</div></blockquote>
<p>Esta función devuelve el error cuadrático medio del resultado real <span class="math notranslate nohighlight">\(y \in \{0, \}\)</span> y la estimación de la probabilidad predicha <span class="math notranslate nohighlight">\(p = \operatorname{Pr}(y = 1)\)</span> (<a class="reference internal" href="../glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a>) como salida por:</p>
<div class="math notranslate nohighlight">
\[BS = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1}(y_i - p_i)^2\]</div>
<p>La pérdida de puntuación de Brier también está entre 0 y 1 y cuanto más bajo sea el valor (la diferencia cuadrática media es menor), más precisa es la predicción.</p>
<p>Aquí hay un pequeño ejemplo de uso de esta función:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">brier_score_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true_categorical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;spam&quot;</span><span class="p">,</span> <span class="s2">&quot;ham&quot;</span><span class="p">,</span> <span class="s2">&quot;ham&quot;</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brier_score_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_prob</span><span class="p">)</span>
<span class="go">0.055</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brier_score_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_prob</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.055</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brier_score_loss</span><span class="p">(</span><span class="n">y_true_categorical</span><span class="p">,</span> <span class="n">y_prob</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="s2">&quot;ham&quot;</span><span class="p">)</span>
<span class="go">0.055</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brier_score_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_prob</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>La puntuación de Brier puede utilizarse para evaluar lo bien que está calibrado un clasificador. Sin embargo, una pérdida de puntuación de Brier más baja no siempre significa una mejor calibración. Esto se debe a que, por analogía con la descomposición sesgo-varianza del error cuadrático medio, la pérdida de puntuación de Brier puede descomponerse como la suma de la pérdida de calibración y la pérdida de refinamiento <a class="reference internal" href="#bella2012" id="id40"><span>[Bella2012]</span></a>. La pérdida de calibración se define como la desviación media al cuadrado de las probabilidades empíricas derivadas de la pendiente de los segmentos ROC. La pérdida de refinamiento puede definirse como la pérdida óptima esperada, medida por el área bajo la curva de coste óptimo. La pérdida de refinamiento puede cambiar independientemente de la pérdida de calibración, por lo que una pérdida de puntuación de Brier más baja no significa necesariamente un modelo mejor calibrado. «Sólo cuando la pérdida de refinamiento permanece igual, una pérdida de puntuación de Brier más baja significa siempre una mejor calibración» <a class="reference internal" href="#bella2012" id="id39"><span>[Bella2012]</span></a>, <a class="reference internal" href="#flach2008" id="id41"><span>[Flach2008]</span></a>.</p>
<div class="topic">
<p class="topic-title">Example:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/calibration/plot_calibration.html#sphx-glr-auto-examples-calibration-plot-calibration-py"><span class="std std-ref">Calibración de probabilidad de clasificadores</span></a> para un ejemplo de uso de la pérdida de puntuación Brier para realizar la calibración probabilística de los clasificadores.</p></li>
</ul>
</div>
<div class="topic">
<p class="topic-title">Referencias:</p>
<dl class="citation">
<dt class="label" id="brier1950"><span class="brackets"><a class="fn-backref" href="#id38">Brier1950</a></span></dt>
<dd><p>G. Brier, <a class="reference external" href="ftp://ftp.library.noaa.gov/docs.lib/htdocs/rescue/mwr/078/mwr-078-01-0001.pdf">Verification of forecasts expressed in terms of
probability</a>,
Monthly weather review 78.1 (1950)</p>
</dd>
<dt class="label" id="bella2012"><span class="brackets">Bella2012</span><span class="fn-backref">(<a href="#id39">1</a>,<a href="#id40">2</a>)</span></dt>
<dd><p>Bella, Ferri, Hernández-Orallo, and Ramírez-Quintana
<a class="reference external" href="http://dmip.webs.upv.es/papers/BFHRHandbook2010.pdf">«Calibration of Machine Learning Models»</a>
in Khosrow-Pour, M. «Machine learning: concepts, methodologies, tools
and applications.» Hershey, PA: Information Science Reference (2012).</p>
</dd>
<dt class="label" id="flach2008"><span class="brackets"><a class="fn-backref" href="#id41">Flach2008</a></span></dt>
<dd><p>Flach, Peter, and Edson Matsubara. <a class="reference external" href="https://drops.dagstuhl.de/opus/volltexte/2008/1382/">«On classification, ranking,
and probability estimation.»</a>
Dagstuhl Seminar Proceedings. Schloss Dagstuhl-Leibniz-Zentrum fr Informatik (2008).</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="multilabel-ranking-metrics">
<span id="id42"></span><h2><span class="section-number">3.3.3. </span>Métricas de clasificación multietiqueta<a class="headerlink" href="#multilabel-ranking-metrics" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En el aprendizaje multietiqueta, cada muestra puede tener asociado cualquier número de etiquetas basadas en evidencia. El objetivo es dar puntuaciones altas y una mejor clasificación a las etiquetas de la verdad básica.</p>
<section id="coverage-error">
<span id="id43"></span><h3><span class="section-number">3.3.3.1. </span>Error de cobertura<a class="headerlink" href="#coverage-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <code class="xref py py-func docutils literal notranslate"><span class="pre">cobertura_error</span></code> calcula el número medio de etiquetas que hay que incluir en la predicción final para que se predigan todas las etiquetas verdaderas. Esto es útil si quiere saber cuántas etiquetas de máxima puntuación tiene que predecir de media sin que falte ninguna verdadera. El mejor valor de esta métrica es, por tanto, el número medio de etiquetas verdaderas.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La puntuación de nuestra implementación es 1 mayor que la dada en Tsoumakas et al., 2010. Esto lo amplía para manejar el caso degenerado en el que una instancia tiene 0 etiquetas verdaderas.</p>
</div>
<p>Formalmente, dada una matriz de indicador binario basada en evidencia etiqueta <span class="math notranslate nohighlight">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> y la puntuación asociada con cada etiqueta <span class="math notranslate nohighlight">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, la cobertura se define como</p>
<div class="math notranslate nohighlight">
\[coverage(y, \hat{f}) = \frac{1}{n_{\text{samples}}}
  \sum_{i=0}^{n_{\text{samples}} - 1} \max_{j:y_{ij} = 1} \text{rank}_{ij}\]</div>
<p>con <span class="math notranslate nohighlight">\(\text{rank}_{ij} = \left|\left\{k: \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\right|\)</span>. Dada la definición de rango, los lazos en <code class="docutils literal notranslate"><span class="pre">y_scores</span></code> se rompen dando el rango máximo que habría sido asignado a todos los valores vinculados.</p>
<p>Aquí hay un pequeño ejemplo de uso de esta función:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">coverage_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coverage_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">)</span>
<span class="go">2.5</span>
</pre></div>
</div>
</section>
<section id="label-ranking-average-precision">
<span id="id44"></span><h3><span class="section-number">3.3.3.2. </span>Precisión promedio de clasificación de etiquetas<a class="headerlink" href="#label-ranking-average-precision" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.label_ranking_average_precision_score.html#sklearn.metrics.label_ranking_average_precision_score" title="sklearn.metrics.label_ranking_average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">label_ranking_average_precision_score</span></code></a> implementa la precisión media del posicionamiento de etiquetas (LRAP). Esta métrica está vinculada a la función <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">average_precision_score</span></code></a>, pero se basa en la noción de clasificación de etiquetas en lugar de en la precisión y la recuperación.</p>
<p>La precisión promedio de la clasificación de las etiquetas (LRAP) promedia sobre las muestras la respuesta a la siguiente pregunta: para cada etiqueta basada en evidencia, ¿qué fracción de las etiquetas mejor clasificadas eran etiquetas verdaderas? Esta medida de rendimiento será mayor si se consigue dar un mejor rango a las etiquetas asociadas a cada muestra. La puntuación obtenida es siempre estrictamente mayor que 0, y el mejor valor es 1. Si hay exactamente una etiqueta relevante por muestra, la precisión media del ranking de etiquetas es equivalente al <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank">ranking recíproco medio</a>.</p>
<p>Formalmente, dada una matriz indicadora binaria de las etiquetas basadas en evidencia <span class="math notranslate nohighlight">\(y \in \left{0, 1\right\}^{n_texto{samples} \y la puntuación asociada a cada etiqueta :math:\)</span>, la precisión media se define como</p>
<div class="math notranslate nohighlight">
\[LRAP(y, \hat{f}) = \frac{1}{n_{\text{samples}}}
  \sum_{i=0}^{n_{\text{samples}} - 1} \frac{1}{||y_i||_0}
  \sum_{j:y_{ij} = 1} \frac{|\mathcal{L}_{ij}|}{\text{rank}_{ij}}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\mathcal{L}_{ij} = \left\k: y_{ik} = 1, \hat{f}_{ik} \geq \hat{f}_{ij} \right}\)</span>, <span class="math notranslate nohighlight">\(\text{rank}_{ij} = \left|\left\{k: \hat{f}_{ik} |geq \hat{f}_{ij} \right\}\right|\)</span>, <span class="math notranslate nohighlight">\(|\cdot|\)</span> calcula la cardinalidad del conjunto (es decir, el número de elementos en el conjunto), y <span class="math notranslate nohighlight">\(||\cdot||_0\)</span> es la «norma» <span class="math notranslate nohighlight">\(\ell_0\)</span> (que calcula el número de elementos no nulos en un vector).</p>
<p>Aquí hay un pequeño ejemplo de uso de esta función:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">label_ranking_average_precision_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_ranking_average_precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">)</span>
<span class="go">0.416...</span>
</pre></div>
</div>
</section>
<section id="ranking-loss">
<span id="label-ranking-loss"></span><h3><span class="section-number">3.3.3.3. </span>Pérdida de clasificación<a class="headerlink" href="#ranking-loss" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.label_ranking_loss.html#sklearn.metrics.label_ranking_loss" title="sklearn.metrics.label_ranking_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">label_ranking_loss</span></code></a> calcula la pérdida de clasificación que promedia sobre las muestras el número de pares de etiquetas que están ordenados incorrectamente, es decir, las etiquetas verdaderas tienen una puntuación menor que las falsas, ponderada por la inversa del número de pares ordenados de etiquetas falsas y verdaderas. La pérdida de clasificación más baja que se puede alcanzar es cero.</p>
<p>Formalmente, dada una matriz indicadora binaria de las etiquetas basada en evidencia <span class="math notranslate nohighlight">\(y \in \left{0, 1\right\}^{n_texto{samples} \y la puntuación asociada a cada etiqueta :math:\)</span>, la pérdida de clasificación se define como</p>
<div class="math notranslate nohighlight">
\[ranking\_loss(y, \hat{f}) =  \frac{1}{n_{\text{samples}}}
  \sum_{i=0}^{n_{\text{samples}} - 1} \frac{1}{||y_i||_0(n_\text{labels} - ||y_i||_0)}
  \left|\left\{(k, l): \hat{f}_{ik} \leq \hat{f}_{il}, y_{ik} = 1, y_{il} = 0 \right\}\right|\]</div>
<p>donde <span class="math notranslate nohighlight">\(|\cdot|\)</span> calcula la cardinalidad del conjunto (es decir, el número de elementos en el conjunto) y <span class="math notranslate nohighlight">\(||\cdot||_0\)</span> es el <span class="math notranslate nohighlight">\(\ell_0\)</span> «normal» (que calcula el número de elementos no cero en un vector).</p>
<p>Aquí hay un pequeño ejemplo de uso de esta función:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">label_ranking_loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_ranking_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">)</span>
<span class="go">0.75...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With the following prediction, we have perfect and minimal loss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_ranking_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Referencias:</p>
<ul class="simple">
<li><p>Tsoumakas, G., Katakis, I., &amp; Vlahavas, I. (2010). Mining multi-label data. In
Data mining and knowledge discovery handbook (pp. 667-685). Springer US.</p></li>
</ul>
</div>
</section>
<section id="normalized-discounted-cumulative-gain">
<span id="ndcg"></span><h3><span class="section-number">3.3.3.4. </span>Ganancia acumulada descontada normalizada<a class="headerlink" href="#normalized-discounted-cumulative-gain" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La Ganancia Acumulativa Descontada (DCG) y la Ganancia Acumulativa Descontada Normalizada (NDCG) son métricas de clasificación implementadas en <a class="reference internal" href="generated/sklearn.metrics.dcg_score.html#sklearn.metrics.dcg_score" title="sklearn.metrics.dcg_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">dcg_score</span></code></a> y <a class="reference internal" href="generated/sklearn.metrics.ndcg_score.html#sklearn.metrics.ndcg_score" title="sklearn.metrics.ndcg_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndcg_score</span></code></a> ; comparan un orden predicho con las puntuaciones basadas en evidencia, como la relevancia de las respuestas a una consulta.</p>
<p>Desde la página de Wikipedia para Ganancia acumulada descontada:</p>
<p>«La ganancia acumulada descontada (DCG) es una medida de la calidad del ranking. En la recuperación de la información, se utiliza a menudo para medir la eficacia de los algoritmos de los motores de búsqueda de la web o aplicaciones relacionadas. Utilizando una escala de relevancia graduada de documentos en un conjunto de resultados de un motor de búsqueda, la DCG mide la utilidad, o ganancia, de un documento en función de su posición en la lista de resultados. La ganancia se acumula desde la parte superior de la lista de resultados hasta la inferior, descontando la ganancia de cada resultado en los rangos inferiores»</p>
<p>DCG ordena los objetivos reales (por ejemplo, la relevancia de las respuestas a la consulta) en el orden predicho, luego los multiplica por un decaimiento logarítmico y suma el resultado. La suma puede truncarse después de los primeros resultados <span class="math notranslate nohighlight">\(K\)</span>, en cuyo caso la llamamos DCG&#64;K. NDCG, o NDCG&#64;K es la DCG dividida por la DCG obtenida por una predicción perfecta, de modo que siempre está entre 0 y 1. Normalmente, se prefiere NDCG a DCG.</p>
<p>En comparación con la pérdida por clasificación, la NDCG puede tener en cuenta las puntuaciones de relevancia, en lugar de una clasificación basada en evidencia. Por lo tanto, si la verdad básica consiste sólo en una ordenación, se debe preferir la pérdida de clasificación; si la verdad básica consiste en puntuaciones de utilidad reales (por ejemplo, 0 para irrelevante, 1 para relevante, 2 para muy relevante), se puede utilizar NDCG.</p>
<p>Para una muestra, dado el vector de valores continuos basado en evidencia para cada objetivo <span class="math notranslate nohighlight">\(y \in \mathbb{R}^{M}\)</span>, donde <span class="math notranslate nohighlight">\(M\)</span> es el número de salidas, y la predicción <span class="math notranslate nohighlight">\(hat{y}\)</span>, que induce la función de clasificación <span class="math notranslate nohighlight">\(f\)</span>, la puntuación DCG es</p>
<div class="math notranslate nohighlight">
\[\sum_{r=1}^{\min(K, M)}\frac{y_{f(r)}}{\log(1 + r)}\]</div>
<p>y la puntuación NDCG es la puntuación DCG dividida por la puntuación DCG obtenida para <span class="math notranslate nohighlight">\(y\)</span>.</p>
<div class="topic">
<p class="topic-title">Referencias:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain">Entrada de Wikipedia para Ganancia Acumulada Descontada</a></p></li>
<li><p>Jarvelin, K., &amp; Kekalainen, J. (2002).
Cumulated gain-based evaluation of IR techniques. ACM Transactions on
Information Systems (TOIS), 20(4), 422-446.</p></li>
<li><p>Wang, Y., Wang, L., Li, Y., He, D., Chen, W., &amp; Liu, T. Y. (2013, May).
A theoretical analysis of NDCG ranking measures. In Proceedings of the 26th
Annual Conference on Learning Theory (COLT 2013)</p></li>
<li><p>McSherry, F., &amp; Najork, M. (2008, March). Computing information retrieval
performance measures efficiently in the presence of tied scores. In
European conference on information retrieval (pp. 414-421). Springer,
Berlin, Heidelberg.</p></li>
</ul>
</div>
</section>
</section>
<section id="regression-metrics">
<span id="id45"></span><h2><span class="section-number">3.3.4. </span>Métricas de Regresión<a class="headerlink" href="#regression-metrics" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics</span></code></a> implementa varias funciones de pérdida, puntuación y utilidad para medir el rendimiento de la regresión. Algunas de ellas han sido mejoradas para manejar el caso de salida múltiple: <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_squared_error</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_absolute_error</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">explained_variance_score</span></code></a> y <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">r2_score</span></code></a>.</p>
<p>Estas funciones tienen un argumento de palabra clave <code class="docutils literal notranslate"><span class="pre">multioutput</span></code> que especifica la forma en que se deben promediar las puntuaciones o pérdidas de cada objetivo individual. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">'uniform_average'</span></code>, que especifica una media uniformemente ponderada sobre las salidas. Si se pasa un <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> de forma <code class="docutils literal notranslate"><span class="pre">(n_outputs,)</span></code>, sus entradas se interpretan como pesos y se devuelve una media ponderada acorde. Si se especifica que <code class="docutils literal notranslate"><span class="pre">multioutput</span></code> es <code class="docutils literal notranslate"><span class="pre">raw_values</span></code>, entonces todas las puntuaciones o pérdidas individuales no alteradas se devolverán en un arreglo de forma <code class="docutils literal notranslate"><span class="pre">(n_outputs,)</span></code>.</p>
<p>Las funciones <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">r2_score</span></code></a> y <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">explained_variance_score</span></code></a> aceptan un valor adicional <code class="docutils literal notranslate"><span class="pre">'variance_weighted</span></code> para el parámetro <code class="docutils literal notranslate"><span class="pre">multioutput</span></code>. Esta opción conduce a una ponderación de cada puntuación individual por la varianza de la variable objetivo correspondiente. Este ajuste cuantifica la varianza capturada globalmente sin escalar. Si las variables objetivo son de diferente escala, esta puntuación da más importancia a la explicación de las variables de mayor varianza. <code class="docutils literal notranslate"><span class="pre">multioutput='variance_weighted'</span></code> es el valor predeterminado de <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">r2_score</span></code></a> por compatibilidad con versiones anteriores. Esto se cambiará a <code class="docutils literal notranslate"><span class="pre">promedio_uniforme</span></code> en el futuro.</p>
<section id="explained-variance-score">
<span id="id46"></span><h3><span class="section-number">3.3.4.1. </span>Puntuación de varianza explicada<a class="headerlink" href="#explained-variance-score" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">explained_variance_score</span></code></a> calcula la puntuación de regresión de la varianza explicada &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Explained_variation">https://en.wikipedia.org/wiki/Explained_variation</a>&gt;`_.</p>
<p>Si <span class="math notranslate nohighlight">\(\hat{y}\)</span> es la salida objetivo estimada, <span class="math notranslate nohighlight">\(y\)</span> la salida correspondiente (correcta) la salida objetivo, y <span class="math notranslate nohighlight">\(Var\)</span> es <a class="reference external" href="https://en.wikipedia.org/wiki/Variance">Varianza</a>, el cuadrado de la desviación estándar, entonces la varianza explicada se calcula de la siguiente manera:</p>
<div class="math notranslate nohighlight">
\[explained\_{}variance(y, \hat{y}) = 1 - \frac{Var\{ y - \hat{y}\}}{Var\{y\}}\]</div>
<p>La mejor puntuación posible es 1.0, los valores más bajos son peores.</p>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">explained_variance_score</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">explained_variance_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explained_variance_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.957...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explained_variance_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="s1">&#39;raw_values&#39;</span><span class="p">)</span>
<span class="go">array([0.967..., 1.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explained_variance_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
<span class="go">0.990...</span>
</pre></div>
</div>
</section>
<section id="max-error">
<span id="id47"></span><h3><span class="section-number">3.3.4.2. </span>Error máximo<a class="headerlink" href="#max-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">max_error</span></code></a> calcula el máximo <a class="reference external" href="https://en.wikipedia.org/wiki/Errors_and_residuals">error residual</a> , una métrica que captura el peor caso de error entre el valor predicho y el valor real. En un modelo de regresión de salida única perfectamente ajustado, <code class="docutils literal notranslate"><span class="pre">max_error</span></code> sería <code class="docutils literal notranslate"><span class="pre">0</span></code> en el conjunto de entrenamiento y, aunque esto sería muy poco probable en el mundo real, esta métrica muestra el grado de error que tuvo el modelo cuando fue ajustado.</p>
<p>Si <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> es el valor predicho de la muestra <code class="docutils literal notranslate"><span class="pre">i</span></code>-ésima :math:, y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces el error máximo se define como</p>
<div class="math notranslate nohighlight">
\[\text{Max Error}(y, \hat{y}) = max(| y_i - \hat{y}_i |)\]</div>
<p>Aquí hay un pequeño ejemplo de uso de la función <code class="xref py py-func docutils literal notranslate"><span class="pre">explained_variance_score</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">max_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>El <a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">max_error</span></code></a> no soporta salidas múltiples.</p>
</section>
<section id="mean-absolute-error">
<span id="id48"></span><h3><span class="section-number">3.3.4.3. </span>Error medio absoluto<a class="headerlink" href="#mean-absolute-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_absolute_error</span></code></a> calcula el <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_absolute_error">error medio absoluto</a>, una métrica de riesgo que corresponde al valor esperado de la pérdida del error absoluto o de la pérdida de la norma <span class="math notranslate nohighlight">\(l1\)</span>.</p>
<p>Si <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> es el valor predicho de la muestra <code class="docutils literal notranslate"><span class="pre">i</span></code>-ésima :math:, y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces el error absoluto promedio (MAE) estimado sobre <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> se define como</p>
<div class="math notranslate nohighlight">
\[\text{MAE}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \left| y_i - \hat{y}_i \right|.\]</div>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_absolute_error</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_absolute_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="s1">&#39;raw_values&#39;</span><span class="p">)</span>
<span class="go">array([0.5, 1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
<span class="go">0.85...</span>
</pre></div>
</div>
</section>
<section id="mean-squared-error">
<span id="id50"></span><h3><span class="section-number">3.3.4.4. </span>Error cuadrático medio<a class="headerlink" href="#mean-squared-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_squared_error</span></code></a> calcula el <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_squared_error">error cuadrático medio</a>, una métrica de riesgo que corresponde al valor esperado del error o pérdida al cuadrado (cuadrático).</p>
<p>Si <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> es el valor predicho de la muestra <code class="docutils literal notranslate"><span class="pre">i</span></code>-ésima :math:, y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces el error cuadrático medio (MSE) estimado sobre <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> se define como</p>
<div class="math notranslate nohighlight">
\[\text{MSE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (y_i - \hat{y}_i)^2.\]</div>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_squared_error</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.375</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.7083...</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Ejemplos:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regression.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-regression-py"><span class="std std-ref">Regresión de Potenciación de Gradiente</span></a> para un ejemplo de uso del error cuadrático medio para evaluar la regresión de gradiente.</p></li>
</ul>
</div>
</section>
<section id="mean-squared-logarithmic-error">
<span id="mean-squared-log-error"></span><h3><span class="section-number">3.3.4.5. </span>Error logarítmico medio cuadrático<a class="headerlink" href="#mean-squared-logarithmic-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error.html#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_squared_log_error</span></code></a> calcula una métrica de riesgo correspondiente al valor esperado del error o pérdida logarítmica (cuadrática) al cuadrado.</p>
<p>Si <span class="math notranslate nohighlight">\(hat{y}_i\)</span> es el valor predicho de la <span class="math notranslate nohighlight">\(i\)</span>-ésima muestra, y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces el error logarítmico medio cuadrático (MSLE) estimado sobre :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>n_{text{samples}} se define como</p>
<div class="math notranslate nohighlight">
\[\text{MSLE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (\log_e (1 + y_i) - \log_e (1 + \hat{y}_i) )^2.\]</div>
<p>Donde <span class="math notranslate nohighlight">\(\log_e (x)\)</span> significa el logaritmo natural de <span class="math notranslate nohighlight">\(x\)</span>. Esta métrica es la mejor para utilizar cuando los objetivos tienen un crecimiento exponencial, como los recuentos de población, las ventas medias de un producto durante un período de años, etc. Ten en cuenta que esta métrica penaliza más una estimación por debajo de lo predicho que una estimación por encima de lo previsto.</p>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error.html#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_squared_log_error</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_log_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_log_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.039...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_log_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.044...</span>
</pre></div>
</div>
</section>
<section id="mean-absolute-percentage-error">
<span id="id51"></span><h3><span class="section-number">3.3.4.6. </span>Error porcentual medio absoluto<a class="headerlink" href="#mean-absolute-percentage-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_absolute_percentage_error</span></code></a> (MAPE), también conocido como desviación porcentual media absoluta (MAPD), es una métrica de evaluación para problemas de regresión. La idea de esta métrica es ser sensible a los errores relativos. Por ejemplo, no cambia por un escalado global de la variable objetivo.</p>
<p>Si <span class="math notranslate nohighlight">\(hat{y}_i\)</span> es el valor predicho de la <span class="math notranslate nohighlight">\(i\)</span>-ésima muestra y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces el error medio porcentual absoluto (MAPE) estimado sobre <span class="math notranslate nohighlight">\(n_{text{samples}}\)</span> se define como</p>
<div class="math notranslate nohighlight">
\[\text{MAPE}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \frac{{}\left| y_i - \hat{y}_i \right|}{max(\epsilon, \left| y_i \right|)}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\epsilon\)</span> es un número arbitrario pequeño pero estrictamente positivo para evitar resultados indefinidos cuando y es cero.</p>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_absolute_percentage_error</span></code></a> soporta salidas múltiples.</p>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_absolute_percentage_error</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_absolute_percentage_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mf">1.2e6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_absolute_percentage_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.2666...</span>
</pre></div>
</div>
<p>En el ejemplo anterior, si hubiéramos utilizado <code class="docutils literal notranslate"><span class="pre">mean_absolute_error</span></code>, se habrían ignorado los valores de magnitud pequeños y sólo reflejarían el error en la predicción del valor de magnitud más alto. Pero ese problema se resuelve en el caso de MAPE porque calcula el porcentaje de error relativo con respecto a la salida real.</p>
</section>
<section id="median-absolute-error">
<span id="id52"></span><h3><span class="section-number">3.3.4.7. </span>Mediana del error absoluto<a class="headerlink" href="#median-absolute-error" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">median_absolute_error</span></code></a> es particularmente interesante porque es robusta a los valores atípicos. La pérdida se calcula tomando la mediana de todas las diferencias absolutas entre el objetivo y la predicción.</p>
<p>Si <span class="math notranslate nohighlight">\(hat{y}_i\)</span> es el valor predicho de la <span class="math notranslate nohighlight">\(i\)</span>-ésima muestra y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces la mediana del error absoluto (MedAE) estimada sobre <span class="math notranslate nohighlight">\(n_{text{samples}}\)</span> se define como</p>
<div class="math notranslate nohighlight">
\[\text{MedAE}(y, \hat{y}) = \text{median}(\mid y_1 - \hat{y}_1 \mid, \ldots, \mid y_n - \hat{y}_n \mid).\]</div>
<p>El <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">median_absolute_error</span></code></a> no soporta múltiples salidas.</p>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">median_absolute_error</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">median_absolute_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">median_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</section>
<section id="r2-score-the-coefficient-of-determination">
<span id="r2-score"></span><h3><span class="section-number">3.3.4.8. </span>La puntuación R², el coeficiente de determinación<a class="headerlink" href="#r2-score-the-coefficient-of-determination" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">r2_score</span></code></a> calcula el <a class="reference external" href="https://en.wikipedia.org/wiki/Coefficient_of_determination">coeficiente de determinación</a>, normalmente denotado como R².</p>
<p>Representa la proporción de la varianza (de y) que ha sido explicada por las variables independientes del modelo. Proporciona una indicación de la bondad del ajuste y, por tanto, una medida de la probabilidad de que las muestras no vistas sean predichas por el modelo, a través de la proporción de varianza explicada.</p>
<p>Como esa varianza depende del conjunto de datos, R² puede no ser significativamente comparable entre diferentes conjuntos de datos. La mejor puntuación posible es 1,0 y puede ser negativa (porque el modelo puede ser arbitrariamente peor). Un modelo constante que siempre predice el valor esperado de y, sin tener en cuenta las características de entrada, obtendría una puntuación R² de 0,0.</p>
<p>Si <span class="math notranslate nohighlight">\(hat{y}_i\)</span> es el valor predicho de la <span class="math notranslate nohighlight">\(i\)</span>-ésima muestra y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente para el total de <span class="math notranslate nohighlight">\(n\)</span> muestras, el R² estimado se define como:</p>
<div class="math notranslate nohighlight">
\[R^2(y, \hat{y}) = 1 - \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\bar{y} = \\frac{1}{n} \\sum_{i=1}^{n} y_i\)</span> y <span class="math notranslate nohighlight">\(\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 = \\sum_{i=1}^{n} \\epsilon_i^2\)</span>.</p>
<p>Ten en cuenta que <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">r2_score</span></code></a> calcula R² no ajustado sin corregir el sesgo en la varianza de muestra de y.</p>
<p>Aquí hay un pequeño ejemplo de uso de la función <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">r2_score</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">r2_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="go">0.948...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="s1">&#39;variance_weighted&#39;</span><span class="p">)</span>
<span class="go">0.938...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="s1">&#39;uniform_average&#39;</span><span class="p">)</span>
<span class="go">0.936...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="s1">&#39;raw_values&#39;</span><span class="p">)</span>
<span class="go">array([0.965..., 0.908...])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">multioutput</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
<span class="go">0.925...</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Example:</p>
<ul class="simple">
<li><p>Ver <a class="reference internal" href="../auto_examples/linear_model/plot_lasso_and_elasticnet.html#sphx-glr-auto-examples-linear-model-plot-lasso-and-elasticnet-py"><span class="std std-ref">Lasso y red elástica para señales dispersas</span></a> para un ejemplo de uso de la puntuación R² para evaluar Lasso y red elástica en señales dispersas.</p></li>
</ul>
</div>
</section>
<section id="mean-poisson-gamma-and-tweedie-deviances">
<span id="mean-tweedie-deviance"></span><h3><span class="section-number">3.3.4.9. </span>Desviaciones medias de Poisson, Gamma y Tweedie<a class="headerlink" href="#mean-poisson-gamma-and-tweedie-deviances" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="generated/sklearn.metrics.mean_tweedie_deviance.html#sklearn.metrics.mean_tweedie_deviance" title="sklearn.metrics.mean_tweedie_deviance"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_tweedie_deviance</span></code></a> calcula el <a class="reference external" href="https://en.wikipedia.org/wiki/Tweedie_distribution#The_Tweedie_deviance">error medio de desviación de Tweedie</a> con un parámetro <code class="docutils literal notranslate"><span class="pre">power</span></code> (<span class="math notranslate nohighlight">\(p\)</span>). Se trata de una métrica que obtiene los valores de expectativa predichos de los objetivos de regresión.</p>
<p>Existen los siguientes casos especiales,</p>
<ul class="simple">
<li><p>cuando <code class="docutils literal notranslate"><span class="pre">power=0</span></code> es equivalente a <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_squared_error</span></code></a>.</p></li>
<li><p>cuando <code class="docutils literal notranslate"><span class="pre">power=1</span></code> es equivalente a <a class="reference internal" href="generated/sklearn.metrics.mean_poisson_deviance.html#sklearn.metrics.mean_poisson_deviance" title="sklearn.metrics.mean_poisson_deviance"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_poisson_deviance</span></code></a>.</p></li>
<li><p>cuando <code class="docutils literal notranslate"><span class="pre">power=2</span></code> es equivalente a <a class="reference internal" href="generated/sklearn.metrics.mean_gamma_deviance.html#sklearn.metrics.mean_gamma_deviance" title="sklearn.metrics.mean_gamma_deviance"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean_gamma_deviance</span></code></a>.</p></li>
</ul>
<p>Si <span class="math notranslate nohighlight">\(hat{y}_i\)</span> es el valor predicho de la <span class="math notranslate nohighlight">\(i\)</span>-ésima muestra, y <span class="math notranslate nohighlight">\(y_i\)</span> es el valor verdadero correspondiente, entonces el error de desviación medio de Tweedie (D) para la potencia <span class="math notranslate nohighlight">\(p\)</span>, estimado sobre :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>n_{text{samples}} se define como</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{D}(y, \hat{y}) = \frac{1}{n_\text{samples}}
\sum_{i=0}^{n_\text{samples} - 1}
\begin{cases}
(y_i-\hat{y}_i)^2, &amp; \text{for }p=0\text{ (Normal)}\\
2(y_i \log(y/\hat{y}_i) + \hat{y}_i - y_i),  &amp; \text{for}p=1\text{ (Poisson)}\\
2(\log(\hat{y}_i/y_i) + y_i/\hat{y}_i - 1),  &amp; \text{for}p=2\text{ (Gamma)}\\
2\left(\frac{\max(y_i,0)^{2-p}}{(1-p)(2-p)}-
\frac{y\,\hat{y}^{1-p}_i}{1-p}+\frac{\hat{y}^{2-p}_i}{2-p}\right),
&amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>La desviación de Tweedie es una función homogénea de grado <code class="docutils literal notranslate"><span class="pre">2-power</span></code>. Así, la distribución Gamma con <code class="docutils literal notranslate"><span class="pre">power=2</span></code> significa que el escalado simultáneo de <code class="docutils literal notranslate"><span class="pre">y_true</span></code> y <code class="docutils literal notranslate"><span class="pre">y_pred</span></code> no tiene ningún efecto sobre la desviación. Para la distribución Poisson <code class="docutils literal notranslate"><span class="pre">power=1</span></code> la desviación escala linealmente, y para la distribución Normal (<code class="docutils literal notranslate"><span class="pre">power=0</span></code>), cuadráticamente.  En general, cuanto más alto sea <code class="docutils literal notranslate"><span class="pre">power</span></code> menor ponderación se da a las desviaciones extremas entre los objetivos verdaderos y los predichos.</p>
<p>Por ejemplo, comparemos las dos predicciones 1.0 y 100 que son el 50% de su valor real correspondiente.</p>
<p>El error cuadrático medio (<code class="docutils literal notranslate"><span class="pre">power=0</span></code>) es muy sensible a la diferencia de predicción del segundo punto,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_tweedie_deviance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_tweedie_deviance</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">power</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_tweedie_deviance</span><span class="p">([</span><span class="mf">100.</span><span class="p">],</span> <span class="p">[</span><span class="mf">150.</span><span class="p">],</span> <span class="n">power</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">2500.0</span>
</pre></div>
</div>
<p>Si incrementamos <code class="docutils literal notranslate"><span class="pre">power</span></code> a 1,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mean_tweedie_deviance</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.18...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_tweedie_deviance</span><span class="p">([</span><span class="mf">100.</span><span class="p">],</span> <span class="p">[</span><span class="mf">150.</span><span class="p">],</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">18.9...</span>
</pre></div>
</div>
<p>la diferencia en errores disminuye. Finalmente, al configurar, <code class="docutils literal notranslate"><span class="pre">power=2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mean_tweedie_deviance</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.14...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_tweedie_deviance</span><span class="p">([</span><span class="mf">100.</span><span class="p">],</span> <span class="p">[</span><span class="mf">150.</span><span class="p">],</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.14...</span>
</pre></div>
</div>
<p>obtendríamos errores idénticos. La desviación cuando <code class="docutils literal notranslate"><span class="pre">power=2</span></code> sólo es sensible a errores relativos.</p>
</section>
</section>
<section id="clustering-metrics">
<span id="id53"></span><h2><span class="section-number">3.3.5. </span>Métricas de agrupamiento<a class="headerlink" href="#clustering-metrics" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <a class="reference internal" href="classes.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics</span></code></a> implementa varias funciones de pérdida, puntuación y utilidad. Para más información, consulta la sección <a class="reference internal" href="clustering.html#clustering-evaluation"><span class="std std-ref">Evaluación del rendimiento del análisis de conglomerados (agrupamiento)</span></a> para el clustering de instancia, y <a class="reference internal" href="biclustering.html#biclustering-evaluation"><span class="std std-ref">Evaluación de Biclustering</span></a> para el biclustering.</p>
</section>
<section id="dummy-estimators">
<span id="id54"></span><h2><span class="section-number">3.3.6. </span>Estimadores de prueba<a class="headerlink" href="#dummy-estimators" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Cuando se realiza un aprendizaje supervisado, una simple comprobación de cordura consiste en comparar el estimador propio con reglas simples. <a class="reference internal" href="generated/sklearn.dummy.DummyClassifier.html#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DummyClassifier</span></code></a> implementa varias de estas estrategias simples para la clasificación:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stratified</span></code> genera predicciones aleatorias respetando la distribución de la clase del conjunto de entrenamiento.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">most_frequent</span></code> siempre predice la etiqueta más frecuente en el conjunto de entrenamiento.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prior</span></code> siempre predice la clase que maximiza la clase anterior (como <code class="docutils literal notranslate"><span class="pre">most_frequent</span></code>) y <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> devuelve la clase anterior.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uniform</span></code> genera predicciones uniformemente al azar.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">constant</span></code> siempre predice un valor constante proporcionado por el usuario.</dt><dd><p>Una motivación importante de este método es la puntuación F1, cuando la clase positiva está en la minoría.</p>
</dd>
</dl>
</li>
</ul>
<p>Ten en cuenta que con todas estas estrategias, ¡el método <code class="docutils literal notranslate"><span class="pre">predict</span></code> ignora completamente los datos de entrada!</p>
<p>Para ilustrar <a class="reference internal" href="generated/sklearn.dummy.DummyClassifier.html#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DummyClassifier</span></code></a>, primero vamos a crear un conjunto de datos no balanceado:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>A continuación, comparemos la precisión de <code class="docutils literal notranslate"><span class="pre">SVC</span></code> y <code class="docutils literal notranslate"><span class="pre">most_frequent</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.dummy</span> <span class="kn">import</span> <span class="n">DummyClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="go">0.63...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">DummyClassifier</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;most_frequent&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">DummyClassifier(random_state=0, strategy=&#39;most_frequent&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="go">0.57...</span>
</pre></div>
</div>
<p>Vemos que <code class="docutils literal notranslate"><span class="pre">SVC</span></code> no lo hace mucho mejor que un clasificador ficticio. Ahora, vamos a cambiar el núcleo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="go">0.94...</span>
</pre></div>
</div>
<p>Vemos que la precisión aumentó hasta casi el 100%.  Se recomienda una estrategia de validación cruzada para una mejor estimación de la precisión, si no es demasiado costosa para la CPU. Para más información, consulte la sección <a class="reference internal" href="cross_validation.html#cross-validation"><span class="std std-ref">Validación cruzada: evaluación del rendimiento del estimador</span></a>. Además, si quieres optimizar el espacio de los parámetros, es muy recomendable utilizar una metodología adecuada; consulta la sección <a class="reference internal" href="grid_search.html#grid-search"><span class="std std-ref">Ajustar los hiperparámetros de un estimador</span></a> para más detalles.</p>
<p>En términos más generales, cuando la precisión de un clasificador está demasiado cerca de ser aleatorio, probablemente significa que algo salió mal: las características no son útiles, un hiperparámetro no está correctamente sintonizado, el clasificador sufre de desbalance de clase, etc…</p>
<p><a class="reference internal" href="generated/sklearn.dummy.DummyRegressor.html#sklearn.dummy.DummyRegressor" title="sklearn.dummy.DummyRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">DummyRegressor</span></code></a> también implementa cuatro simples reglas generales para la regresión:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mean</span></code> siempre predice la media de los objetivos de entrenamiento.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">median</span></code> siempre predice la mediana de los objetivos de entrenamiento.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quantile</span></code> siempre predice un cuantil proporcionado por el usuario de los objetivos de entrenamiento.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code> siempre predice un valor constante proporcionado por el usuario.</p></li>
</ul>
<p>En todas estas estrategias, el método de <code class="docutils literal notranslate"><span class="pre">predict</span></code> ignora completamente los datos de entrada.</p>
</section>
</section>


      </div>
    <div class="container">
      <footer class="sk-content-footer">
            &copy; 2007 - 2020, scikit-learn developers (BSD License).
          <a href="../_sources/modules/model_evaluation.rst.txt" rel="nofollow">Mostrar la fuente de esta página</a>
      </footer>
    </div>
  </div>
</div>
<script src="../_static/js/vendor/bootstrap.min.js"></script>

<script>
    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
    ga('create', 'UA-22606712-2', 'auto');
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script>
$(document).ready(function() {
    /* Add a [>>>] button on the top-right corner of code samples to hide
     * the >>> and ... prompts and the output and thus make the code
     * copyable. */
    var div = $('.highlight-python .highlight,' +
                '.highlight-python3 .highlight,' +
                '.highlight-pycon .highlight,' +
		'.highlight-default .highlight')
    var pre = div.find('pre');

    // get the styles from the current theme
    pre.parent().parent().css('position', 'relative');
    var hide_text = 'Hide prompts and outputs';
    var show_text = 'Show prompts and outputs';

    // create and add the button to all the code blocks that contain >>>
    div.each(function(index) {
        var jthis = $(this);
        if (jthis.find('.gp').length > 0) {
            var button = $('<span class="copybutton">&gt;&gt;&gt;</span>');
            button.attr('title', hide_text);
            button.data('hidden', 'false');
            jthis.prepend(button);
        }
        // tracebacks (.gt) contain bare text elements that need to be
        // wrapped in a span to work with .nextUntil() (see later)
        jthis.find('pre:has(.gt)').contents().filter(function() {
            return ((this.nodeType == 3) && (this.data.trim().length > 0));
        }).wrap('<span>');
    });

    // define the behavior of the button when it's clicked
    $('.copybutton').click(function(e){
        e.preventDefault();
        var button = $(this);
        if (button.data('hidden') === 'false') {
            // hide the code output
            button.parent().find('.go, .gp, .gt').hide();
            button.next('pre').find('.gt').nextUntil('.gp, .go').css('visibility', 'hidden');
            button.css('text-decoration', 'line-through');
            button.attr('title', show_text);
            button.data('hidden', 'true');
        } else {
            // show the code output
            button.parent().find('.go, .gp, .gt').show();
            button.next('pre').find('.gt').nextUntil('.gp, .go').css('visibility', 'visible');
            button.css('text-decoration', 'none');
            button.attr('title', hide_text);
            button.data('hidden', 'false');
        }
    });

	/*** Add permalink buttons next to glossary terms ***/
	$('dl.glossary > dt[id]').append(function() {
		return ('<a class="headerlink" href="#' +
			    this.getAttribute('id') +
			    '" title="Permalink to this term">¶</a>');
	});
  /*** Hide navbar when scrolling down ***/
  // Returns true when headerlink target matches hash in url
  (function() {
    hashTargetOnTop = function() {
        var hash = window.location.hash;
        if ( hash.length < 2 ) { return false; }

        var target = document.getElementById( hash.slice(1) );
        if ( target === null ) { return false; }

        var top = target.getBoundingClientRect().top;
        return (top < 2) && (top > -2);
    };

    // Hide navbar on load if hash target is on top
    var navBar = document.getElementById("navbar");
    var navBarToggler = document.getElementById("sk-navbar-toggler");
    var navBarHeightHidden = "-" + navBar.getBoundingClientRect().height + "px";
    var $window = $(window);

    hideNavBar = function() {
        navBar.style.top = navBarHeightHidden;
    };

    showNavBar = function() {
        navBar.style.top = "0";
    }

    if (hashTargetOnTop()) {
        hideNavBar()
    }

    var prevScrollpos = window.pageYOffset;
    hideOnScroll = function(lastScrollTop) {
        if (($window.width() < 768) && (navBarToggler.getAttribute("aria-expanded") === 'true')) {
            return;
        }
        if (lastScrollTop > 2 && (prevScrollpos <= lastScrollTop) || hashTargetOnTop()){
            hideNavBar()
        } else {
            showNavBar()
        }
        prevScrollpos = lastScrollTop;
    };

    /*** high performance scroll event listener***/
    var raf = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame;
    var lastScrollTop = $window.scrollTop();

    if (raf) {
        loop();
    }

    function loop() {
        var scrollTop = $window.scrollTop();
        if (lastScrollTop === scrollTop) {
            raf(loop);
            return;
        } else {
            lastScrollTop = scrollTop;
            hideOnScroll(lastScrollTop);
            raf(loop);
        }
    }
  })();
});

</script>
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
</body>
</html>